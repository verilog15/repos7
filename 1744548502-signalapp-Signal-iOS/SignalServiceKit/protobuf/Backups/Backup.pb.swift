//
// Copyright 2024 Signal Messenger, LLC
// SPDX-License-Identifier: AGPL-3.0-only
//

// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Backup.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
// Copyright 2024 Signal Messenger, LLC
// SPDX-License-Identifier: AGPL-3.0-only

public import Foundation
public import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// If unset - computed as the value of the first byte of SHA-256(msg=CONTACT_ID)
/// modulo the count of colors. Once set the avatar color for a recipient is
/// never recomputed or changed.
///
/// `CONTACT_ID` is the first available identifier from the list:
/// - ServiceIdToBinary(ACI)
/// - E164
/// - ServiceIdToBinary(PNI)
/// - Group Id
public enum BackupProto_AvatarColor: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case a100 // = 0
  case a110 // = 1
  case a120 // = 2
  case a130 // = 3
  case a140 // = 4
  case a150 // = 5
  case a160 // = 6
  case a170 // = 7
  case a180 // = 8
  case a190 // = 9
  case a200 // = 10
  case a210 // = 11
  case UNRECOGNIZED(Int)

  public init() {
    self = .a100
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .a100
    case 1: self = .a110
    case 2: self = .a120
    case 3: self = .a130
    case 4: self = .a140
    case 5: self = .a150
    case 6: self = .a160
    case 7: self = .a170
    case 8: self = .a180
    case 9: self = .a190
    case 10: self = .a200
    case 11: self = .a210
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .a100: return 0
    case .a110: return 1
    case .a120: return 2
    case .a130: return 3
    case .a140: return 4
    case .a150: return 5
    case .a160: return 6
    case .a170: return 7
    case .a180: return 8
    case .a190: return 9
    case .a200: return 10
    case .a210: return 11
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [BackupProto_AvatarColor] = [
    .a100,
    .a110,
    .a120,
    .a130,
    .a140,
    .a150,
    .a160,
    .a170,
    .a180,
    .a190,
    .a200,
    .a210,
  ]

}

public enum BackupProto_GroupV2AccessLevel: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// Interpret as "Unsatisfiable"
  case unknown // = 0
  case any // = 1
  case member // = 2
  case administrator // = 3
  case unsatisfiable // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .any
    case 2: self = .member
    case 3: self = .administrator
    case 4: self = .unsatisfiable
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .any: return 1
    case .member: return 2
    case .administrator: return 3
    case .unsatisfiable: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [BackupProto_GroupV2AccessLevel] = [
    .unknown,
    .any,
    .member,
    .administrator,
    .unsatisfiable,
  ]

}

public struct BackupProto_BackupInfo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var version: UInt64 = 0

  public var backupTimeMs: UInt64 = 0

  /// 32-byte random value generated when the backup is uploaded for the first time.
  public var mediaRootBackupKey: Data = Data()

  public var currentAppVersion: String = String()

  public var firstAppVersion: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Frames must follow in the following ordering rules:
///
/// 1. There is exactly one AccountData and it is the first frame.
/// 2. A frame referenced by ID must come before the referencing frame.
///    e.g. a Recipient must come before any Chat referencing it.
/// 3. All ChatItems must appear in global Chat rendering order.
///    (The order in which they were received by the client.)
/// 4. ChatFolders must appear in render order (e.g., left to right for
///    LTR locales), but can appear anywhere relative to other frames respecting
///    rule 2 (after Recipients and Chats).
///
/// Recipients, Chats, StickerPacks, AdHocCalls, and NotificationProfiles
/// can be in any order. (But must respect rule 2.)
///
/// For example, Chats may all be together at the beginning,
/// or may each immediately precede its first ChatItem.
public struct BackupProto_Frame: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If unset, importers should skip this frame without throwing an error.
  public var item: BackupProto_Frame.OneOf_Item? = nil

  public var account: BackupProto_AccountData {
    get {
      if case .account(let v)? = item {return v}
      return BackupProto_AccountData()
    }
    set {item = .account(newValue)}
  }

  public var recipient: BackupProto_Recipient {
    get {
      if case .recipient(let v)? = item {return v}
      return BackupProto_Recipient()
    }
    set {item = .recipient(newValue)}
  }

  public var chat: BackupProto_Chat {
    get {
      if case .chat(let v)? = item {return v}
      return BackupProto_Chat()
    }
    set {item = .chat(newValue)}
  }

  public var chatItem: BackupProto_ChatItem {
    get {
      if case .chatItem(let v)? = item {return v}
      return BackupProto_ChatItem()
    }
    set {item = .chatItem(newValue)}
  }

  public var stickerPack: BackupProto_StickerPack {
    get {
      if case .stickerPack(let v)? = item {return v}
      return BackupProto_StickerPack()
    }
    set {item = .stickerPack(newValue)}
  }

  public var adHocCall: BackupProto_AdHocCall {
    get {
      if case .adHocCall(let v)? = item {return v}
      return BackupProto_AdHocCall()
    }
    set {item = .adHocCall(newValue)}
  }

  public var notificationProfile: BackupProto_NotificationProfile {
    get {
      if case .notificationProfile(let v)? = item {return v}
      return BackupProto_NotificationProfile()
    }
    set {item = .notificationProfile(newValue)}
  }

  public var chatFolder: BackupProto_ChatFolder {
    get {
      if case .chatFolder(let v)? = item {return v}
      return BackupProto_ChatFolder()
    }
    set {item = .chatFolder(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// If unset, importers should skip this frame without throwing an error.
  public enum OneOf_Item: Equatable, Sendable {
    case account(BackupProto_AccountData)
    case recipient(BackupProto_Recipient)
    case chat(BackupProto_Chat)
    case chatItem(BackupProto_ChatItem)
    case stickerPack(BackupProto_StickerPack)
    case adHocCall(BackupProto_AdHocCall)
    case notificationProfile(BackupProto_NotificationProfile)
    case chatFolder(BackupProto_ChatFolder)

  }

  public init() {}
}

public struct BackupProto_AccountData: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var profileKey: Data = Data()

  public var username: String {
    get {return _username ?? String()}
    set {_username = newValue}
  }
  /// Returns true if `username` has been explicitly set.
  public var hasUsername: Bool {return self._username != nil}
  /// Clears the value of `username`. Subsequent reads from it will return its default value.
  public mutating func clearUsername() {self._username = nil}

  public var usernameLink: BackupProto_AccountData.UsernameLink {
    get {return _usernameLink ?? BackupProto_AccountData.UsernameLink()}
    set {_usernameLink = newValue}
  }
  /// Returns true if `usernameLink` has been explicitly set.
  public var hasUsernameLink: Bool {return self._usernameLink != nil}
  /// Clears the value of `usernameLink`. Subsequent reads from it will return its default value.
  public mutating func clearUsernameLink() {self._usernameLink = nil}

  public var givenName: String = String()

  public var familyName: String = String()

  public var avatarURLPath: String = String()

  public var donationSubscriberData: BackupProto_AccountData.SubscriberData {
    get {return _donationSubscriberData ?? BackupProto_AccountData.SubscriberData()}
    set {_donationSubscriberData = newValue}
  }
  /// Returns true if `donationSubscriberData` has been explicitly set.
  public var hasDonationSubscriberData: Bool {return self._donationSubscriberData != nil}
  /// Clears the value of `donationSubscriberData`. Subsequent reads from it will return its default value.
  public mutating func clearDonationSubscriberData() {self._donationSubscriberData = nil}

  public var accountSettings: BackupProto_AccountData.AccountSettings {
    get {return _accountSettings ?? BackupProto_AccountData.AccountSettings()}
    set {_accountSettings = newValue}
  }
  /// Returns true if `accountSettings` has been explicitly set.
  public var hasAccountSettings: Bool {return self._accountSettings != nil}
  /// Clears the value of `accountSettings`. Subsequent reads from it will return its default value.
  public mutating func clearAccountSettings() {self._accountSettings = nil}

  public var backupsSubscriberData: BackupProto_AccountData.IAPSubscriberData {
    get {return _backupsSubscriberData ?? BackupProto_AccountData.IAPSubscriberData()}
    set {_backupsSubscriberData = newValue}
  }
  /// Returns true if `backupsSubscriberData` has been explicitly set.
  public var hasBackupsSubscriberData: Bool {return self._backupsSubscriberData != nil}
  /// Clears the value of `backupsSubscriberData`. Subsequent reads from it will return its default value.
  public mutating func clearBackupsSubscriberData() {self._backupsSubscriberData = nil}

  public var svrPin: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum PhoneNumberSharingMode: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Interpret as "Nobody"
    case unknown // = 0
    case everybody // = 1
    case nobody // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .everybody
      case 2: self = .nobody
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .everybody: return 1
      case .nobody: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [BackupProto_AccountData.PhoneNumberSharingMode] = [
      .unknown,
      .everybody,
      .nobody,
    ]

  }

  public struct UsernameLink: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// 32 bytes of entropy used for encryption
    public var entropy: Data = Data()

    /// 16 bytes of encoded UUID provided by the server
    public var serverID: Data = Data()

    public var color: BackupProto_AccountData.UsernameLink.Color = .unknown

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Color: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int

      /// Interpret as "Blue"
      case unknown // = 0
      case blue // = 1
      case white // = 2
      case grey // = 3
      case olive // = 4
      case green // = 5
      case orange // = 6
      case pink // = 7
      case purple // = 8
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .blue
        case 2: self = .white
        case 3: self = .grey
        case 4: self = .olive
        case 5: self = .green
        case 6: self = .orange
        case 7: self = .pink
        case 8: self = .purple
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .blue: return 1
        case .white: return 2
        case .grey: return 3
        case .olive: return 4
        case .green: return 5
        case .orange: return 6
        case .pink: return 7
        case .purple: return 8
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [BackupProto_AccountData.UsernameLink.Color] = [
        .unknown,
        .blue,
        .white,
        .grey,
        .olive,
        .green,
        .orange,
        .pink,
        .purple,
      ]

    }

    public init() {}
  }

  public struct AccountSettings: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var readReceipts: Bool {
      get {return _storage._readReceipts}
      set {_uniqueStorage()._readReceipts = newValue}
    }

    public var sealedSenderIndicators: Bool {
      get {return _storage._sealedSenderIndicators}
      set {_uniqueStorage()._sealedSenderIndicators = newValue}
    }

    public var typingIndicators: Bool {
      get {return _storage._typingIndicators}
      set {_uniqueStorage()._typingIndicators = newValue}
    }

    public var linkPreviews: Bool {
      get {return _storage._linkPreviews}
      set {_uniqueStorage()._linkPreviews = newValue}
    }

    public var notDiscoverableByPhoneNumber: Bool {
      get {return _storage._notDiscoverableByPhoneNumber}
      set {_uniqueStorage()._notDiscoverableByPhoneNumber = newValue}
    }

    public var preferContactAvatars: Bool {
      get {return _storage._preferContactAvatars}
      set {_uniqueStorage()._preferContactAvatars = newValue}
    }

    /// 0 means no universal expire timer.
    public var universalExpireTimerSeconds: UInt32 {
      get {return _storage._universalExpireTimerSeconds}
      set {_uniqueStorage()._universalExpireTimerSeconds = newValue}
    }

    public var preferredReactionEmoji: [String] {
      get {return _storage._preferredReactionEmoji}
      set {_uniqueStorage()._preferredReactionEmoji = newValue}
    }

    public var displayBadgesOnProfile: Bool {
      get {return _storage._displayBadgesOnProfile}
      set {_uniqueStorage()._displayBadgesOnProfile = newValue}
    }

    public var keepMutedChatsArchived: Bool {
      get {return _storage._keepMutedChatsArchived}
      set {_uniqueStorage()._keepMutedChatsArchived = newValue}
    }

    public var hasSetMyStoriesPrivacy_p: Bool {
      get {return _storage._hasSetMyStoriesPrivacy_p}
      set {_uniqueStorage()._hasSetMyStoriesPrivacy_p = newValue}
    }

    public var hasViewedOnboardingStory_p: Bool {
      get {return _storage._hasViewedOnboardingStory_p}
      set {_uniqueStorage()._hasViewedOnboardingStory_p = newValue}
    }

    public var storiesDisabled: Bool {
      get {return _storage._storiesDisabled}
      set {_uniqueStorage()._storiesDisabled = newValue}
    }

    public var storyViewReceiptsEnabled: Bool {
      get {return _storage._storyViewReceiptsEnabled ?? false}
      set {_uniqueStorage()._storyViewReceiptsEnabled = newValue}
    }
    /// Returns true if `storyViewReceiptsEnabled` has been explicitly set.
    public var hasStoryViewReceiptsEnabled: Bool {return _storage._storyViewReceiptsEnabled != nil}
    /// Clears the value of `storyViewReceiptsEnabled`. Subsequent reads from it will return its default value.
    public mutating func clearStoryViewReceiptsEnabled() {_uniqueStorage()._storyViewReceiptsEnabled = nil}

    public var hasSeenGroupStoryEducationSheet_p: Bool {
      get {return _storage._hasSeenGroupStoryEducationSheet_p}
      set {_uniqueStorage()._hasSeenGroupStoryEducationSheet_p = newValue}
    }

    public var hasCompletedUsernameOnboarding_p: Bool {
      get {return _storage._hasCompletedUsernameOnboarding_p}
      set {_uniqueStorage()._hasCompletedUsernameOnboarding_p = newValue}
    }

    public var phoneNumberSharingMode: BackupProto_AccountData.PhoneNumberSharingMode {
      get {return _storage._phoneNumberSharingMode}
      set {_uniqueStorage()._phoneNumberSharingMode = newValue}
    }

    public var defaultChatStyle: BackupProto_ChatStyle {
      get {return _storage._defaultChatStyle ?? BackupProto_ChatStyle()}
      set {_uniqueStorage()._defaultChatStyle = newValue}
    }
    /// Returns true if `defaultChatStyle` has been explicitly set.
    public var hasDefaultChatStyle: Bool {return _storage._defaultChatStyle != nil}
    /// Clears the value of `defaultChatStyle`. Subsequent reads from it will return its default value.
    public mutating func clearDefaultChatStyle() {_uniqueStorage()._defaultChatStyle = nil}

    public var customChatColors: [BackupProto_ChatStyle.CustomChatColor] {
      get {return _storage._customChatColors}
      set {_uniqueStorage()._customChatColors = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct SubscriberData: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var subscriberID: Data = Data()

    public var currencyCode: String = String()

    public var manuallyCancelled: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct IAPSubscriberData: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var subscriberID: Data = Data()

    /// If unset, importers should ignore the subscriber data without throwing an error.
    public var iapSubscriptionID: BackupProto_AccountData.IAPSubscriberData.OneOf_IapSubscriptionID? = nil

    /// Identifies an Android Play Store IAP subscription.
    public var purchaseToken: String {
      get {
        if case .purchaseToken(let v)? = iapSubscriptionID {return v}
        return String()
      }
      set {iapSubscriptionID = .purchaseToken(newValue)}
    }

    /// Identifies an iOS App Store IAP subscription.
    public var originalTransactionID: UInt64 {
      get {
        if case .originalTransactionID(let v)? = iapSubscriptionID {return v}
        return 0
      }
      set {iapSubscriptionID = .originalTransactionID(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// If unset, importers should ignore the subscriber data without throwing an error.
    public enum OneOf_IapSubscriptionID: Equatable, Sendable {
      /// Identifies an Android Play Store IAP subscription.
      case purchaseToken(String)
      /// Identifies an iOS App Store IAP subscription.
      case originalTransactionID(UInt64)

    }

    public init() {}
  }

  public init() {}

  fileprivate var _username: String? = nil
  fileprivate var _usernameLink: BackupProto_AccountData.UsernameLink? = nil
  fileprivate var _donationSubscriberData: BackupProto_AccountData.SubscriberData? = nil
  fileprivate var _accountSettings: BackupProto_AccountData.AccountSettings? = nil
  fileprivate var _backupsSubscriberData: BackupProto_AccountData.IAPSubscriberData? = nil
}

public struct BackupProto_Recipient: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// generated id for reference only within this file
  public var id: UInt64 = 0

  /// If unset, importers should skip this frame without throwing an error.
  public var destination: BackupProto_Recipient.OneOf_Destination? = nil

  public var contact: BackupProto_Contact {
    get {
      if case .contact(let v)? = destination {return v}
      return BackupProto_Contact()
    }
    set {destination = .contact(newValue)}
  }

  public var group: BackupProto_Group {
    get {
      if case .group(let v)? = destination {return v}
      return BackupProto_Group()
    }
    set {destination = .group(newValue)}
  }

  public var distributionList: BackupProto_DistributionListItem {
    get {
      if case .distributionList(let v)? = destination {return v}
      return BackupProto_DistributionListItem()
    }
    set {destination = .distributionList(newValue)}
  }

  public var self_p: BackupProto_Self {
    get {
      if case .self_p(let v)? = destination {return v}
      return BackupProto_Self()
    }
    set {destination = .self_p(newValue)}
  }

  public var releaseNotes: BackupProto_ReleaseNotes {
    get {
      if case .releaseNotes(let v)? = destination {return v}
      return BackupProto_ReleaseNotes()
    }
    set {destination = .releaseNotes(newValue)}
  }

  public var callLink: BackupProto_CallLink {
    get {
      if case .callLink(let v)? = destination {return v}
      return BackupProto_CallLink()
    }
    set {destination = .callLink(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// If unset, importers should skip this frame without throwing an error.
  public enum OneOf_Destination: Equatable, Sendable {
    case contact(BackupProto_Contact)
    case group(BackupProto_Group)
    case distributionList(BackupProto_DistributionListItem)
    case self_p(BackupProto_Self)
    case releaseNotes(BackupProto_ReleaseNotes)
    case callLink(BackupProto_CallLink)

  }

  public init() {}
}

public struct BackupProto_Contact: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// should be 16 bytes
  public var aci: Data {
    get {return _storage._aci ?? Data()}
    set {_uniqueStorage()._aci = newValue}
  }
  /// Returns true if `aci` has been explicitly set.
  public var hasAci: Bool {return _storage._aci != nil}
  /// Clears the value of `aci`. Subsequent reads from it will return its default value.
  public mutating func clearAci() {_uniqueStorage()._aci = nil}

  /// should be 16 bytes
  public var pni: Data {
    get {return _storage._pni ?? Data()}
    set {_uniqueStorage()._pni = newValue}
  }
  /// Returns true if `pni` has been explicitly set.
  public var hasPni: Bool {return _storage._pni != nil}
  /// Clears the value of `pni`. Subsequent reads from it will return its default value.
  public mutating func clearPni() {_uniqueStorage()._pni = nil}

  public var username: String {
    get {return _storage._username ?? String()}
    set {_uniqueStorage()._username = newValue}
  }
  /// Returns true if `username` has been explicitly set.
  public var hasUsername: Bool {return _storage._username != nil}
  /// Clears the value of `username`. Subsequent reads from it will return its default value.
  public mutating func clearUsername() {_uniqueStorage()._username = nil}

  public var e164: UInt64 {
    get {return _storage._e164 ?? 0}
    set {_uniqueStorage()._e164 = newValue}
  }
  /// Returns true if `e164` has been explicitly set.
  public var hasE164: Bool {return _storage._e164 != nil}
  /// Clears the value of `e164`. Subsequent reads from it will return its default value.
  public mutating func clearE164() {_uniqueStorage()._e164 = nil}

  public var blocked: Bool {
    get {return _storage._blocked}
    set {_uniqueStorage()._blocked = newValue}
  }

  public var visibility: BackupProto_Contact.Visibility {
    get {return _storage._visibility}
    set {_uniqueStorage()._visibility = newValue}
  }

  /// If unset, consider the user to be registered
  public var registration: OneOf_Registration? {
    get {return _storage._registration}
    set {_uniqueStorage()._registration = newValue}
  }

  public var registered: BackupProto_Contact.Registered {
    get {
      if case .registered(let v)? = _storage._registration {return v}
      return BackupProto_Contact.Registered()
    }
    set {_uniqueStorage()._registration = .registered(newValue)}
  }

  public var notRegistered: BackupProto_Contact.NotRegistered {
    get {
      if case .notRegistered(let v)? = _storage._registration {return v}
      return BackupProto_Contact.NotRegistered()
    }
    set {_uniqueStorage()._registration = .notRegistered(newValue)}
  }

  public var profileKey: Data {
    get {return _storage._profileKey ?? Data()}
    set {_uniqueStorage()._profileKey = newValue}
  }
  /// Returns true if `profileKey` has been explicitly set.
  public var hasProfileKey: Bool {return _storage._profileKey != nil}
  /// Clears the value of `profileKey`. Subsequent reads from it will return its default value.
  public mutating func clearProfileKey() {_uniqueStorage()._profileKey = nil}

  public var profileSharing: Bool {
    get {return _storage._profileSharing}
    set {_uniqueStorage()._profileSharing = newValue}
  }

  public var profileGivenName: String {
    get {return _storage._profileGivenName ?? String()}
    set {_uniqueStorage()._profileGivenName = newValue}
  }
  /// Returns true if `profileGivenName` has been explicitly set.
  public var hasProfileGivenName: Bool {return _storage._profileGivenName != nil}
  /// Clears the value of `profileGivenName`. Subsequent reads from it will return its default value.
  public mutating func clearProfileGivenName() {_uniqueStorage()._profileGivenName = nil}

  public var profileFamilyName: String {
    get {return _storage._profileFamilyName ?? String()}
    set {_uniqueStorage()._profileFamilyName = newValue}
  }
  /// Returns true if `profileFamilyName` has been explicitly set.
  public var hasProfileFamilyName: Bool {return _storage._profileFamilyName != nil}
  /// Clears the value of `profileFamilyName`. Subsequent reads from it will return its default value.
  public mutating func clearProfileFamilyName() {_uniqueStorage()._profileFamilyName = nil}

  public var hideStory: Bool {
    get {return _storage._hideStory}
    set {_uniqueStorage()._hideStory = newValue}
  }

  public var identityKey: Data {
    get {return _storage._identityKey ?? Data()}
    set {_uniqueStorage()._identityKey = newValue}
  }
  /// Returns true if `identityKey` has been explicitly set.
  public var hasIdentityKey: Bool {return _storage._identityKey != nil}
  /// Clears the value of `identityKey`. Subsequent reads from it will return its default value.
  public mutating func clearIdentityKey() {_uniqueStorage()._identityKey = nil}

  public var identityState: BackupProto_Contact.IdentityState {
    get {return _storage._identityState}
    set {_uniqueStorage()._identityState = newValue}
  }

  /// absent iff both `given` and `family` are empty
  public var nickname: BackupProto_Contact.Name {
    get {return _storage._nickname ?? BackupProto_Contact.Name()}
    set {_uniqueStorage()._nickname = newValue}
  }
  /// Returns true if `nickname` has been explicitly set.
  public var hasNickname: Bool {return _storage._nickname != nil}
  /// Clears the value of `nickname`. Subsequent reads from it will return its default value.
  public mutating func clearNickname() {_uniqueStorage()._nickname = nil}

  public var note: String {
    get {return _storage._note}
    set {_uniqueStorage()._note = newValue}
  }

  public var systemGivenName: String {
    get {return _storage._systemGivenName}
    set {_uniqueStorage()._systemGivenName = newValue}
  }

  public var systemFamilyName: String {
    get {return _storage._systemFamilyName}
    set {_uniqueStorage()._systemFamilyName = newValue}
  }

  public var systemNickname: String {
    get {return _storage._systemNickname}
    set {_uniqueStorage()._systemNickname = newValue}
  }

  public var avatarColor: BackupProto_AvatarColor {
    get {return _storage._avatarColor ?? .a100}
    set {_uniqueStorage()._avatarColor = newValue}
  }
  /// Returns true if `avatarColor` has been explicitly set.
  public var hasAvatarColor: Bool {return _storage._avatarColor != nil}
  /// Clears the value of `avatarColor`. Subsequent reads from it will return its default value.
  public mutating func clearAvatarColor() {_uniqueStorage()._avatarColor = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// If unset, consider the user to be registered
  public enum OneOf_Registration: Equatable, Sendable {
    case registered(BackupProto_Contact.Registered)
    case notRegistered(BackupProto_Contact.NotRegistered)

  }

  public enum IdentityState: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// A valid value -- indicates unset by the user
    case `default` // = 0
    case verified // = 1

    /// Was once verified and is now unverified
    case unverified // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .default
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .default
      case 1: self = .verified
      case 2: self = .unverified
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .default: return 0
      case .verified: return 1
      case .unverified: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [BackupProto_Contact.IdentityState] = [
      .default,
      .verified,
      .unverified,
    ]

  }

  public enum Visibility: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// A valid value -- the contact is not hidden
    case visible // = 0
    case hidden // = 1
    case hiddenMessageRequest // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .visible
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .visible
      case 1: self = .hidden
      case 2: self = .hiddenMessageRequest
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .visible: return 0
      case .hidden: return 1
      case .hiddenMessageRequest: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [BackupProto_Contact.Visibility] = [
      .visible,
      .hidden,
      .hiddenMessageRequest,
    ]

  }

  public struct Registered: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct NotRegistered: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unregisteredTimestamp: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Name: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var given: String = String()

    public var family: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct BackupProto_Group: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var masterKey: Data {
    get {return _storage._masterKey}
    set {_uniqueStorage()._masterKey = newValue}
  }

  public var whitelisted: Bool {
    get {return _storage._whitelisted}
    set {_uniqueStorage()._whitelisted = newValue}
  }

  public var hideStory: Bool {
    get {return _storage._hideStory}
    set {_uniqueStorage()._hideStory = newValue}
  }

  public var storySendMode: BackupProto_Group.StorySendMode {
    get {return _storage._storySendMode}
    set {_uniqueStorage()._storySendMode = newValue}
  }

  public var snapshot: BackupProto_Group.GroupSnapshot {
    get {return _storage._snapshot ?? BackupProto_Group.GroupSnapshot()}
    set {_uniqueStorage()._snapshot = newValue}
  }
  /// Returns true if `snapshot` has been explicitly set.
  public var hasSnapshot: Bool {return _storage._snapshot != nil}
  /// Clears the value of `snapshot`. Subsequent reads from it will return its default value.
  public mutating func clearSnapshot() {_uniqueStorage()._snapshot = nil}

  public var blocked: Bool {
    get {return _storage._blocked}
    set {_uniqueStorage()._blocked = newValue}
  }

  public var avatarColor: BackupProto_AvatarColor {
    get {return _storage._avatarColor ?? .a100}
    set {_uniqueStorage()._avatarColor = newValue}
  }
  /// Returns true if `avatarColor` has been explicitly set.
  public var hasAvatarColor: Bool {return _storage._avatarColor != nil}
  /// Clears the value of `avatarColor`. Subsequent reads from it will return its default value.
  public mutating func clearAvatarColor() {_uniqueStorage()._avatarColor = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum StorySendMode: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// A valid value -- indicates unset by the user
    case `default` // = 0
    case disabled // = 1
    case enabled // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .default
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .default
      case 1: self = .disabled
      case 2: self = .enabled
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .default: return 0
      case .disabled: return 1
      case .enabled: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [BackupProto_Group.StorySendMode] = [
      .default,
      .disabled,
      .enabled,
    ]

  }

  /// These are simply plaintext copies of the groups proto from Groups.proto.
  /// They should be kept completely in-sync with Groups.proto.
  /// These exist to allow us to have the latest snapshot of a group during restoration without having to hit the network.
  /// We would use Groups.proto if we could, but we want a plaintext version to improve export readability.
  /// For documentation, defer to Groups.proto. The only name change is Group -> GroupSnapshot to avoid the naming conflict.
  public struct GroupSnapshot: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var title: BackupProto_Group.GroupAttributeBlob {
      get {return _title ?? BackupProto_Group.GroupAttributeBlob()}
      set {_title = newValue}
    }
    /// Returns true if `title` has been explicitly set.
    public var hasTitle: Bool {return self._title != nil}
    /// Clears the value of `title`. Subsequent reads from it will return its default value.
    public mutating func clearTitle() {self._title = nil}

    public var description_p: BackupProto_Group.GroupAttributeBlob {
      get {return _description_p ?? BackupProto_Group.GroupAttributeBlob()}
      set {_description_p = newValue}
    }
    /// Returns true if `description_p` has been explicitly set.
    public var hasDescription_p: Bool {return self._description_p != nil}
    /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
    public mutating func clearDescription_p() {self._description_p = nil}

    public var avatarURL: String = String()

    public var disappearingMessagesTimer: BackupProto_Group.GroupAttributeBlob {
      get {return _disappearingMessagesTimer ?? BackupProto_Group.GroupAttributeBlob()}
      set {_disappearingMessagesTimer = newValue}
    }
    /// Returns true if `disappearingMessagesTimer` has been explicitly set.
    public var hasDisappearingMessagesTimer: Bool {return self._disappearingMessagesTimer != nil}
    /// Clears the value of `disappearingMessagesTimer`. Subsequent reads from it will return its default value.
    public mutating func clearDisappearingMessagesTimer() {self._disappearingMessagesTimer = nil}

    public var accessControl: BackupProto_Group.AccessControl {
      get {return _accessControl ?? BackupProto_Group.AccessControl()}
      set {_accessControl = newValue}
    }
    /// Returns true if `accessControl` has been explicitly set.
    public var hasAccessControl: Bool {return self._accessControl != nil}
    /// Clears the value of `accessControl`. Subsequent reads from it will return its default value.
    public mutating func clearAccessControl() {self._accessControl = nil}

    public var version: UInt32 = 0

    public var members: [BackupProto_Group.Member] = []

    public var membersPendingProfileKey: [BackupProto_Group.MemberPendingProfileKey] = []

    public var membersPendingAdminApproval: [BackupProto_Group.MemberPendingAdminApproval] = []

    public var inviteLinkPassword: Data = Data()

    public var announcementsOnly: Bool = false

    public var membersBanned: [BackupProto_Group.MemberBanned] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _title: BackupProto_Group.GroupAttributeBlob? = nil
    fileprivate var _description_p: BackupProto_Group.GroupAttributeBlob? = nil
    fileprivate var _disappearingMessagesTimer: BackupProto_Group.GroupAttributeBlob? = nil
    fileprivate var _accessControl: BackupProto_Group.AccessControl? = nil
  }

  public struct GroupAttributeBlob: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// If unset, consider the field it represents to not be present
    public var content: BackupProto_Group.GroupAttributeBlob.OneOf_Content? = nil

    public var title: String {
      get {
        if case .title(let v)? = content {return v}
        return String()
      }
      set {content = .title(newValue)}
    }

    public var avatar: Data {
      get {
        if case .avatar(let v)? = content {return v}
        return Data()
      }
      set {content = .avatar(newValue)}
    }

    public var disappearingMessagesDuration: UInt32 {
      get {
        if case .disappearingMessagesDuration(let v)? = content {return v}
        return 0
      }
      set {content = .disappearingMessagesDuration(newValue)}
    }

    public var descriptionText: String {
      get {
        if case .descriptionText(let v)? = content {return v}
        return String()
      }
      set {content = .descriptionText(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// If unset, consider the field it represents to not be present
    public enum OneOf_Content: Equatable, @unchecked Sendable {
      case title(String)
      case avatar(Data)
      case disappearingMessagesDuration(UInt32)
      case descriptionText(String)

    }

    public init() {}
  }

  public struct Member: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var userID: Data = Data()

    public var role: BackupProto_Group.Member.Role = .unknown

    public var joinedAtVersion: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Role: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int

      /// Intepret as "Default"
      case unknown // = 0
      case `default` // = 1
      case administrator // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .default
        case 2: self = .administrator
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .default: return 1
        case .administrator: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [BackupProto_Group.Member.Role] = [
        .unknown,
        .default,
        .administrator,
      ]

    }

    public init() {}
  }

  public struct MemberPendingProfileKey: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var member: BackupProto_Group.Member {
      get {return _member ?? BackupProto_Group.Member()}
      set {_member = newValue}
    }
    /// Returns true if `member` has been explicitly set.
    public var hasMember: Bool {return self._member != nil}
    /// Clears the value of `member`. Subsequent reads from it will return its default value.
    public mutating func clearMember() {self._member = nil}

    public var addedByUserID: Data = Data()

    public var timestamp: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _member: BackupProto_Group.Member? = nil
  }

  public struct MemberPendingAdminApproval: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var userID: Data = Data()

    public var timestamp: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct MemberBanned: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var userID: Data = Data()

    public var timestamp: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct AccessControl: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var attributes: BackupProto_Group.AccessControl.AccessRequired = .unknown

    public var members: BackupProto_Group.AccessControl.AccessRequired = .unknown

    public var addFromInviteLink: BackupProto_Group.AccessControl.AccessRequired = .unknown

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum AccessRequired: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int

      /// Intepret as "Unsatisfiable"
      case unknown // = 0
      case any // = 1
      case member // = 2
      case administrator // = 3
      case unsatisfiable // = 4
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .any
        case 2: self = .member
        case 3: self = .administrator
        case 4: self = .unsatisfiable
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .any: return 1
        case .member: return 2
        case .administrator: return 3
        case .unsatisfiable: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [BackupProto_Group.AccessControl.AccessRequired] = [
        .unknown,
        .any,
        .member,
        .administrator,
        .unsatisfiable,
      ]

    }

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct BackupProto_Self: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var avatarColor: BackupProto_AvatarColor {
    get {return _avatarColor ?? .a100}
    set {_avatarColor = newValue}
  }
  /// Returns true if `avatarColor` has been explicitly set.
  public var hasAvatarColor: Bool {return self._avatarColor != nil}
  /// Clears the value of `avatarColor`. Subsequent reads from it will return its default value.
  public mutating func clearAvatarColor() {self._avatarColor = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _avatarColor: BackupProto_AvatarColor? = nil
}

public struct BackupProto_ReleaseNotes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BackupProto_Chat: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// generated id for reference only within this file
  public var id: UInt64 = 0

  public var recipientID: UInt64 = 0

  public var archived: Bool = false

  /// will be displayed in ascending order
  public var pinnedOrder: UInt32 {
    get {return _pinnedOrder ?? 0}
    set {_pinnedOrder = newValue}
  }
  /// Returns true if `pinnedOrder` has been explicitly set.
  public var hasPinnedOrder: Bool {return self._pinnedOrder != nil}
  /// Clears the value of `pinnedOrder`. Subsequent reads from it will return its default value.
  public mutating func clearPinnedOrder() {self._pinnedOrder = nil}

  public var expirationTimerMs: UInt64 {
    get {return _expirationTimerMs ?? 0}
    set {_expirationTimerMs = newValue}
  }
  /// Returns true if `expirationTimerMs` has been explicitly set.
  public var hasExpirationTimerMs: Bool {return self._expirationTimerMs != nil}
  /// Clears the value of `expirationTimerMs`. Subsequent reads from it will return its default value.
  public mutating func clearExpirationTimerMs() {self._expirationTimerMs = nil}

  /// INT64_MAX (2^63 - 1) = "always muted".
  public var muteUntilMs: UInt64 {
    get {return _muteUntilMs ?? 0}
    set {_muteUntilMs = newValue}
  }
  /// Returns true if `muteUntilMs` has been explicitly set.
  public var hasMuteUntilMs: Bool {return self._muteUntilMs != nil}
  /// Clears the value of `muteUntilMs`. Subsequent reads from it will return its default value.
  public mutating func clearMuteUntilMs() {self._muteUntilMs = nil}

  public var markedUnread: Bool = false

  public var dontNotifyForMentionsIfMuted: Bool = false

  public var style: BackupProto_ChatStyle {
    get {return _style ?? BackupProto_ChatStyle()}
    set {_style = newValue}
  }
  /// Returns true if `style` has been explicitly set.
  public var hasStyle: Bool {return self._style != nil}
  /// Clears the value of `style`. Subsequent reads from it will return its default value.
  public mutating func clearStyle() {self._style = nil}

  public var expireTimerVersion: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pinnedOrder: UInt32? = nil
  fileprivate var _expirationTimerMs: UInt64? = nil
  fileprivate var _muteUntilMs: UInt64? = nil
  fileprivate var _style: BackupProto_ChatStyle? = nil
}

///*
/// Call Links have some associated data including a call, but unlike other recipients
/// are not tied to threads because they do not have messages associated with them.
///
/// note:
/// - room id can be derived from the root key
/// - the presence of an admin key means this user is a call admin
public struct BackupProto_CallLink: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rootKey: Data = Data()

  /// Only present if the user is an admin
  public var adminKey: Data {
    get {return _adminKey ?? Data()}
    set {_adminKey = newValue}
  }
  /// Returns true if `adminKey` has been explicitly set.
  public var hasAdminKey: Bool {return self._adminKey != nil}
  /// Clears the value of `adminKey`. Subsequent reads from it will return its default value.
  public mutating func clearAdminKey() {self._adminKey = nil}

  public var name: String = String()

  public var restrictions: BackupProto_CallLink.Restrictions = .unknown

  public var expirationMs: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Restrictions: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Interpret as "Admin Approval"
    case unknown // = 0
    case none // = 1
    case adminApproval // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .none
      case 2: self = .adminApproval
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .none: return 1
      case .adminApproval: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [BackupProto_CallLink.Restrictions] = [
      .unknown,
      .none,
      .adminApproval,
    ]

  }

  public init() {}

  fileprivate var _adminKey: Data? = nil
}

public struct BackupProto_AdHocCall: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: UInt64 = 0

  /// Refers to a `CallLink` recipient.
  public var recipientID: UInt64 = 0

  public var state: BackupProto_AdHocCall.State = .unknownState

  public var callTimestamp: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Interpret as "Generic"
    case unknownState // = 0
    case generic // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownState
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownState
      case 1: self = .generic
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownState: return 0
      case .generic: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [BackupProto_AdHocCall.State] = [
      .unknownState,
      .generic,
    ]

  }

  public init() {}
}

public struct BackupProto_DistributionListItem: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// distribution ids are UUIDv4s. "My Story" is represented
  /// by an all-0 UUID (00000000-0000-0000-0000-000000000000).
  public var distributionID: Data = Data()

  /// If unset, importers should skip the item entirely without showing an error.
  public var item: BackupProto_DistributionListItem.OneOf_Item? = nil

  public var deletionTimestamp: UInt64 {
    get {
      if case .deletionTimestamp(let v)? = item {return v}
      return 0
    }
    set {item = .deletionTimestamp(newValue)}
  }

  public var distributionList: BackupProto_DistributionList {
    get {
      if case .distributionList(let v)? = item {return v}
      return BackupProto_DistributionList()
    }
    set {item = .distributionList(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// If unset, importers should skip the item entirely without showing an error.
  public enum OneOf_Item: Equatable, Sendable {
    case deletionTimestamp(UInt64)
    case distributionList(BackupProto_DistributionList)

  }

  public init() {}
}

public struct BackupProto_DistributionList: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var allowReplies: Bool = false

  public var privacyMode: BackupProto_DistributionList.PrivacyMode = .unknown

  /// generated recipient id
  public var memberRecipientIds: [UInt64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum PrivacyMode: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Interpret as "Only with"
    case unknown // = 0
    case onlyWith // = 1
    case allExcept // = 2
    case all // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .onlyWith
      case 2: self = .allExcept
      case 3: self = .all
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .onlyWith: return 1
      case .allExcept: return 2
      case .all: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [BackupProto_DistributionList.PrivacyMode] = [
      .unknown,
      .onlyWith,
      .allExcept,
      .all,
    ]

  }

  public init() {}
}

public struct BackupProto_ChatItem: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// conversation id
  public var chatID: UInt64 {
    get {return _storage._chatID}
    set {_uniqueStorage()._chatID = newValue}
  }

  /// recipient id
  public var authorID: UInt64 {
    get {return _storage._authorID}
    set {_uniqueStorage()._authorID = newValue}
  }

  public var dateSent: UInt64 {
    get {return _storage._dateSent}
    set {_uniqueStorage()._dateSent = newValue}
  }

  /// timestamp of when expiration timer started ticking down
  public var expireStartDate: UInt64 {
    get {return _storage._expireStartDate ?? 0}
    set {_uniqueStorage()._expireStartDate = newValue}
  }
  /// Returns true if `expireStartDate` has been explicitly set.
  public var hasExpireStartDate: Bool {return _storage._expireStartDate != nil}
  /// Clears the value of `expireStartDate`. Subsequent reads from it will return its default value.
  public mutating func clearExpireStartDate() {_uniqueStorage()._expireStartDate = nil}

  /// how long timer of message is (ms)
  public var expiresInMs: UInt64 {
    get {return _storage._expiresInMs ?? 0}
    set {_uniqueStorage()._expiresInMs = newValue}
  }
  /// Returns true if `expiresInMs` has been explicitly set.
  public var hasExpiresInMs: Bool {return _storage._expiresInMs != nil}
  /// Clears the value of `expiresInMs`. Subsequent reads from it will return its default value.
  public mutating func clearExpiresInMs() {_uniqueStorage()._expiresInMs = nil}

  /// ordered from oldest to newest
  public var revisions: [BackupProto_ChatItem] {
    get {return _storage._revisions}
    set {_uniqueStorage()._revisions = newValue}
  }

  public var sms: Bool {
    get {return _storage._sms}
    set {_uniqueStorage()._sms = newValue}
  }

  /// If unset, importers should skip this item without throwing an error.
  public var directionalDetails: OneOf_DirectionalDetails? {
    get {return _storage._directionalDetails}
    set {_uniqueStorage()._directionalDetails = newValue}
  }

  public var incoming: BackupProto_ChatItem.IncomingMessageDetails {
    get {
      if case .incoming(let v)? = _storage._directionalDetails {return v}
      return BackupProto_ChatItem.IncomingMessageDetails()
    }
    set {_uniqueStorage()._directionalDetails = .incoming(newValue)}
  }

  public var outgoing: BackupProto_ChatItem.OutgoingMessageDetails {
    get {
      if case .outgoing(let v)? = _storage._directionalDetails {return v}
      return BackupProto_ChatItem.OutgoingMessageDetails()
    }
    set {_uniqueStorage()._directionalDetails = .outgoing(newValue)}
  }

  public var directionless: BackupProto_ChatItem.DirectionlessMessageDetails {
    get {
      if case .directionless(let v)? = _storage._directionalDetails {return v}
      return BackupProto_ChatItem.DirectionlessMessageDetails()
    }
    set {_uniqueStorage()._directionalDetails = .directionless(newValue)}
  }

  /// If unset, importers should skip this item without throwing an error.
  public var item: OneOf_Item? {
    get {return _storage._item}
    set {_uniqueStorage()._item = newValue}
  }

  public var standardMessage: BackupProto_StandardMessage {
    get {
      if case .standardMessage(let v)? = _storage._item {return v}
      return BackupProto_StandardMessage()
    }
    set {_uniqueStorage()._item = .standardMessage(newValue)}
  }

  public var contactMessage: BackupProto_ContactMessage {
    get {
      if case .contactMessage(let v)? = _storage._item {return v}
      return BackupProto_ContactMessage()
    }
    set {_uniqueStorage()._item = .contactMessage(newValue)}
  }

  public var stickerMessage: BackupProto_StickerMessage {
    get {
      if case .stickerMessage(let v)? = _storage._item {return v}
      return BackupProto_StickerMessage()
    }
    set {_uniqueStorage()._item = .stickerMessage(newValue)}
  }

  public var remoteDeletedMessage: BackupProto_RemoteDeletedMessage {
    get {
      if case .remoteDeletedMessage(let v)? = _storage._item {return v}
      return BackupProto_RemoteDeletedMessage()
    }
    set {_uniqueStorage()._item = .remoteDeletedMessage(newValue)}
  }

  public var updateMessage: BackupProto_ChatUpdateMessage {
    get {
      if case .updateMessage(let v)? = _storage._item {return v}
      return BackupProto_ChatUpdateMessage()
    }
    set {_uniqueStorage()._item = .updateMessage(newValue)}
  }

  public var paymentNotification: BackupProto_PaymentNotification {
    get {
      if case .paymentNotification(let v)? = _storage._item {return v}
      return BackupProto_PaymentNotification()
    }
    set {_uniqueStorage()._item = .paymentNotification(newValue)}
  }

  public var giftBadge: BackupProto_GiftBadge {
    get {
      if case .giftBadge(let v)? = _storage._item {return v}
      return BackupProto_GiftBadge()
    }
    set {_uniqueStorage()._item = .giftBadge(newValue)}
  }

  public var viewOnceMessage: BackupProto_ViewOnceMessage {
    get {
      if case .viewOnceMessage(let v)? = _storage._item {return v}
      return BackupProto_ViewOnceMessage()
    }
    set {_uniqueStorage()._item = .viewOnceMessage(newValue)}
  }

  /// group story reply messages are not backed up
  public var directStoryReplyMessage: BackupProto_DirectStoryReplyMessage {
    get {
      if case .directStoryReplyMessage(let v)? = _storage._item {return v}
      return BackupProto_DirectStoryReplyMessage()
    }
    set {_uniqueStorage()._item = .directStoryReplyMessage(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// If unset, importers should skip this item without throwing an error.
  public enum OneOf_DirectionalDetails: Equatable, Sendable {
    case incoming(BackupProto_ChatItem.IncomingMessageDetails)
    case outgoing(BackupProto_ChatItem.OutgoingMessageDetails)
    case directionless(BackupProto_ChatItem.DirectionlessMessageDetails)

  }

  /// If unset, importers should skip this item without throwing an error.
  public enum OneOf_Item: Equatable, Sendable {
    case standardMessage(BackupProto_StandardMessage)
    case contactMessage(BackupProto_ContactMessage)
    case stickerMessage(BackupProto_StickerMessage)
    case remoteDeletedMessage(BackupProto_RemoteDeletedMessage)
    case updateMessage(BackupProto_ChatUpdateMessage)
    case paymentNotification(BackupProto_PaymentNotification)
    case giftBadge(BackupProto_GiftBadge)
    case viewOnceMessage(BackupProto_ViewOnceMessage)
    /// group story reply messages are not backed up
    case directStoryReplyMessage(BackupProto_DirectStoryReplyMessage)

  }

  public struct IncomingMessageDetails: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var dateReceived: UInt64 = 0

    public var dateServerSent: UInt64 {
      get {return _dateServerSent ?? 0}
      set {_dateServerSent = newValue}
    }
    /// Returns true if `dateServerSent` has been explicitly set.
    public var hasDateServerSent: Bool {return self._dateServerSent != nil}
    /// Clears the value of `dateServerSent`. Subsequent reads from it will return its default value.
    public mutating func clearDateServerSent() {self._dateServerSent = nil}

    public var read: Bool = false

    public var sealedSender: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _dateServerSent: UInt64? = nil
  }

  public struct OutgoingMessageDetails: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var sendStatus: [BackupProto_SendStatus] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct DirectionlessMessageDetails: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct BackupProto_SendStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var recipientID: UInt64 = 0

  /// the time the status was last updated -- if from a receipt, it should be the sentTime of the receipt
  public var timestamp: UInt64 = 0

  /// If unset, importers should consider the status to be "pending"
  public var deliveryStatus: BackupProto_SendStatus.OneOf_DeliveryStatus? = nil

  public var pending: BackupProto_SendStatus.Pending {
    get {
      if case .pending(let v)? = deliveryStatus {return v}
      return BackupProto_SendStatus.Pending()
    }
    set {deliveryStatus = .pending(newValue)}
  }

  public var sent: BackupProto_SendStatus.Sent {
    get {
      if case .sent(let v)? = deliveryStatus {return v}
      return BackupProto_SendStatus.Sent()
    }
    set {deliveryStatus = .sent(newValue)}
  }

  public var delivered: BackupProto_SendStatus.Delivered {
    get {
      if case .delivered(let v)? = deliveryStatus {return v}
      return BackupProto_SendStatus.Delivered()
    }
    set {deliveryStatus = .delivered(newValue)}
  }

  public var read: BackupProto_SendStatus.Read {
    get {
      if case .read(let v)? = deliveryStatus {return v}
      return BackupProto_SendStatus.Read()
    }
    set {deliveryStatus = .read(newValue)}
  }

  public var viewed: BackupProto_SendStatus.Viewed {
    get {
      if case .viewed(let v)? = deliveryStatus {return v}
      return BackupProto_SendStatus.Viewed()
    }
    set {deliveryStatus = .viewed(newValue)}
  }

  public var skipped: BackupProto_SendStatus.Skipped {
    get {
      if case .skipped(let v)? = deliveryStatus {return v}
      return BackupProto_SendStatus.Skipped()
    }
    set {deliveryStatus = .skipped(newValue)}
  }

  public var failed: BackupProto_SendStatus.Failed {
    get {
      if case .failed(let v)? = deliveryStatus {return v}
      return BackupProto_SendStatus.Failed()
    }
    set {deliveryStatus = .failed(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// If unset, importers should consider the status to be "pending"
  public enum OneOf_DeliveryStatus: Equatable, Sendable {
    case pending(BackupProto_SendStatus.Pending)
    case sent(BackupProto_SendStatus.Sent)
    case delivered(BackupProto_SendStatus.Delivered)
    case read(BackupProto_SendStatus.Read)
    case viewed(BackupProto_SendStatus.Viewed)
    case skipped(BackupProto_SendStatus.Skipped)
    case failed(BackupProto_SendStatus.Failed)

  }

  public struct Pending: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Sent: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var sealedSender: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Delivered: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var sealedSender: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Read: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var sealedSender: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Viewed: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var sealedSender: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// e.g. user in group was blocked, so we skipped sending to them
  public struct Skipped: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Failed: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var reason: BackupProto_SendStatus.Failed.FailureReason = .unknown

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum FailureReason: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int

      /// A valid value -- could indicate a crash or lack of information
      case unknown // = 0
      case network // = 1
      case identityKeyMismatch // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .network
        case 2: self = .identityKeyMismatch
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .network: return 1
        case .identityKeyMismatch: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [BackupProto_SendStatus.Failed.FailureReason] = [
        .unknown,
        .network,
        .identityKeyMismatch,
      ]

    }

    public init() {}
  }

  public init() {}
}

public struct BackupProto_Text: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var body: String = String()

  public var bodyRanges: [BackupProto_BodyRange] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BackupProto_StandardMessage: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var quote: BackupProto_Quote {
    get {return _storage._quote ?? BackupProto_Quote()}
    set {_uniqueStorage()._quote = newValue}
  }
  /// Returns true if `quote` has been explicitly set.
  public var hasQuote: Bool {return _storage._quote != nil}
  /// Clears the value of `quote`. Subsequent reads from it will return its default value.
  public mutating func clearQuote() {_uniqueStorage()._quote = nil}

  public var text: BackupProto_Text {
    get {return _storage._text ?? BackupProto_Text()}
    set {_uniqueStorage()._text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  public var hasText: Bool {return _storage._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  public mutating func clearText() {_uniqueStorage()._text = nil}

  public var attachments: [BackupProto_MessageAttachment] {
    get {return _storage._attachments}
    set {_uniqueStorage()._attachments = newValue}
  }

  public var linkPreview: [BackupProto_LinkPreview] {
    get {return _storage._linkPreview}
    set {_uniqueStorage()._linkPreview = newValue}
  }

  public var longText: BackupProto_FilePointer {
    get {return _storage._longText ?? BackupProto_FilePointer()}
    set {_uniqueStorage()._longText = newValue}
  }
  /// Returns true if `longText` has been explicitly set.
  public var hasLongText: Bool {return _storage._longText != nil}
  /// Clears the value of `longText`. Subsequent reads from it will return its default value.
  public mutating func clearLongText() {_uniqueStorage()._longText = nil}

  public var reactions: [BackupProto_Reaction] {
    get {return _storage._reactions}
    set {_uniqueStorage()._reactions = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct BackupProto_ContactMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var contact: BackupProto_ContactAttachment {
    get {return _contact ?? BackupProto_ContactAttachment()}
    set {_contact = newValue}
  }
  /// Returns true if `contact` has been explicitly set.
  public var hasContact: Bool {return self._contact != nil}
  /// Clears the value of `contact`. Subsequent reads from it will return its default value.
  public mutating func clearContact() {self._contact = nil}

  public var reactions: [BackupProto_Reaction] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _contact: BackupProto_ContactAttachment? = nil
}

public struct BackupProto_DirectStoryReplyMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If unset, importers should ignore the message without throwing an error.
  public var reply: BackupProto_DirectStoryReplyMessage.OneOf_Reply? = nil

  public var textReply: BackupProto_DirectStoryReplyMessage.TextReply {
    get {
      if case .textReply(let v)? = reply {return v}
      return BackupProto_DirectStoryReplyMessage.TextReply()
    }
    set {reply = .textReply(newValue)}
  }

  public var emoji: String {
    get {
      if case .emoji(let v)? = reply {return v}
      return String()
    }
    set {reply = .emoji(newValue)}
  }

  public var reactions: [BackupProto_Reaction] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// If unset, importers should ignore the message without throwing an error.
  public enum OneOf_Reply: Equatable, Sendable {
    case textReply(BackupProto_DirectStoryReplyMessage.TextReply)
    case emoji(String)

  }

  public struct TextReply: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var text: BackupProto_Text {
      get {return _storage._text ?? BackupProto_Text()}
      set {_uniqueStorage()._text = newValue}
    }
    /// Returns true if `text` has been explicitly set.
    public var hasText: Bool {return _storage._text != nil}
    /// Clears the value of `text`. Subsequent reads from it will return its default value.
    public mutating func clearText() {_uniqueStorage()._text = nil}

    public var longText: BackupProto_FilePointer {
      get {return _storage._longText ?? BackupProto_FilePointer()}
      set {_uniqueStorage()._longText = newValue}
    }
    /// Returns true if `longText` has been explicitly set.
    public var hasLongText: Bool {return _storage._longText != nil}
    /// Clears the value of `longText`. Subsequent reads from it will return its default value.
    public mutating func clearLongText() {_uniqueStorage()._longText = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}
}

public struct BackupProto_PaymentNotification: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// stored as a decimal string, e.g. 1.00001
  public var amountMob: String {
    get {return _amountMob ?? String()}
    set {_amountMob = newValue}
  }
  /// Returns true if `amountMob` has been explicitly set.
  public var hasAmountMob: Bool {return self._amountMob != nil}
  /// Clears the value of `amountMob`. Subsequent reads from it will return its default value.
  public mutating func clearAmountMob() {self._amountMob = nil}

  /// stored as a decimal string, e.g. 1.00001
  public var feeMob: String {
    get {return _feeMob ?? String()}
    set {_feeMob = newValue}
  }
  /// Returns true if `feeMob` has been explicitly set.
  public var hasFeeMob: Bool {return self._feeMob != nil}
  /// Clears the value of `feeMob`. Subsequent reads from it will return its default value.
  public mutating func clearFeeMob() {self._feeMob = nil}

  public var note: String {
    get {return _note ?? String()}
    set {_note = newValue}
  }
  /// Returns true if `note` has been explicitly set.
  public var hasNote: Bool {return self._note != nil}
  /// Clears the value of `note`. Subsequent reads from it will return its default value.
  public mutating func clearNote() {self._note = nil}

  public var transactionDetails: BackupProto_PaymentNotification.TransactionDetails {
    get {return _transactionDetails ?? BackupProto_PaymentNotification.TransactionDetails()}
    set {_transactionDetails = newValue}
  }
  /// Returns true if `transactionDetails` has been explicitly set.
  public var hasTransactionDetails: Bool {return self._transactionDetails != nil}
  /// Clears the value of `transactionDetails`. Subsequent reads from it will return its default value.
  public mutating func clearTransactionDetails() {self._transactionDetails = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct TransactionDetails: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// If unset, importers should treat the transaction as successful with no metadata.
    public var payment: BackupProto_PaymentNotification.TransactionDetails.OneOf_Payment? = nil

    public var transaction: BackupProto_PaymentNotification.TransactionDetails.Transaction {
      get {
        if case .transaction(let v)? = payment {return v}
        return BackupProto_PaymentNotification.TransactionDetails.Transaction()
      }
      set {payment = .transaction(newValue)}
    }

    public var failedTransaction: BackupProto_PaymentNotification.TransactionDetails.FailedTransaction {
      get {
        if case .failedTransaction(let v)? = payment {return v}
        return BackupProto_PaymentNotification.TransactionDetails.FailedTransaction()
      }
      set {payment = .failedTransaction(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// If unset, importers should treat the transaction as successful with no metadata.
    public enum OneOf_Payment: Equatable, Sendable {
      case transaction(BackupProto_PaymentNotification.TransactionDetails.Transaction)
      case failedTransaction(BackupProto_PaymentNotification.TransactionDetails.FailedTransaction)

    }

    /// Used to map to payments on the ledger
    public struct MobileCoinTxoIdentification: @unchecked Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// for received transactions
      public var publicKey: [Data] = []

      /// for sent transactions
      public var keyImages: [Data] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// Failed payments can't be synced from the ledger
    public struct FailedTransaction: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var reason: BackupProto_PaymentNotification.TransactionDetails.FailedTransaction.FailureReason = .generic

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum FailureReason: SwiftProtobuf.Enum, Swift.CaseIterable {
        public typealias RawValue = Int

        /// A valid value -- reason unknown
        case generic // = 0
        case network // = 1
        case insufficientFunds // = 2
        case UNRECOGNIZED(Int)

        public init() {
          self = .generic
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .generic
          case 1: self = .network
          case 2: self = .insufficientFunds
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .generic: return 0
          case .network: return 1
          case .insufficientFunds: return 2
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [BackupProto_PaymentNotification.TransactionDetails.FailedTransaction.FailureReason] = [
          .generic,
          .network,
          .insufficientFunds,
        ]

      }

      public init() {}
    }

    public struct Transaction: @unchecked Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var status: BackupProto_PaymentNotification.TransactionDetails.Transaction.Status = .initial

      /// This identification is used to map the payment table to the ledger
      /// and is likely required otherwise we may have issues reconciling with
      /// the ledger
      public var mobileCoinIdentification: BackupProto_PaymentNotification.TransactionDetails.MobileCoinTxoIdentification {
        get {return _mobileCoinIdentification ?? BackupProto_PaymentNotification.TransactionDetails.MobileCoinTxoIdentification()}
        set {_mobileCoinIdentification = newValue}
      }
      /// Returns true if `mobileCoinIdentification` has been explicitly set.
      public var hasMobileCoinIdentification: Bool {return self._mobileCoinIdentification != nil}
      /// Clears the value of `mobileCoinIdentification`. Subsequent reads from it will return its default value.
      public mutating func clearMobileCoinIdentification() {self._mobileCoinIdentification = nil}

      public var timestamp: UInt64 {
        get {return _timestamp ?? 0}
        set {_timestamp = newValue}
      }
      /// Returns true if `timestamp` has been explicitly set.
      public var hasTimestamp: Bool {return self._timestamp != nil}
      /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
      public mutating func clearTimestamp() {self._timestamp = nil}

      public var blockIndex: UInt64 {
        get {return _blockIndex ?? 0}
        set {_blockIndex = newValue}
      }
      /// Returns true if `blockIndex` has been explicitly set.
      public var hasBlockIndex: Bool {return self._blockIndex != nil}
      /// Clears the value of `blockIndex`. Subsequent reads from it will return its default value.
      public mutating func clearBlockIndex() {self._blockIndex = nil}

      public var blockTimestamp: UInt64 {
        get {return _blockTimestamp ?? 0}
        set {_blockTimestamp = newValue}
      }
      /// Returns true if `blockTimestamp` has been explicitly set.
      public var hasBlockTimestamp: Bool {return self._blockTimestamp != nil}
      /// Clears the value of `blockTimestamp`. Subsequent reads from it will return its default value.
      public mutating func clearBlockTimestamp() {self._blockTimestamp = nil}

      /// mobile coin blobs
      public var transaction: Data {
        get {return _transaction ?? Data()}
        set {_transaction = newValue}
      }
      /// Returns true if `transaction` has been explicitly set.
      public var hasTransaction: Bool {return self._transaction != nil}
      /// Clears the value of `transaction`. Subsequent reads from it will return its default value.
      public mutating func clearTransaction() {self._transaction = nil}

      /// mobile coin blobs
      public var receipt: Data {
        get {return _receipt ?? Data()}
        set {_receipt = newValue}
      }
      /// Returns true if `receipt` has been explicitly set.
      public var hasReceipt: Bool {return self._receipt != nil}
      /// Clears the value of `receipt`. Subsequent reads from it will return its default value.
      public mutating func clearReceipt() {self._receipt = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum Status: SwiftProtobuf.Enum, Swift.CaseIterable {
        public typealias RawValue = Int

        /// A valid value -- state unconfirmed
        case initial // = 0
        case submitted // = 1
        case successful // = 2
        case UNRECOGNIZED(Int)

        public init() {
          self = .initial
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .initial
          case 1: self = .submitted
          case 2: self = .successful
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .initial: return 0
          case .submitted: return 1
          case .successful: return 2
          case .UNRECOGNIZED(let i): return i
          }
        }

        // The compiler won't synthesize support with the UNRECOGNIZED case.
        public static let allCases: [BackupProto_PaymentNotification.TransactionDetails.Transaction.Status] = [
          .initial,
          .submitted,
          .successful,
        ]

      }

      public init() {}

      fileprivate var _mobileCoinIdentification: BackupProto_PaymentNotification.TransactionDetails.MobileCoinTxoIdentification? = nil
      fileprivate var _timestamp: UInt64? = nil
      fileprivate var _blockIndex: UInt64? = nil
      fileprivate var _blockTimestamp: UInt64? = nil
      fileprivate var _transaction: Data? = nil
      fileprivate var _receipt: Data? = nil
    }

    public init() {}
  }

  public init() {}

  fileprivate var _amountMob: String? = nil
  fileprivate var _feeMob: String? = nil
  fileprivate var _note: String? = nil
  fileprivate var _transactionDetails: BackupProto_PaymentNotification.TransactionDetails? = nil
}

public struct BackupProto_GiftBadge: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var receiptCredentialPresentation: Data = Data()

  public var state: BackupProto_GiftBadge.State = .unopened

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// A valid state
    case unopened // = 0
    case opened // = 1
    case redeemed // = 2
    case failed // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unopened
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unopened
      case 1: self = .opened
      case 2: self = .redeemed
      case 3: self = .failed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unopened: return 0
      case .opened: return 1
      case .redeemed: return 2
      case .failed: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [BackupProto_GiftBadge.State] = [
      .unopened,
      .opened,
      .redeemed,
      .failed,
    ]

  }

  public init() {}
}

public struct BackupProto_ViewOnceMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Will be null for viewed messages
  public var attachment: BackupProto_MessageAttachment {
    get {return _attachment ?? BackupProto_MessageAttachment()}
    set {_attachment = newValue}
  }
  /// Returns true if `attachment` has been explicitly set.
  public var hasAttachment: Bool {return self._attachment != nil}
  /// Clears the value of `attachment`. Subsequent reads from it will return its default value.
  public mutating func clearAttachment() {self._attachment = nil}

  public var reactions: [BackupProto_Reaction] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _attachment: BackupProto_MessageAttachment? = nil
}

public struct BackupProto_ContactAttachment: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: BackupProto_ContactAttachment.Name {
    get {return _storage._name ?? BackupProto_ContactAttachment.Name()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {_uniqueStorage()._name = nil}

  public var number: [BackupProto_ContactAttachment.Phone] {
    get {return _storage._number}
    set {_uniqueStorage()._number = newValue}
  }

  public var email: [BackupProto_ContactAttachment.Email] {
    get {return _storage._email}
    set {_uniqueStorage()._email = newValue}
  }

  public var address: [BackupProto_ContactAttachment.PostalAddress] {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var avatar: BackupProto_FilePointer {
    get {return _storage._avatar ?? BackupProto_FilePointer()}
    set {_uniqueStorage()._avatar = newValue}
  }
  /// Returns true if `avatar` has been explicitly set.
  public var hasAvatar: Bool {return _storage._avatar != nil}
  /// Clears the value of `avatar`. Subsequent reads from it will return its default value.
  public mutating func clearAvatar() {_uniqueStorage()._avatar = nil}

  public var organization: String {
    get {return _storage._organization}
    set {_uniqueStorage()._organization = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Name: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var givenName: String = String()

    public var familyName: String = String()

    public var prefix: String = String()

    public var suffix: String = String()

    public var middleName: String = String()

    public var nickname: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Phone: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var value: String = String()

    public var type: BackupProto_ContactAttachment.Phone.TypeEnum = .unknown

    public var label: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum TypeEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int

      /// Interpret as "Home"
      case unknown // = 0
      case home // = 1
      case mobile // = 2
      case work // = 3
      case custom // = 4
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .home
        case 2: self = .mobile
        case 3: self = .work
        case 4: self = .custom
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .home: return 1
        case .mobile: return 2
        case .work: return 3
        case .custom: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [BackupProto_ContactAttachment.Phone.TypeEnum] = [
        .unknown,
        .home,
        .mobile,
        .work,
        .custom,
      ]

    }

    public init() {}
  }

  public struct Email: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var value: String = String()

    public var type: BackupProto_ContactAttachment.Email.TypeEnum = .unknown

    public var label: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum TypeEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int

      /// Intepret as "Home"
      case unknown // = 0
      case home // = 1
      case mobile // = 2
      case work // = 3
      case custom // = 4
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .home
        case 2: self = .mobile
        case 3: self = .work
        case 4: self = .custom
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .home: return 1
        case .mobile: return 2
        case .work: return 3
        case .custom: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [BackupProto_ContactAttachment.Email.TypeEnum] = [
        .unknown,
        .home,
        .mobile,
        .work,
        .custom,
      ]

    }

    public init() {}
  }

  public struct PostalAddress: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var type: BackupProto_ContactAttachment.PostalAddress.TypeEnum = .unknown

    public var label: String = String()

    public var street: String = String()

    public var pobox: String = String()

    public var neighborhood: String = String()

    public var city: String = String()

    public var region: String = String()

    public var postcode: String = String()

    public var country: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum TypeEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int

      /// Interpret as "Home"
      case unknown // = 0
      case home // = 1
      case work // = 2
      case custom // = 3
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .home
        case 2: self = .work
        case 3: self = .custom
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .home: return 1
        case .work: return 2
        case .custom: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [BackupProto_ContactAttachment.PostalAddress.TypeEnum] = [
        .unknown,
        .home,
        .work,
        .custom,
      ]

    }

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct BackupProto_StickerMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sticker: BackupProto_Sticker {
    get {return _sticker ?? BackupProto_Sticker()}
    set {_sticker = newValue}
  }
  /// Returns true if `sticker` has been explicitly set.
  public var hasSticker: Bool {return self._sticker != nil}
  /// Clears the value of `sticker`. Subsequent reads from it will return its default value.
  public mutating func clearSticker() {self._sticker = nil}

  public var reactions: [BackupProto_Reaction] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sticker: BackupProto_Sticker? = nil
}

/// Tombstone for remote delete
public struct BackupProto_RemoteDeletedMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BackupProto_Sticker: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var packID: Data {
    get {return _storage._packID}
    set {_uniqueStorage()._packID = newValue}
  }

  public var packKey: Data {
    get {return _storage._packKey}
    set {_uniqueStorage()._packKey = newValue}
  }

  public var stickerID: UInt32 {
    get {return _storage._stickerID}
    set {_uniqueStorage()._stickerID = newValue}
  }

  public var emoji: String {
    get {return _storage._emoji ?? String()}
    set {_uniqueStorage()._emoji = newValue}
  }
  /// Returns true if `emoji` has been explicitly set.
  public var hasEmoji: Bool {return _storage._emoji != nil}
  /// Clears the value of `emoji`. Subsequent reads from it will return its default value.
  public mutating func clearEmoji() {_uniqueStorage()._emoji = nil}

  /// Stickers are uploaded to be sent as attachments; we also
  /// back them up as normal attachments when they are in messages.
  /// DO NOT treat this as the definitive source of a sticker in
  /// an installed StickerPack that shares the same packId.
  public var data: BackupProto_FilePointer {
    get {return _storage._data ?? BackupProto_FilePointer()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct BackupProto_LinkPreview: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var url: String {
    get {return _storage._url}
    set {_uniqueStorage()._url = newValue}
  }

  public var title: String {
    get {return _storage._title ?? String()}
    set {_uniqueStorage()._title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  public var hasTitle: Bool {return _storage._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  public mutating func clearTitle() {_uniqueStorage()._title = nil}

  public var image: BackupProto_FilePointer {
    get {return _storage._image ?? BackupProto_FilePointer()}
    set {_uniqueStorage()._image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  public var hasImage: Bool {return _storage._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  public mutating func clearImage() {_uniqueStorage()._image = nil}

  public var description_p: String {
    get {return _storage._description_p ?? String()}
    set {_uniqueStorage()._description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  public var hasDescription_p: Bool {return _storage._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  public mutating func clearDescription_p() {_uniqueStorage()._description_p = nil}

  public var date: UInt64 {
    get {return _storage._date ?? 0}
    set {_uniqueStorage()._date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return _storage._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {_uniqueStorage()._date = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A FilePointer on a message that has additional
/// metadata that applies only to message attachments.
public struct BackupProto_MessageAttachment: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pointer: BackupProto_FilePointer {
    get {return _storage._pointer ?? BackupProto_FilePointer()}
    set {_uniqueStorage()._pointer = newValue}
  }
  /// Returns true if `pointer` has been explicitly set.
  public var hasPointer: Bool {return _storage._pointer != nil}
  /// Clears the value of `pointer`. Subsequent reads from it will return its default value.
  public mutating func clearPointer() {_uniqueStorage()._pointer = nil}

  public var flag: BackupProto_MessageAttachment.Flag {
    get {return _storage._flag}
    set {_uniqueStorage()._flag = newValue}
  }

  public var wasDownloaded: Bool {
    get {return _storage._wasDownloaded}
    set {_uniqueStorage()._wasDownloaded = newValue}
  }

  /// Cross-client identifier for this attachment among all attachments on the
  /// owning message. See: SignalService.AttachmentPointer.clientUuid.
  public var clientUuid: Data {
    get {return _storage._clientUuid ?? Data()}
    set {_uniqueStorage()._clientUuid = newValue}
  }
  /// Returns true if `clientUuid` has been explicitly set.
  public var hasClientUuid: Bool {return _storage._clientUuid != nil}
  /// Clears the value of `clientUuid`. Subsequent reads from it will return its default value.
  public mutating func clearClientUuid() {_uniqueStorage()._clientUuid = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Similar to SignalService.AttachmentPointer.Flags,
  /// but explicitly mutually exclusive. Note the different raw values
  /// (non-zero starting values are not supported in proto3.)
  public enum Flag: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// A valid value -- no flag applied
    case none // = 0
    case voiceMessage // = 1
    case borderless // = 2
    case gif // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .none
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .voiceMessage
      case 2: self = .borderless
      case 3: self = .gif
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .none: return 0
      case .voiceMessage: return 1
      case .borderless: return 2
      case .gif: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [BackupProto_MessageAttachment.Flag] = [
      .none,
      .voiceMessage,
      .borderless,
      .gif,
    ]

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct BackupProto_FilePointer: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If unset, importers should consider it to be an InvalidAttachmentLocator without throwing an error.
  public var locator: BackupProto_FilePointer.OneOf_Locator? = nil

  public var backupLocator: BackupProto_FilePointer.BackupLocator {
    get {
      if case .backupLocator(let v)? = locator {return v}
      return BackupProto_FilePointer.BackupLocator()
    }
    set {locator = .backupLocator(newValue)}
  }

  public var attachmentLocator: BackupProto_FilePointer.AttachmentLocator {
    get {
      if case .attachmentLocator(let v)? = locator {return v}
      return BackupProto_FilePointer.AttachmentLocator()
    }
    set {locator = .attachmentLocator(newValue)}
  }

  public var invalidAttachmentLocator: BackupProto_FilePointer.InvalidAttachmentLocator {
    get {
      if case .invalidAttachmentLocator(let v)? = locator {return v}
      return BackupProto_FilePointer.InvalidAttachmentLocator()
    }
    set {locator = .invalidAttachmentLocator(newValue)}
  }

  public var contentType: String {
    get {return _contentType ?? String()}
    set {_contentType = newValue}
  }
  /// Returns true if `contentType` has been explicitly set.
  public var hasContentType: Bool {return self._contentType != nil}
  /// Clears the value of `contentType`. Subsequent reads from it will return its default value.
  public mutating func clearContentType() {self._contentType = nil}

  public var incrementalMac: Data {
    get {return _incrementalMac ?? Data()}
    set {_incrementalMac = newValue}
  }
  /// Returns true if `incrementalMac` has been explicitly set.
  public var hasIncrementalMac: Bool {return self._incrementalMac != nil}
  /// Clears the value of `incrementalMac`. Subsequent reads from it will return its default value.
  public mutating func clearIncrementalMac() {self._incrementalMac = nil}

  public var incrementalMacChunkSize: UInt32 {
    get {return _incrementalMacChunkSize ?? 0}
    set {_incrementalMacChunkSize = newValue}
  }
  /// Returns true if `incrementalMacChunkSize` has been explicitly set.
  public var hasIncrementalMacChunkSize: Bool {return self._incrementalMacChunkSize != nil}
  /// Clears the value of `incrementalMacChunkSize`. Subsequent reads from it will return its default value.
  public mutating func clearIncrementalMacChunkSize() {self._incrementalMacChunkSize = nil}

  public var fileName: String {
    get {return _fileName ?? String()}
    set {_fileName = newValue}
  }
  /// Returns true if `fileName` has been explicitly set.
  public var hasFileName: Bool {return self._fileName != nil}
  /// Clears the value of `fileName`. Subsequent reads from it will return its default value.
  public mutating func clearFileName() {self._fileName = nil}

  public var width: UInt32 {
    get {return _width ?? 0}
    set {_width = newValue}
  }
  /// Returns true if `width` has been explicitly set.
  public var hasWidth: Bool {return self._width != nil}
  /// Clears the value of `width`. Subsequent reads from it will return its default value.
  public mutating func clearWidth() {self._width = nil}

  public var height: UInt32 {
    get {return _height ?? 0}
    set {_height = newValue}
  }
  /// Returns true if `height` has been explicitly set.
  public var hasHeight: Bool {return self._height != nil}
  /// Clears the value of `height`. Subsequent reads from it will return its default value.
  public mutating func clearHeight() {self._height = nil}

  public var caption: String {
    get {return _caption ?? String()}
    set {_caption = newValue}
  }
  /// Returns true if `caption` has been explicitly set.
  public var hasCaption: Bool {return self._caption != nil}
  /// Clears the value of `caption`. Subsequent reads from it will return its default value.
  public mutating func clearCaption() {self._caption = nil}

  public var blurHash: String {
    get {return _blurHash ?? String()}
    set {_blurHash = newValue}
  }
  /// Returns true if `blurHash` has been explicitly set.
  public var hasBlurHash: Bool {return self._blurHash != nil}
  /// Clears the value of `blurHash`. Subsequent reads from it will return its default value.
  public mutating func clearBlurHash() {self._blurHash = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// If unset, importers should consider it to be an InvalidAttachmentLocator without throwing an error.
  public enum OneOf_Locator: Equatable, Sendable {
    case backupLocator(BackupProto_FilePointer.BackupLocator)
    case attachmentLocator(BackupProto_FilePointer.AttachmentLocator)
    case invalidAttachmentLocator(BackupProto_FilePointer.InvalidAttachmentLocator)

  }

  /// References attachments in the backup (media) storage tier.
  public struct BackupLocator: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var mediaName: String = String()

    /// If present, the cdn number of the succesful upload.
    /// If empty/0, may still have been uploaded, and clients
    /// can discover the cdn number via the list endpoint.
    public var cdnNumber: UInt32 {
      get {return _cdnNumber ?? 0}
      set {_cdnNumber = newValue}
    }
    /// Returns true if `cdnNumber` has been explicitly set.
    public var hasCdnNumber: Bool {return self._cdnNumber != nil}
    /// Clears the value of `cdnNumber`. Subsequent reads from it will return its default value.
    public mutating func clearCdnNumber() {self._cdnNumber = nil}

    public var key: Data = Data()

    public var digest: Data = Data()

    public var size: UInt32 = 0

    /// Fallback in case backup tier upload failed.
    public var transitCdnKey: String {
      get {return _transitCdnKey ?? String()}
      set {_transitCdnKey = newValue}
    }
    /// Returns true if `transitCdnKey` has been explicitly set.
    public var hasTransitCdnKey: Bool {return self._transitCdnKey != nil}
    /// Clears the value of `transitCdnKey`. Subsequent reads from it will return its default value.
    public mutating func clearTransitCdnKey() {self._transitCdnKey = nil}

    public var transitCdnNumber: UInt32 {
      get {return _transitCdnNumber ?? 0}
      set {_transitCdnNumber = newValue}
    }
    /// Returns true if `transitCdnNumber` has been explicitly set.
    public var hasTransitCdnNumber: Bool {return self._transitCdnNumber != nil}
    /// Clears the value of `transitCdnNumber`. Subsequent reads from it will return its default value.
    public mutating func clearTransitCdnNumber() {self._transitCdnNumber = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _cdnNumber: UInt32? = nil
    fileprivate var _transitCdnKey: String? = nil
    fileprivate var _transitCdnNumber: UInt32? = nil
  }

  /// References attachments in the transit storage tier.
  /// May be downloaded or not when the backup is generated;
  /// primarily for free-tier users who cannot copy the
  /// attachments to the backup (media) storage tier.
  public struct AttachmentLocator: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var cdnKey: String = String()

    public var cdnNumber: UInt32 = 0

    public var uploadTimestamp: UInt64 {
      get {return _uploadTimestamp ?? 0}
      set {_uploadTimestamp = newValue}
    }
    /// Returns true if `uploadTimestamp` has been explicitly set.
    public var hasUploadTimestamp: Bool {return self._uploadTimestamp != nil}
    /// Clears the value of `uploadTimestamp`. Subsequent reads from it will return its default value.
    public mutating func clearUploadTimestamp() {self._uploadTimestamp = nil}

    public var key: Data = Data()

    public var digest: Data = Data()

    public var size: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _uploadTimestamp: UInt64? = nil
  }

  /// References attachments that are invalid in such a way where download
  /// cannot be attempted. Could range from missing digests to missing
  /// CDN keys or anything else that makes download attempts impossible.
  /// This serves as a 'tombstone' so that the UX can show that an attachment
  /// did exist, but for whatever reason it's not retrievable.
  public struct InvalidAttachmentLocator: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _contentType: String? = nil
  fileprivate var _incrementalMac: Data? = nil
  fileprivate var _incrementalMacChunkSize: UInt32? = nil
  fileprivate var _fileName: String? = nil
  fileprivate var _width: UInt32? = nil
  fileprivate var _height: UInt32? = nil
  fileprivate var _caption: String? = nil
  fileprivate var _blurHash: String? = nil
}

public struct BackupProto_Quote: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// null if the target message could not be found at time of quote insert
  public var targetSentTimestamp: UInt64 {
    get {return _targetSentTimestamp ?? 0}
    set {_targetSentTimestamp = newValue}
  }
  /// Returns true if `targetSentTimestamp` has been explicitly set.
  public var hasTargetSentTimestamp: Bool {return self._targetSentTimestamp != nil}
  /// Clears the value of `targetSentTimestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTargetSentTimestamp() {self._targetSentTimestamp = nil}

  public var authorID: UInt64 = 0

  public var text: BackupProto_Text {
    get {return _text ?? BackupProto_Text()}
    set {_text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  public var hasText: Bool {return self._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  public mutating func clearText() {self._text = nil}

  public var attachments: [BackupProto_Quote.QuotedAttachment] = []

  public var type: BackupProto_Quote.TypeEnum = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Interpret as "Normal"
    case unknown // = 0
    case normal // = 1
    case giftBadge // = 2
    case viewOnce // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .normal
      case 2: self = .giftBadge
      case 3: self = .viewOnce
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .normal: return 1
      case .giftBadge: return 2
      case .viewOnce: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [BackupProto_Quote.TypeEnum] = [
      .unknown,
      .normal,
      .giftBadge,
      .viewOnce,
    ]

  }

  public struct QuotedAttachment: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var contentType: String {
      get {return _contentType ?? String()}
      set {_contentType = newValue}
    }
    /// Returns true if `contentType` has been explicitly set.
    public var hasContentType: Bool {return self._contentType != nil}
    /// Clears the value of `contentType`. Subsequent reads from it will return its default value.
    public mutating func clearContentType() {self._contentType = nil}

    public var fileName: String {
      get {return _fileName ?? String()}
      set {_fileName = newValue}
    }
    /// Returns true if `fileName` has been explicitly set.
    public var hasFileName: Bool {return self._fileName != nil}
    /// Clears the value of `fileName`. Subsequent reads from it will return its default value.
    public mutating func clearFileName() {self._fileName = nil}

    public var thumbnail: BackupProto_MessageAttachment {
      get {return _thumbnail ?? BackupProto_MessageAttachment()}
      set {_thumbnail = newValue}
    }
    /// Returns true if `thumbnail` has been explicitly set.
    public var hasThumbnail: Bool {return self._thumbnail != nil}
    /// Clears the value of `thumbnail`. Subsequent reads from it will return its default value.
    public mutating func clearThumbnail() {self._thumbnail = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _contentType: String? = nil
    fileprivate var _fileName: String? = nil
    fileprivate var _thumbnail: BackupProto_MessageAttachment? = nil
  }

  public init() {}

  fileprivate var _targetSentTimestamp: UInt64? = nil
  fileprivate var _text: BackupProto_Text? = nil
}

public struct BackupProto_BodyRange: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 'start' and 'length' are measured in UTF-16 code units.
  /// They may refer to offsets in a longText attachment.
  public var start: UInt32 = 0

  public var length: UInt32 = 0

  /// If unset, importers should ignore the body range without throwing an error.
  public var associatedValue: BackupProto_BodyRange.OneOf_AssociatedValue? = nil

  public var mentionAci: Data {
    get {
      if case .mentionAci(let v)? = associatedValue {return v}
      return Data()
    }
    set {associatedValue = .mentionAci(newValue)}
  }

  public var style: BackupProto_BodyRange.Style {
    get {
      if case .style(let v)? = associatedValue {return v}
      return .none
    }
    set {associatedValue = .style(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// If unset, importers should ignore the body range without throwing an error.
  public enum OneOf_AssociatedValue: Equatable, @unchecked Sendable {
    case mentionAci(Data)
    case style(BackupProto_BodyRange.Style)

  }

  public enum Style: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Importers should ignore the body range without throwing an error.
    case none // = 0
    case bold // = 1
    case italic // = 2
    case spoiler // = 3
    case strikethrough // = 4
    case monospace // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .none
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .bold
      case 2: self = .italic
      case 3: self = .spoiler
      case 4: self = .strikethrough
      case 5: self = .monospace
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .none: return 0
      case .bold: return 1
      case .italic: return 2
      case .spoiler: return 3
      case .strikethrough: return 4
      case .monospace: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [BackupProto_BodyRange.Style] = [
      .none,
      .bold,
      .italic,
      .spoiler,
      .strikethrough,
      .monospace,
    ]

  }

  public init() {}
}

public struct BackupProto_Reaction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var emoji: String = String()

  public var authorID: UInt64 = 0

  public var sentTimestamp: UInt64 = 0

  /// A higher sort order means that a reaction is more recent. Some clients may export this as
  /// incrementing numbers (e.g. 1, 2, 3), others as timestamps.
  public var sortOrder: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BackupProto_ChatUpdateMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If unset, importers should ignore the update message without throwing an error.
  public var update: BackupProto_ChatUpdateMessage.OneOf_Update? = nil

  public var simpleUpdate: BackupProto_SimpleChatUpdate {
    get {
      if case .simpleUpdate(let v)? = update {return v}
      return BackupProto_SimpleChatUpdate()
    }
    set {update = .simpleUpdate(newValue)}
  }

  public var groupChange: BackupProto_GroupChangeChatUpdate {
    get {
      if case .groupChange(let v)? = update {return v}
      return BackupProto_GroupChangeChatUpdate()
    }
    set {update = .groupChange(newValue)}
  }

  public var expirationTimerChange: BackupProto_ExpirationTimerChatUpdate {
    get {
      if case .expirationTimerChange(let v)? = update {return v}
      return BackupProto_ExpirationTimerChatUpdate()
    }
    set {update = .expirationTimerChange(newValue)}
  }

  public var profileChange: BackupProto_ProfileChangeChatUpdate {
    get {
      if case .profileChange(let v)? = update {return v}
      return BackupProto_ProfileChangeChatUpdate()
    }
    set {update = .profileChange(newValue)}
  }

  public var threadMerge: BackupProto_ThreadMergeChatUpdate {
    get {
      if case .threadMerge(let v)? = update {return v}
      return BackupProto_ThreadMergeChatUpdate()
    }
    set {update = .threadMerge(newValue)}
  }

  public var sessionSwitchover: BackupProto_SessionSwitchoverChatUpdate {
    get {
      if case .sessionSwitchover(let v)? = update {return v}
      return BackupProto_SessionSwitchoverChatUpdate()
    }
    set {update = .sessionSwitchover(newValue)}
  }

  public var individualCall: BackupProto_IndividualCall {
    get {
      if case .individualCall(let v)? = update {return v}
      return BackupProto_IndividualCall()
    }
    set {update = .individualCall(newValue)}
  }

  public var groupCall: BackupProto_GroupCall {
    get {
      if case .groupCall(let v)? = update {return v}
      return BackupProto_GroupCall()
    }
    set {update = .groupCall(newValue)}
  }

  public var learnedProfileChange: BackupProto_LearnedProfileChatUpdate {
    get {
      if case .learnedProfileChange(let v)? = update {return v}
      return BackupProto_LearnedProfileChatUpdate()
    }
    set {update = .learnedProfileChange(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// If unset, importers should ignore the update message without throwing an error.
  public enum OneOf_Update: Equatable, Sendable {
    case simpleUpdate(BackupProto_SimpleChatUpdate)
    case groupChange(BackupProto_GroupChangeChatUpdate)
    case expirationTimerChange(BackupProto_ExpirationTimerChatUpdate)
    case profileChange(BackupProto_ProfileChangeChatUpdate)
    case threadMerge(BackupProto_ThreadMergeChatUpdate)
    case sessionSwitchover(BackupProto_SessionSwitchoverChatUpdate)
    case individualCall(BackupProto_IndividualCall)
    case groupCall(BackupProto_GroupCall)
    case learnedProfileChange(BackupProto_LearnedProfileChatUpdate)

  }

  public init() {}
}

public struct BackupProto_IndividualCall: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: UInt64 {
    get {return _callID ?? 0}
    set {_callID = newValue}
  }
  /// Returns true if `callID` has been explicitly set.
  public var hasCallID: Bool {return self._callID != nil}
  /// Clears the value of `callID`. Subsequent reads from it will return its default value.
  public mutating func clearCallID() {self._callID = nil}

  public var type: BackupProto_IndividualCall.TypeEnum = .unknownType

  public var direction: BackupProto_IndividualCall.Direction = .unknownDirection

  public var state: BackupProto_IndividualCall.State = .unknownState

  public var startedCallTimestamp: UInt64 = 0

  public var read: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Interpret as "Audio call"
    case unknownType // = 0
    case audioCall // = 1
    case videoCall // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownType
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownType
      case 1: self = .audioCall
      case 2: self = .videoCall
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownType: return 0
      case .audioCall: return 1
      case .videoCall: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [BackupProto_IndividualCall.TypeEnum] = [
      .unknownType,
      .audioCall,
      .videoCall,
    ]

  }

  public enum Direction: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Interpret as "Incoming"
    case unknownDirection // = 0
    case incoming // = 1
    case outgoing // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownDirection
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownDirection
      case 1: self = .incoming
      case 2: self = .outgoing
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownDirection: return 0
      case .incoming: return 1
      case .outgoing: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [BackupProto_IndividualCall.Direction] = [
      .unknownDirection,
      .incoming,
      .outgoing,
    ]

  }

  public enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Interpret as "Accepted"
    case unknownState // = 0
    case accepted // = 1
    case notAccepted // = 2

    /// An incoming call that is no longer ongoing, which we neither accepted
    /// not actively declined. For example, it expired, was canceled by the
    /// sender, or was rejected due to being in another call.
    case missed // = 3

    /// We auto-declined an incoming call due to a notification profile.
    case missedNotificationProfile // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownState
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownState
      case 1: self = .accepted
      case 2: self = .notAccepted
      case 3: self = .missed
      case 4: self = .missedNotificationProfile
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownState: return 0
      case .accepted: return 1
      case .notAccepted: return 2
      case .missed: return 3
      case .missedNotificationProfile: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [BackupProto_IndividualCall.State] = [
      .unknownState,
      .accepted,
      .notAccepted,
      .missed,
      .missedNotificationProfile,
    ]

  }

  public init() {}

  fileprivate var _callID: UInt64? = nil
}

public struct BackupProto_GroupCall: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: UInt64 {
    get {return _callID ?? 0}
    set {_callID = newValue}
  }
  /// Returns true if `callID` has been explicitly set.
  public var hasCallID: Bool {return self._callID != nil}
  /// Clears the value of `callID`. Subsequent reads from it will return its default value.
  public mutating func clearCallID() {self._callID = nil}

  public var state: BackupProto_GroupCall.State = .unknownState

  public var ringerRecipientID: UInt64 {
    get {return _ringerRecipientID ?? 0}
    set {_ringerRecipientID = newValue}
  }
  /// Returns true if `ringerRecipientID` has been explicitly set.
  public var hasRingerRecipientID: Bool {return self._ringerRecipientID != nil}
  /// Clears the value of `ringerRecipientID`. Subsequent reads from it will return its default value.
  public mutating func clearRingerRecipientID() {self._ringerRecipientID = nil}

  public var startedCallRecipientID: UInt64 {
    get {return _startedCallRecipientID ?? 0}
    set {_startedCallRecipientID = newValue}
  }
  /// Returns true if `startedCallRecipientID` has been explicitly set.
  public var hasStartedCallRecipientID: Bool {return self._startedCallRecipientID != nil}
  /// Clears the value of `startedCallRecipientID`. Subsequent reads from it will return its default value.
  public mutating func clearStartedCallRecipientID() {self._startedCallRecipientID = nil}

  public var startedCallTimestamp: UInt64 = 0

  /// The time the call ended.
  public var endedCallTimestamp: UInt64 {
    get {return _endedCallTimestamp ?? 0}
    set {_endedCallTimestamp = newValue}
  }
  /// Returns true if `endedCallTimestamp` has been explicitly set.
  public var hasEndedCallTimestamp: Bool {return self._endedCallTimestamp != nil}
  /// Clears the value of `endedCallTimestamp`. Subsequent reads from it will return its default value.
  public mutating func clearEndedCallTimestamp() {self._endedCallTimestamp = nil}

  public var read: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Interpret as "Generic"
    case unknownState // = 0

    /// A group call was started without ringing.
    case generic // = 1

    /// We joined a group call that was started without ringing.
    case joined // = 2

    /// An incoming group call is actively ringing.
    case ringing // = 3

    /// We accepted an incoming group ring.
    case accepted // = 4

    /// We declined an incoming group ring.
    case declined // = 5

    /// We missed an incoming group ring, for example because it expired.
    case missed // = 6

    /// We auto-declined an incoming group ring due to a notification profile.
    case missedNotificationProfile // = 7

    /// An outgoing ring was started. We don't track any state for outgoing rings
    /// beyond that they started.
    case outgoingRing // = 8
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownState
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownState
      case 1: self = .generic
      case 2: self = .joined
      case 3: self = .ringing
      case 4: self = .accepted
      case 5: self = .declined
      case 6: self = .missed
      case 7: self = .missedNotificationProfile
      case 8: self = .outgoingRing
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownState: return 0
      case .generic: return 1
      case .joined: return 2
      case .ringing: return 3
      case .accepted: return 4
      case .declined: return 5
      case .missed: return 6
      case .missedNotificationProfile: return 7
      case .outgoingRing: return 8
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [BackupProto_GroupCall.State] = [
      .unknownState,
      .generic,
      .joined,
      .ringing,
      .accepted,
      .declined,
      .missed,
      .missedNotificationProfile,
      .outgoingRing,
    ]

  }

  public init() {}

  fileprivate var _callID: UInt64? = nil
  fileprivate var _ringerRecipientID: UInt64? = nil
  fileprivate var _startedCallRecipientID: UInt64? = nil
  fileprivate var _endedCallTimestamp: UInt64? = nil
}

public struct BackupProto_SimpleChatUpdate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: BackupProto_SimpleChatUpdate.TypeEnum = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Importers should skip the update without throwing an error.
    case unknown // = 0
    case joinedSignal // = 1
    case identityUpdate // = 2
    case identityVerified // = 3

    /// marking as unverified
    case identityDefault // = 4
    case changeNumber // = 5
    case releaseChannelDonationRequest // = 6
    case endSession // = 7
    case chatSessionRefresh // = 8
    case badDecrypt // = 9
    case paymentsActivated // = 10
    case paymentActivationRequest // = 11
    case unsupportedProtocolMessage // = 12
    case reportedSpam // = 13
    case blocked // = 14
    case unblocked // = 15
    case messageRequestAccepted // = 16
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .joinedSignal
      case 2: self = .identityUpdate
      case 3: self = .identityVerified
      case 4: self = .identityDefault
      case 5: self = .changeNumber
      case 6: self = .releaseChannelDonationRequest
      case 7: self = .endSession
      case 8: self = .chatSessionRefresh
      case 9: self = .badDecrypt
      case 10: self = .paymentsActivated
      case 11: self = .paymentActivationRequest
      case 12: self = .unsupportedProtocolMessage
      case 13: self = .reportedSpam
      case 14: self = .blocked
      case 15: self = .unblocked
      case 16: self = .messageRequestAccepted
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .joinedSignal: return 1
      case .identityUpdate: return 2
      case .identityVerified: return 3
      case .identityDefault: return 4
      case .changeNumber: return 5
      case .releaseChannelDonationRequest: return 6
      case .endSession: return 7
      case .chatSessionRefresh: return 8
      case .badDecrypt: return 9
      case .paymentsActivated: return 10
      case .paymentActivationRequest: return 11
      case .unsupportedProtocolMessage: return 12
      case .reportedSpam: return 13
      case .blocked: return 14
      case .unblocked: return 15
      case .messageRequestAccepted: return 16
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [BackupProto_SimpleChatUpdate.TypeEnum] = [
      .unknown,
      .joinedSignal,
      .identityUpdate,
      .identityVerified,
      .identityDefault,
      .changeNumber,
      .releaseChannelDonationRequest,
      .endSession,
      .chatSessionRefresh,
      .badDecrypt,
      .paymentsActivated,
      .paymentActivationRequest,
      .unsupportedProtocolMessage,
      .reportedSpam,
      .blocked,
      .unblocked,
      .messageRequestAccepted,
    ]

  }

  public init() {}
}

/// For 1:1 chat updates only.
/// For group thread updates use GroupExpirationTimerUpdate.
public struct BackupProto_ExpirationTimerChatUpdate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 0 means the expiration timer was disabled
  public var expiresInMs: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BackupProto_ProfileChangeChatUpdate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var previousName: String = String()

  public var newName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BackupProto_LearnedProfileChatUpdate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If unset, importers should consider the previous name to be an empty string.
  public var previousName: BackupProto_LearnedProfileChatUpdate.OneOf_PreviousName? = nil

  public var e164: UInt64 {
    get {
      if case .e164(let v)? = previousName {return v}
      return 0
    }
    set {previousName = .e164(newValue)}
  }

  public var username: String {
    get {
      if case .username(let v)? = previousName {return v}
      return String()
    }
    set {previousName = .username(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// If unset, importers should consider the previous name to be an empty string.
  public enum OneOf_PreviousName: Equatable, Sendable {
    case e164(UInt64)
    case username(String)

  }

  public init() {}
}

public struct BackupProto_ThreadMergeChatUpdate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var previousE164: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BackupProto_SessionSwitchoverChatUpdate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var e164: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BackupProto_GroupChangeChatUpdate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Must be one or more; all updates batched together came from
  /// a single batched group state update.
  public var updates: [BackupProto_GroupChangeChatUpdate.Update] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Update: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// If unset, importers should consider it to be a GenericGroupUpdate with unset updaterAci
    public var update: BackupProto_GroupChangeChatUpdate.Update.OneOf_Update? = nil

    public var genericGroupUpdate: BackupProto_GenericGroupUpdate {
      get {
        if case .genericGroupUpdate(let v)? = update {return v}
        return BackupProto_GenericGroupUpdate()
      }
      set {update = .genericGroupUpdate(newValue)}
    }

    public var groupCreationUpdate: BackupProto_GroupCreationUpdate {
      get {
        if case .groupCreationUpdate(let v)? = update {return v}
        return BackupProto_GroupCreationUpdate()
      }
      set {update = .groupCreationUpdate(newValue)}
    }

    public var groupNameUpdate: BackupProto_GroupNameUpdate {
      get {
        if case .groupNameUpdate(let v)? = update {return v}
        return BackupProto_GroupNameUpdate()
      }
      set {update = .groupNameUpdate(newValue)}
    }

    public var groupAvatarUpdate: BackupProto_GroupAvatarUpdate {
      get {
        if case .groupAvatarUpdate(let v)? = update {return v}
        return BackupProto_GroupAvatarUpdate()
      }
      set {update = .groupAvatarUpdate(newValue)}
    }

    public var groupDescriptionUpdate: BackupProto_GroupDescriptionUpdate {
      get {
        if case .groupDescriptionUpdate(let v)? = update {return v}
        return BackupProto_GroupDescriptionUpdate()
      }
      set {update = .groupDescriptionUpdate(newValue)}
    }

    public var groupMembershipAccessLevelChangeUpdate: BackupProto_GroupMembershipAccessLevelChangeUpdate {
      get {
        if case .groupMembershipAccessLevelChangeUpdate(let v)? = update {return v}
        return BackupProto_GroupMembershipAccessLevelChangeUpdate()
      }
      set {update = .groupMembershipAccessLevelChangeUpdate(newValue)}
    }

    public var groupAttributesAccessLevelChangeUpdate: BackupProto_GroupAttributesAccessLevelChangeUpdate {
      get {
        if case .groupAttributesAccessLevelChangeUpdate(let v)? = update {return v}
        return BackupProto_GroupAttributesAccessLevelChangeUpdate()
      }
      set {update = .groupAttributesAccessLevelChangeUpdate(newValue)}
    }

    public var groupAnnouncementOnlyChangeUpdate: BackupProto_GroupAnnouncementOnlyChangeUpdate {
      get {
        if case .groupAnnouncementOnlyChangeUpdate(let v)? = update {return v}
        return BackupProto_GroupAnnouncementOnlyChangeUpdate()
      }
      set {update = .groupAnnouncementOnlyChangeUpdate(newValue)}
    }

    public var groupAdminStatusUpdate: BackupProto_GroupAdminStatusUpdate {
      get {
        if case .groupAdminStatusUpdate(let v)? = update {return v}
        return BackupProto_GroupAdminStatusUpdate()
      }
      set {update = .groupAdminStatusUpdate(newValue)}
    }

    public var groupMemberLeftUpdate: BackupProto_GroupMemberLeftUpdate {
      get {
        if case .groupMemberLeftUpdate(let v)? = update {return v}
        return BackupProto_GroupMemberLeftUpdate()
      }
      set {update = .groupMemberLeftUpdate(newValue)}
    }

    public var groupMemberRemovedUpdate: BackupProto_GroupMemberRemovedUpdate {
      get {
        if case .groupMemberRemovedUpdate(let v)? = update {return v}
        return BackupProto_GroupMemberRemovedUpdate()
      }
      set {update = .groupMemberRemovedUpdate(newValue)}
    }

    public var selfInvitedToGroupUpdate: BackupProto_SelfInvitedToGroupUpdate {
      get {
        if case .selfInvitedToGroupUpdate(let v)? = update {return v}
        return BackupProto_SelfInvitedToGroupUpdate()
      }
      set {update = .selfInvitedToGroupUpdate(newValue)}
    }

    public var selfInvitedOtherUserToGroupUpdate: BackupProto_SelfInvitedOtherUserToGroupUpdate {
      get {
        if case .selfInvitedOtherUserToGroupUpdate(let v)? = update {return v}
        return BackupProto_SelfInvitedOtherUserToGroupUpdate()
      }
      set {update = .selfInvitedOtherUserToGroupUpdate(newValue)}
    }

    public var groupUnknownInviteeUpdate: BackupProto_GroupUnknownInviteeUpdate {
      get {
        if case .groupUnknownInviteeUpdate(let v)? = update {return v}
        return BackupProto_GroupUnknownInviteeUpdate()
      }
      set {update = .groupUnknownInviteeUpdate(newValue)}
    }

    public var groupInvitationAcceptedUpdate: BackupProto_GroupInvitationAcceptedUpdate {
      get {
        if case .groupInvitationAcceptedUpdate(let v)? = update {return v}
        return BackupProto_GroupInvitationAcceptedUpdate()
      }
      set {update = .groupInvitationAcceptedUpdate(newValue)}
    }

    public var groupInvitationDeclinedUpdate: BackupProto_GroupInvitationDeclinedUpdate {
      get {
        if case .groupInvitationDeclinedUpdate(let v)? = update {return v}
        return BackupProto_GroupInvitationDeclinedUpdate()
      }
      set {update = .groupInvitationDeclinedUpdate(newValue)}
    }

    public var groupMemberJoinedUpdate: BackupProto_GroupMemberJoinedUpdate {
      get {
        if case .groupMemberJoinedUpdate(let v)? = update {return v}
        return BackupProto_GroupMemberJoinedUpdate()
      }
      set {update = .groupMemberJoinedUpdate(newValue)}
    }

    public var groupMemberAddedUpdate: BackupProto_GroupMemberAddedUpdate {
      get {
        if case .groupMemberAddedUpdate(let v)? = update {return v}
        return BackupProto_GroupMemberAddedUpdate()
      }
      set {update = .groupMemberAddedUpdate(newValue)}
    }

    public var groupSelfInvitationRevokedUpdate: BackupProto_GroupSelfInvitationRevokedUpdate {
      get {
        if case .groupSelfInvitationRevokedUpdate(let v)? = update {return v}
        return BackupProto_GroupSelfInvitationRevokedUpdate()
      }
      set {update = .groupSelfInvitationRevokedUpdate(newValue)}
    }

    public var groupInvitationRevokedUpdate: BackupProto_GroupInvitationRevokedUpdate {
      get {
        if case .groupInvitationRevokedUpdate(let v)? = update {return v}
        return BackupProto_GroupInvitationRevokedUpdate()
      }
      set {update = .groupInvitationRevokedUpdate(newValue)}
    }

    public var groupJoinRequestUpdate: BackupProto_GroupJoinRequestUpdate {
      get {
        if case .groupJoinRequestUpdate(let v)? = update {return v}
        return BackupProto_GroupJoinRequestUpdate()
      }
      set {update = .groupJoinRequestUpdate(newValue)}
    }

    public var groupJoinRequestApprovalUpdate: BackupProto_GroupJoinRequestApprovalUpdate {
      get {
        if case .groupJoinRequestApprovalUpdate(let v)? = update {return v}
        return BackupProto_GroupJoinRequestApprovalUpdate()
      }
      set {update = .groupJoinRequestApprovalUpdate(newValue)}
    }

    public var groupJoinRequestCanceledUpdate: BackupProto_GroupJoinRequestCanceledUpdate {
      get {
        if case .groupJoinRequestCanceledUpdate(let v)? = update {return v}
        return BackupProto_GroupJoinRequestCanceledUpdate()
      }
      set {update = .groupJoinRequestCanceledUpdate(newValue)}
    }

    public var groupInviteLinkResetUpdate: BackupProto_GroupInviteLinkResetUpdate {
      get {
        if case .groupInviteLinkResetUpdate(let v)? = update {return v}
        return BackupProto_GroupInviteLinkResetUpdate()
      }
      set {update = .groupInviteLinkResetUpdate(newValue)}
    }

    public var groupInviteLinkEnabledUpdate: BackupProto_GroupInviteLinkEnabledUpdate {
      get {
        if case .groupInviteLinkEnabledUpdate(let v)? = update {return v}
        return BackupProto_GroupInviteLinkEnabledUpdate()
      }
      set {update = .groupInviteLinkEnabledUpdate(newValue)}
    }

    public var groupInviteLinkAdminApprovalUpdate: BackupProto_GroupInviteLinkAdminApprovalUpdate {
      get {
        if case .groupInviteLinkAdminApprovalUpdate(let v)? = update {return v}
        return BackupProto_GroupInviteLinkAdminApprovalUpdate()
      }
      set {update = .groupInviteLinkAdminApprovalUpdate(newValue)}
    }

    public var groupInviteLinkDisabledUpdate: BackupProto_GroupInviteLinkDisabledUpdate {
      get {
        if case .groupInviteLinkDisabledUpdate(let v)? = update {return v}
        return BackupProto_GroupInviteLinkDisabledUpdate()
      }
      set {update = .groupInviteLinkDisabledUpdate(newValue)}
    }

    public var groupMemberJoinedByLinkUpdate: BackupProto_GroupMemberJoinedByLinkUpdate {
      get {
        if case .groupMemberJoinedByLinkUpdate(let v)? = update {return v}
        return BackupProto_GroupMemberJoinedByLinkUpdate()
      }
      set {update = .groupMemberJoinedByLinkUpdate(newValue)}
    }

    public var groupV2MigrationUpdate: BackupProto_GroupV2MigrationUpdate {
      get {
        if case .groupV2MigrationUpdate(let v)? = update {return v}
        return BackupProto_GroupV2MigrationUpdate()
      }
      set {update = .groupV2MigrationUpdate(newValue)}
    }

    public var groupV2MigrationSelfInvitedUpdate: BackupProto_GroupV2MigrationSelfInvitedUpdate {
      get {
        if case .groupV2MigrationSelfInvitedUpdate(let v)? = update {return v}
        return BackupProto_GroupV2MigrationSelfInvitedUpdate()
      }
      set {update = .groupV2MigrationSelfInvitedUpdate(newValue)}
    }

    public var groupV2MigrationInvitedMembersUpdate: BackupProto_GroupV2MigrationInvitedMembersUpdate {
      get {
        if case .groupV2MigrationInvitedMembersUpdate(let v)? = update {return v}
        return BackupProto_GroupV2MigrationInvitedMembersUpdate()
      }
      set {update = .groupV2MigrationInvitedMembersUpdate(newValue)}
    }

    public var groupV2MigrationDroppedMembersUpdate: BackupProto_GroupV2MigrationDroppedMembersUpdate {
      get {
        if case .groupV2MigrationDroppedMembersUpdate(let v)? = update {return v}
        return BackupProto_GroupV2MigrationDroppedMembersUpdate()
      }
      set {update = .groupV2MigrationDroppedMembersUpdate(newValue)}
    }

    public var groupSequenceOfRequestsAndCancelsUpdate: BackupProto_GroupSequenceOfRequestsAndCancelsUpdate {
      get {
        if case .groupSequenceOfRequestsAndCancelsUpdate(let v)? = update {return v}
        return BackupProto_GroupSequenceOfRequestsAndCancelsUpdate()
      }
      set {update = .groupSequenceOfRequestsAndCancelsUpdate(newValue)}
    }

    public var groupExpirationTimerUpdate: BackupProto_GroupExpirationTimerUpdate {
      get {
        if case .groupExpirationTimerUpdate(let v)? = update {return v}
        return BackupProto_GroupExpirationTimerUpdate()
      }
      set {update = .groupExpirationTimerUpdate(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// If unset, importers should consider it to be a GenericGroupUpdate with unset updaterAci
    public enum OneOf_Update: Equatable, Sendable {
      case genericGroupUpdate(BackupProto_GenericGroupUpdate)
      case groupCreationUpdate(BackupProto_GroupCreationUpdate)
      case groupNameUpdate(BackupProto_GroupNameUpdate)
      case groupAvatarUpdate(BackupProto_GroupAvatarUpdate)
      case groupDescriptionUpdate(BackupProto_GroupDescriptionUpdate)
      case groupMembershipAccessLevelChangeUpdate(BackupProto_GroupMembershipAccessLevelChangeUpdate)
      case groupAttributesAccessLevelChangeUpdate(BackupProto_GroupAttributesAccessLevelChangeUpdate)
      case groupAnnouncementOnlyChangeUpdate(BackupProto_GroupAnnouncementOnlyChangeUpdate)
      case groupAdminStatusUpdate(BackupProto_GroupAdminStatusUpdate)
      case groupMemberLeftUpdate(BackupProto_GroupMemberLeftUpdate)
      case groupMemberRemovedUpdate(BackupProto_GroupMemberRemovedUpdate)
      case selfInvitedToGroupUpdate(BackupProto_SelfInvitedToGroupUpdate)
      case selfInvitedOtherUserToGroupUpdate(BackupProto_SelfInvitedOtherUserToGroupUpdate)
      case groupUnknownInviteeUpdate(BackupProto_GroupUnknownInviteeUpdate)
      case groupInvitationAcceptedUpdate(BackupProto_GroupInvitationAcceptedUpdate)
      case groupInvitationDeclinedUpdate(BackupProto_GroupInvitationDeclinedUpdate)
      case groupMemberJoinedUpdate(BackupProto_GroupMemberJoinedUpdate)
      case groupMemberAddedUpdate(BackupProto_GroupMemberAddedUpdate)
      case groupSelfInvitationRevokedUpdate(BackupProto_GroupSelfInvitationRevokedUpdate)
      case groupInvitationRevokedUpdate(BackupProto_GroupInvitationRevokedUpdate)
      case groupJoinRequestUpdate(BackupProto_GroupJoinRequestUpdate)
      case groupJoinRequestApprovalUpdate(BackupProto_GroupJoinRequestApprovalUpdate)
      case groupJoinRequestCanceledUpdate(BackupProto_GroupJoinRequestCanceledUpdate)
      case groupInviteLinkResetUpdate(BackupProto_GroupInviteLinkResetUpdate)
      case groupInviteLinkEnabledUpdate(BackupProto_GroupInviteLinkEnabledUpdate)
      case groupInviteLinkAdminApprovalUpdate(BackupProto_GroupInviteLinkAdminApprovalUpdate)
      case groupInviteLinkDisabledUpdate(BackupProto_GroupInviteLinkDisabledUpdate)
      case groupMemberJoinedByLinkUpdate(BackupProto_GroupMemberJoinedByLinkUpdate)
      case groupV2MigrationUpdate(BackupProto_GroupV2MigrationUpdate)
      case groupV2MigrationSelfInvitedUpdate(BackupProto_GroupV2MigrationSelfInvitedUpdate)
      case groupV2MigrationInvitedMembersUpdate(BackupProto_GroupV2MigrationInvitedMembersUpdate)
      case groupV2MigrationDroppedMembersUpdate(BackupProto_GroupV2MigrationDroppedMembersUpdate)
      case groupSequenceOfRequestsAndCancelsUpdate(BackupProto_GroupSequenceOfRequestsAndCancelsUpdate)
      case groupExpirationTimerUpdate(BackupProto_GroupExpirationTimerUpdate)

    }

    public init() {}
  }

  public init() {}
}

public struct BackupProto_GenericGroupUpdate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var updaterAci: Data {
    get {return _updaterAci ?? Data()}
    set {_updaterAci = newValue}
  }
  /// Returns true if `updaterAci` has been explicitly set.
  public var hasUpdaterAci: Bool {return self._updaterAci != nil}
  /// Clears the value of `updaterAci`. Subsequent reads from it will return its default value.
  public mutating func clearUpdaterAci() {self._updaterAci = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _updaterAci: Data? = nil
}

public struct BackupProto_GroupCreationUpdate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var updaterAci: Data {
    get {return _updaterAci ?? Data()}
    set {_updaterAci = newValue}
  }
  /// Returns true if `updaterAci` has been explicitly set.
  public var hasUpdaterAci: Bool {return self._updaterAci != nil}
  /// Clears the value of `updaterAci`. Subsequent reads from it will return its default value.
  public mutating func clearUpdaterAci() {self._updaterAci = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _updaterAci: Data? = nil
}

public struct BackupProto_GroupNameUpdate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var updaterAci: Data {
    get {return _updaterAci ?? Data()}
    set {_updaterAci = newValue}
  }
  /// Returns true if `updaterAci` has been explicitly set.
  public var hasUpdaterAci: Bool {return self._updaterAci != nil}
  /// Clears the value of `updaterAci`. Subsequent reads from it will return its default value.
  public mutating func clearUpdaterAci() {self._updaterAci = nil}

  /// Null value means the group name was removed.
  public var newGroupName: String {
    get {return _newGroupName ?? String()}
    set {_newGroupName = newValue}
  }
  /// Returns true if `newGroupName` has been explicitly set.
  public var hasNewGroupName: Bool {return self._newGroupName != nil}
  /// Clears the value of `newGroupName`. Subsequent reads from it will return its default value.
  public mutating func clearNewGroupName() {self._newGroupName = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _updaterAci: Data? = nil
  fileprivate var _newGroupName: String? = nil
}

public struct BackupProto_GroupAvatarUpdate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var updaterAci: Data {
    get {return _updaterAci ?? Data()}
    set {_updaterAci = newValue}
  }
  /// Returns true if `updaterAci` has been explicitly set.
  public var hasUpdaterAci: Bool {return self._updaterAci != nil}
  /// Clears the value of `updaterAci`. Subsequent reads from it will return its default value.
  public mutating func clearUpdaterAci() {self._updaterAci = nil}

  public var wasRemoved: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _updaterAci: Data? = nil
}

public struct BackupProto_GroupDescriptionUpdate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var updaterAci: Data {
    get {return _updaterAci ?? Data()}
    set {_updaterAci = newValue}
  }
  /// Returns true if `updaterAci` has been explicitly set.
  public var hasUpdaterAci: Bool {return self._updaterAci != nil}
  /// Clears the value of `updaterAci`. Subsequent reads from it will return its default value.
  public mutating func clearUpdaterAci() {self._updaterAci = nil}

  /// Null value means the group description was removed.
  public var newDescription: String {
    get {return _newDescription ?? String()}
    set {_newDescription = newValue}
  }
  /// Returns true if `newDescription` has been explicitly set.
  public var hasNewDescription: Bool {return self._newDescription != nil}
  /// Clears the value of `newDescription`. Subsequent reads from it will return its default value.
  public mutating func clearNewDescription() {self._newDescription = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _updaterAci: Data? = nil
  fileprivate var _newDescription: String? = nil
}

public struct BackupProto_GroupMembershipAccessLevelChangeUpdate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var updaterAci: Data {
    get {return _updaterAci ?? Data()}
    set {_updaterAci = newValue}
  }
  /// Returns true if `updaterAci` has been explicitly set.
  public var hasUpdaterAci: Bool {return self._updaterAci != nil}
  /// Clears the value of `updaterAci`. Subsequent reads from it will return its default value.
  public mutating func clearUpdaterAci() {self._updaterAci = nil}

  public var accessLevel: BackupProto_GroupV2AccessLevel = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _updaterAci: Data? = nil
}

public struct BackupProto_GroupAttributesAccessLevelChangeUpdate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var updaterAci: Data {
    get {return _updaterAci ?? Data()}
    set {_updaterAci = newValue}
  }
  /// Returns true if `updaterAci` has been explicitly set.
  public var hasUpdaterAci: Bool {return self._updaterAci != nil}
  /// Clears the value of `updaterAci`. Subsequent reads from it will return its default value.
  public mutating func clearUpdaterAci() {self._updaterAci = nil}

  public var accessLevel: BackupProto_GroupV2AccessLevel = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _updaterAci: Data? = nil
}

public struct BackupProto_GroupAnnouncementOnlyChangeUpdate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var updaterAci: Data {
    get {return _updaterAci ?? Data()}
    set {_updaterAci = newValue}
  }
  /// Returns true if `updaterAci` has been explicitly set.
  public var hasUpdaterAci: Bool {return self._updaterAci != nil}
  /// Clears the value of `updaterAci`. Subsequent reads from it will return its default value.
  public mutating func clearUpdaterAci() {self._updaterAci = nil}

  public var isAnnouncementOnly: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _updaterAci: Data? = nil
}

public struct BackupProto_GroupAdminStatusUpdate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var updaterAci: Data {
    get {return _updaterAci ?? Data()}
    set {_updaterAci = newValue}
  }
  /// Returns true if `updaterAci` has been explicitly set.
  public var hasUpdaterAci: Bool {return self._updaterAci != nil}
  /// Clears the value of `updaterAci`. Subsequent reads from it will return its default value.
  public mutating func clearUpdaterAci() {self._updaterAci = nil}

  /// The aci who had admin status granted or revoked.
  public var memberAci: Data = Data()

  public var wasAdminStatusGranted: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _updaterAci: Data? = nil
}

public struct BackupProto_GroupMemberLeftUpdate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var aci: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BackupProto_GroupMemberRemovedUpdate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var removerAci: Data {
    get {return _removerAci ?? Data()}
    set {_removerAci = newValue}
  }
  /// Returns true if `removerAci` has been explicitly set.
  public var hasRemoverAci: Bool {return self._removerAci != nil}
  /// Clears the value of `removerAci`. Subsequent reads from it will return its default value.
  public mutating func clearRemoverAci() {self._removerAci = nil}

  public var removedAci: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _removerAci: Data? = nil
}

public struct BackupProto_SelfInvitedToGroupUpdate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var inviterAci: Data {
    get {return _inviterAci ?? Data()}
    set {_inviterAci = newValue}
  }
  /// Returns true if `inviterAci` has been explicitly set.
  public var hasInviterAci: Bool {return self._inviterAci != nil}
  /// Clears the value of `inviterAci`. Subsequent reads from it will return its default value.
  public mutating func clearInviterAci() {self._inviterAci = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _inviterAci: Data? = nil
}

public struct BackupProto_SelfInvitedOtherUserToGroupUpdate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If no invitee id available, use GroupUnknownInviteeUpdate
  public var inviteeServiceID: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BackupProto_GroupUnknownInviteeUpdate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Can be the self user.
  public var inviterAci: Data {
    get {return _inviterAci ?? Data()}
    set {_inviterAci = newValue}
  }
  /// Returns true if `inviterAci` has been explicitly set.
  public var hasInviterAci: Bool {return self._inviterAci != nil}
  /// Clears the value of `inviterAci`. Subsequent reads from it will return its default value.
  public mutating func clearInviterAci() {self._inviterAci = nil}

  public var inviteeCount: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _inviterAci: Data? = nil
}

public struct BackupProto_GroupInvitationAcceptedUpdate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var inviterAci: Data {
    get {return _inviterAci ?? Data()}
    set {_inviterAci = newValue}
  }
  /// Returns true if `inviterAci` has been explicitly set.
  public var hasInviterAci: Bool {return self._inviterAci != nil}
  /// Clears the value of `inviterAci`. Subsequent reads from it will return its default value.
  public mutating func clearInviterAci() {self._inviterAci = nil}

  public var newMemberAci: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _inviterAci: Data? = nil
}

public struct BackupProto_GroupInvitationDeclinedUpdate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var inviterAci: Data {
    get {return _inviterAci ?? Data()}
    set {_inviterAci = newValue}
  }
  /// Returns true if `inviterAci` has been explicitly set.
  public var hasInviterAci: Bool {return self._inviterAci != nil}
  /// Clears the value of `inviterAci`. Subsequent reads from it will return its default value.
  public mutating func clearInviterAci() {self._inviterAci = nil}

  /// Note: if invited by pni, just set inviteeAci to nil.
  public var inviteeAci: Data {
    get {return _inviteeAci ?? Data()}
    set {_inviteeAci = newValue}
  }
  /// Returns true if `inviteeAci` has been explicitly set.
  public var hasInviteeAci: Bool {return self._inviteeAci != nil}
  /// Clears the value of `inviteeAci`. Subsequent reads from it will return its default value.
  public mutating func clearInviteeAci() {self._inviteeAci = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _inviterAci: Data? = nil
  fileprivate var _inviteeAci: Data? = nil
}

public struct BackupProto_GroupMemberJoinedUpdate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var newMemberAci: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BackupProto_GroupMemberAddedUpdate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var updaterAci: Data {
    get {return _updaterAci ?? Data()}
    set {_updaterAci = newValue}
  }
  /// Returns true if `updaterAci` has been explicitly set.
  public var hasUpdaterAci: Bool {return self._updaterAci != nil}
  /// Clears the value of `updaterAci`. Subsequent reads from it will return its default value.
  public mutating func clearUpdaterAci() {self._updaterAci = nil}

  public var newMemberAci: Data = Data()

  public var hadOpenInvitation: Bool = false

  /// If hadOpenInvitation is true, optionally include aci of the inviter.
  public var inviterAci: Data {
    get {return _inviterAci ?? Data()}
    set {_inviterAci = newValue}
  }
  /// Returns true if `inviterAci` has been explicitly set.
  public var hasInviterAci: Bool {return self._inviterAci != nil}
  /// Clears the value of `inviterAci`. Subsequent reads from it will return its default value.
  public mutating func clearInviterAci() {self._inviterAci = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _updaterAci: Data? = nil
  fileprivate var _inviterAci: Data? = nil
}

/// An invitation to self was revoked.
public struct BackupProto_GroupSelfInvitationRevokedUpdate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var revokerAci: Data {
    get {return _revokerAci ?? Data()}
    set {_revokerAci = newValue}
  }
  /// Returns true if `revokerAci` has been explicitly set.
  public var hasRevokerAci: Bool {return self._revokerAci != nil}
  /// Clears the value of `revokerAci`. Subsequent reads from it will return its default value.
  public mutating func clearRevokerAci() {self._revokerAci = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _revokerAci: Data? = nil
}

/// These invitees should never be the local user.
/// Use GroupSelfInvitationRevokedUpdate in those cases.
/// The inviter or updater can be the local user.
public struct BackupProto_GroupInvitationRevokedUpdate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The member that revoked the invite(s), not the inviter!
  /// Assumed to be an admin (at the time, may no longer be an
  /// admin or even a member).
  public var updaterAci: Data {
    get {return _updaterAci ?? Data()}
    set {_updaterAci = newValue}
  }
  /// Returns true if `updaterAci` has been explicitly set.
  public var hasUpdaterAci: Bool {return self._updaterAci != nil}
  /// Clears the value of `updaterAci`. Subsequent reads from it will return its default value.
  public mutating func clearUpdaterAci() {self._updaterAci = nil}

  public var invitees: [BackupProto_GroupInvitationRevokedUpdate.Invitee] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Invitee: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var inviterAci: Data {
      get {return _inviterAci ?? Data()}
      set {_inviterAci = newValue}
    }
    /// Returns true if `inviterAci` has been explicitly set.
    public var hasInviterAci: Bool {return self._inviterAci != nil}
    /// Clears the value of `inviterAci`. Subsequent reads from it will return its default value.
    public mutating func clearInviterAci() {self._inviterAci = nil}

    /// Prefer to use aci over pni. No need to set
    /// pni if aci is set. Both can be missing.
    public var inviteeAci: Data {
      get {return _inviteeAci ?? Data()}
      set {_inviteeAci = newValue}
    }
    /// Returns true if `inviteeAci` has been explicitly set.
    public var hasInviteeAci: Bool {return self._inviteeAci != nil}
    /// Clears the value of `inviteeAci`. Subsequent reads from it will return its default value.
    public mutating func clearInviteeAci() {self._inviteeAci = nil}

    public var inviteePni: Data {
      get {return _inviteePni ?? Data()}
      set {_inviteePni = newValue}
    }
    /// Returns true if `inviteePni` has been explicitly set.
    public var hasInviteePni: Bool {return self._inviteePni != nil}
    /// Clears the value of `inviteePni`. Subsequent reads from it will return its default value.
    public mutating func clearInviteePni() {self._inviteePni = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _inviterAci: Data? = nil
    fileprivate var _inviteeAci: Data? = nil
    fileprivate var _inviteePni: Data? = nil
  }

  public init() {}

  fileprivate var _updaterAci: Data? = nil
}

public struct BackupProto_GroupJoinRequestUpdate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestorAci: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BackupProto_GroupJoinRequestApprovalUpdate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestorAci: Data = Data()

  /// The aci that approved or rejected the request.
  public var updaterAci: Data {
    get {return _updaterAci ?? Data()}
    set {_updaterAci = newValue}
  }
  /// Returns true if `updaterAci` has been explicitly set.
  public var hasUpdaterAci: Bool {return self._updaterAci != nil}
  /// Clears the value of `updaterAci`. Subsequent reads from it will return its default value.
  public mutating func clearUpdaterAci() {self._updaterAci = nil}

  public var wasApproved: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _updaterAci: Data? = nil
}

public struct BackupProto_GroupJoinRequestCanceledUpdate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestorAci: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A single requestor has requested to join and cancelled
/// their request repeatedly with no other updates in between.
/// The last action encompassed by this update is always a
/// cancellation; if there was another open request immediately
/// after, it will be a separate GroupJoinRequestUpdate, either
/// in the same frame or in a subsequent frame.
public struct BackupProto_GroupSequenceOfRequestsAndCancelsUpdate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestorAci: Data = Data()

  public var count: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BackupProto_GroupInviteLinkResetUpdate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var updaterAci: Data {
    get {return _updaterAci ?? Data()}
    set {_updaterAci = newValue}
  }
  /// Returns true if `updaterAci` has been explicitly set.
  public var hasUpdaterAci: Bool {return self._updaterAci != nil}
  /// Clears the value of `updaterAci`. Subsequent reads from it will return its default value.
  public mutating func clearUpdaterAci() {self._updaterAci = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _updaterAci: Data? = nil
}

public struct BackupProto_GroupInviteLinkEnabledUpdate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var updaterAci: Data {
    get {return _updaterAci ?? Data()}
    set {_updaterAci = newValue}
  }
  /// Returns true if `updaterAci` has been explicitly set.
  public var hasUpdaterAci: Bool {return self._updaterAci != nil}
  /// Clears the value of `updaterAci`. Subsequent reads from it will return its default value.
  public mutating func clearUpdaterAci() {self._updaterAci = nil}

  public var linkRequiresAdminApproval: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _updaterAci: Data? = nil
}

public struct BackupProto_GroupInviteLinkAdminApprovalUpdate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var updaterAci: Data {
    get {return _updaterAci ?? Data()}
    set {_updaterAci = newValue}
  }
  /// Returns true if `updaterAci` has been explicitly set.
  public var hasUpdaterAci: Bool {return self._updaterAci != nil}
  /// Clears the value of `updaterAci`. Subsequent reads from it will return its default value.
  public mutating func clearUpdaterAci() {self._updaterAci = nil}

  public var linkRequiresAdminApproval: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _updaterAci: Data? = nil
}

public struct BackupProto_GroupInviteLinkDisabledUpdate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var updaterAci: Data {
    get {return _updaterAci ?? Data()}
    set {_updaterAci = newValue}
  }
  /// Returns true if `updaterAci` has been explicitly set.
  public var hasUpdaterAci: Bool {return self._updaterAci != nil}
  /// Clears the value of `updaterAci`. Subsequent reads from it will return its default value.
  public mutating func clearUpdaterAci() {self._updaterAci = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _updaterAci: Data? = nil
}

public struct BackupProto_GroupMemberJoinedByLinkUpdate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var newMemberAci: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A gv1->gv2 migration occurred.
public struct BackupProto_GroupV2MigrationUpdate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Another user migrated gv1->gv2 but was unable to add
/// the local user and invited them instead.
public struct BackupProto_GroupV2MigrationSelfInvitedUpdate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The local user migrated gv1->gv2 but was unable to
/// add some members and invited them instead.
/// (Happens if we don't have the invitee's profile key)
public struct BackupProto_GroupV2MigrationInvitedMembersUpdate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var invitedMembersCount: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The local user migrated gv1->gv2 but was unable to
/// add or invite some members and dropped them instead.
/// (Happens for e164 members where we don't have an aci).
public struct BackupProto_GroupV2MigrationDroppedMembersUpdate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var droppedMembersCount: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// For 1:1 timer updates, use ExpirationTimerChatUpdate.
public struct BackupProto_GroupExpirationTimerUpdate: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 0 means the expiration timer was disabled
  public var expiresInMs: UInt64 = 0

  public var updaterAci: Data {
    get {return _updaterAci ?? Data()}
    set {_updaterAci = newValue}
  }
  /// Returns true if `updaterAci` has been explicitly set.
  public var hasUpdaterAci: Bool {return self._updaterAci != nil}
  /// Clears the value of `updaterAci`. Subsequent reads from it will return its default value.
  public mutating func clearUpdaterAci() {self._updaterAci = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _updaterAci: Data? = nil
}

public struct BackupProto_StickerPack: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var packID: Data = Data()

  public var packKey: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BackupProto_ChatStyle: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If unset, importers should consider there to be no wallpaper.
  public var wallpaper: OneOf_Wallpaper? {
    get {return _storage._wallpaper}
    set {_uniqueStorage()._wallpaper = newValue}
  }

  public var wallpaperPreset: BackupProto_ChatStyle.WallpaperPreset {
    get {
      if case .wallpaperPreset(let v)? = _storage._wallpaper {return v}
      return .unknownWallpaperPreset
    }
    set {_uniqueStorage()._wallpaper = .wallpaperPreset(newValue)}
  }

  /// This `FilePointer` is expected not to contain a `fileName`, `width`,
  /// `height`, or `caption`.
  public var wallpaperPhoto: BackupProto_FilePointer {
    get {
      if case .wallpaperPhoto(let v)? = _storage._wallpaper {return v}
      return BackupProto_FilePointer()
    }
    set {_uniqueStorage()._wallpaper = .wallpaperPhoto(newValue)}
  }

  /// If unset, importers should consider it to be AutomaticBubbleColor
  public var bubbleColor: OneOf_BubbleColor? {
    get {return _storage._bubbleColor}
    set {_uniqueStorage()._bubbleColor = newValue}
  }

  /// Bubble setting is automatically determined based on the wallpaper setting,
  /// or `SOLID_ULTRAMARINE` for `noWallpaper`
  public var autoBubbleColor: BackupProto_ChatStyle.AutomaticBubbleColor {
    get {
      if case .autoBubbleColor(let v)? = _storage._bubbleColor {return v}
      return BackupProto_ChatStyle.AutomaticBubbleColor()
    }
    set {_uniqueStorage()._bubbleColor = .autoBubbleColor(newValue)}
  }

  public var bubbleColorPreset: BackupProto_ChatStyle.BubbleColorPreset {
    get {
      if case .bubbleColorPreset(let v)? = _storage._bubbleColor {return v}
      return .unknownBubbleColorPreset
    }
    set {_uniqueStorage()._bubbleColor = .bubbleColorPreset(newValue)}
  }

  /// See AccountSettings.customChatColors
  public var customColorID: UInt64 {
    get {
      if case .customColorID(let v)? = _storage._bubbleColor {return v}
      return 0
    }
    set {_uniqueStorage()._bubbleColor = .customColorID(newValue)}
  }

  public var dimWallpaperInDarkMode: Bool {
    get {return _storage._dimWallpaperInDarkMode}
    set {_uniqueStorage()._dimWallpaperInDarkMode = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// If unset, importers should consider there to be no wallpaper.
  public enum OneOf_Wallpaper: Equatable, Sendable {
    case wallpaperPreset(BackupProto_ChatStyle.WallpaperPreset)
    /// This `FilePointer` is expected not to contain a `fileName`, `width`,
    /// `height`, or `caption`.
    case wallpaperPhoto(BackupProto_FilePointer)

  }

  /// If unset, importers should consider it to be AutomaticBubbleColor
  public enum OneOf_BubbleColor: Equatable, Sendable {
    /// Bubble setting is automatically determined based on the wallpaper setting,
    /// or `SOLID_ULTRAMARINE` for `noWallpaper`
    case autoBubbleColor(BackupProto_ChatStyle.AutomaticBubbleColor)
    case bubbleColorPreset(BackupProto_ChatStyle.BubbleColorPreset)
    /// See AccountSettings.customChatColors
    case customColorID(UInt64)

  }

  public enum WallpaperPreset: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Interpret as the wallpaper being unset
    case unknownWallpaperPreset // = 0
    case solidBlush // = 1
    case solidCopper // = 2
    case solidDust // = 3
    case solidCeladon // = 4
    case solidRainforest // = 5
    case solidPacific // = 6
    case solidFrost // = 7
    case solidNavy // = 8
    case solidLilac // = 9
    case solidPink // = 10
    case solidEggplant // = 11
    case solidSilver // = 12
    case gradientSunset // = 13
    case gradientNoir // = 14
    case gradientHeatmap // = 15
    case gradientAqua // = 16
    case gradientIridescent // = 17
    case gradientMonstera // = 18
    case gradientBliss // = 19
    case gradientSky // = 20
    case gradientPeach // = 21
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownWallpaperPreset
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownWallpaperPreset
      case 1: self = .solidBlush
      case 2: self = .solidCopper
      case 3: self = .solidDust
      case 4: self = .solidCeladon
      case 5: self = .solidRainforest
      case 6: self = .solidPacific
      case 7: self = .solidFrost
      case 8: self = .solidNavy
      case 9: self = .solidLilac
      case 10: self = .solidPink
      case 11: self = .solidEggplant
      case 12: self = .solidSilver
      case 13: self = .gradientSunset
      case 14: self = .gradientNoir
      case 15: self = .gradientHeatmap
      case 16: self = .gradientAqua
      case 17: self = .gradientIridescent
      case 18: self = .gradientMonstera
      case 19: self = .gradientBliss
      case 20: self = .gradientSky
      case 21: self = .gradientPeach
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownWallpaperPreset: return 0
      case .solidBlush: return 1
      case .solidCopper: return 2
      case .solidDust: return 3
      case .solidCeladon: return 4
      case .solidRainforest: return 5
      case .solidPacific: return 6
      case .solidFrost: return 7
      case .solidNavy: return 8
      case .solidLilac: return 9
      case .solidPink: return 10
      case .solidEggplant: return 11
      case .solidSilver: return 12
      case .gradientSunset: return 13
      case .gradientNoir: return 14
      case .gradientHeatmap: return 15
      case .gradientAqua: return 16
      case .gradientIridescent: return 17
      case .gradientMonstera: return 18
      case .gradientBliss: return 19
      case .gradientSky: return 20
      case .gradientPeach: return 21
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [BackupProto_ChatStyle.WallpaperPreset] = [
      .unknownWallpaperPreset,
      .solidBlush,
      .solidCopper,
      .solidDust,
      .solidCeladon,
      .solidRainforest,
      .solidPacific,
      .solidFrost,
      .solidNavy,
      .solidLilac,
      .solidPink,
      .solidEggplant,
      .solidSilver,
      .gradientSunset,
      .gradientNoir,
      .gradientHeatmap,
      .gradientAqua,
      .gradientIridescent,
      .gradientMonstera,
      .gradientBliss,
      .gradientSky,
      .gradientPeach,
    ]

  }

  public enum BubbleColorPreset: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Interpret as the user's default chat bubble color
    case unknownBubbleColorPreset // = 0
    case solidUltramarine // = 1
    case solidCrimson // = 2
    case solidVermilion // = 3
    case solidBurlap // = 4
    case solidForest // = 5
    case solidWintergreen // = 6
    case solidTeal // = 7
    case solidBlue // = 8
    case solidIndigo // = 9
    case solidViolet // = 10
    case solidPlum // = 11
    case solidTaupe // = 12
    case solidSteel // = 13
    case gradientEmber // = 14
    case gradientMidnight // = 15
    case gradientInfrared // = 16
    case gradientLagoon // = 17
    case gradientFluorescent // = 18
    case gradientBasil // = 19
    case gradientSublime // = 20
    case gradientSea // = 21
    case gradientTangerine // = 22
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownBubbleColorPreset
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownBubbleColorPreset
      case 1: self = .solidUltramarine
      case 2: self = .solidCrimson
      case 3: self = .solidVermilion
      case 4: self = .solidBurlap
      case 5: self = .solidForest
      case 6: self = .solidWintergreen
      case 7: self = .solidTeal
      case 8: self = .solidBlue
      case 9: self = .solidIndigo
      case 10: self = .solidViolet
      case 11: self = .solidPlum
      case 12: self = .solidTaupe
      case 13: self = .solidSteel
      case 14: self = .gradientEmber
      case 15: self = .gradientMidnight
      case 16: self = .gradientInfrared
      case 17: self = .gradientLagoon
      case 18: self = .gradientFluorescent
      case 19: self = .gradientBasil
      case 20: self = .gradientSublime
      case 21: self = .gradientSea
      case 22: self = .gradientTangerine
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownBubbleColorPreset: return 0
      case .solidUltramarine: return 1
      case .solidCrimson: return 2
      case .solidVermilion: return 3
      case .solidBurlap: return 4
      case .solidForest: return 5
      case .solidWintergreen: return 6
      case .solidTeal: return 7
      case .solidBlue: return 8
      case .solidIndigo: return 9
      case .solidViolet: return 10
      case .solidPlum: return 11
      case .solidTaupe: return 12
      case .solidSteel: return 13
      case .gradientEmber: return 14
      case .gradientMidnight: return 15
      case .gradientInfrared: return 16
      case .gradientLagoon: return 17
      case .gradientFluorescent: return 18
      case .gradientBasil: return 19
      case .gradientSublime: return 20
      case .gradientSea: return 21
      case .gradientTangerine: return 22
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [BackupProto_ChatStyle.BubbleColorPreset] = [
      .unknownBubbleColorPreset,
      .solidUltramarine,
      .solidCrimson,
      .solidVermilion,
      .solidBurlap,
      .solidForest,
      .solidWintergreen,
      .solidTeal,
      .solidBlue,
      .solidIndigo,
      .solidViolet,
      .solidPlum,
      .solidTaupe,
      .solidSteel,
      .gradientEmber,
      .gradientMidnight,
      .gradientInfrared,
      .gradientLagoon,
      .gradientFluorescent,
      .gradientBasil,
      .gradientSublime,
      .gradientSea,
      .gradientTangerine,
    ]

  }

  public struct Gradient: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// degrees
    public var angle: UInt32 = 0

    /// 0xAARRGGBB
    public var colors: [UInt32] = []

    /// percent from 0 to 1
    public var positions: [Float] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct CustomChatColor: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: UInt64 = 0

    /// If unset, use the default chat color
    public var color: BackupProto_ChatStyle.CustomChatColor.OneOf_Color? = nil

    /// 0xAARRGGBB
    public var solid: UInt32 {
      get {
        if case .solid(let v)? = color {return v}
        return 0
      }
      set {color = .solid(newValue)}
    }

    public var gradient: BackupProto_ChatStyle.Gradient {
      get {
        if case .gradient(let v)? = color {return v}
        return BackupProto_ChatStyle.Gradient()
      }
      set {color = .gradient(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// If unset, use the default chat color
    public enum OneOf_Color: Equatable, Sendable {
      /// 0xAARRGGBB
      case solid(UInt32)
      case gradient(BackupProto_ChatStyle.Gradient)

    }

    public init() {}
  }

  public struct AutomaticBubbleColor: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct BackupProto_NotificationProfile: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var emoji: String {
    get {return _emoji ?? String()}
    set {_emoji = newValue}
  }
  /// Returns true if `emoji` has been explicitly set.
  public var hasEmoji: Bool {return self._emoji != nil}
  /// Clears the value of `emoji`. Subsequent reads from it will return its default value.
  public mutating func clearEmoji() {self._emoji = nil}

  /// 0xAARRGGBB
  public var color: UInt32 = 0

  public var createdAtMs: UInt64 = 0

  public var allowAllCalls: Bool = false

  public var allowAllMentions: Bool = false

  /// generated recipient id for allowed groups and contacts
  public var allowedMembers: [UInt64] = []

  public var scheduleEnabled: Bool = false

  /// 24-hour clock int, 0000-2359 (e.g., 15, 900, 1130, 2345)
  public var scheduleStartTime: UInt32 = 0

  /// 24-hour clock int, 0000-2359 (e.g., 15, 900, 1130, 2345)
  public var scheduleEndTime: UInt32 = 0

  public var scheduleDaysEnabled: [BackupProto_NotificationProfile.DayOfWeek] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum DayOfWeek: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Interpret as "Monday"
    case unknown // = 0
    case monday // = 1
    case tuesday // = 2
    case wednesday // = 3
    case thursday // = 4
    case friday // = 5
    case saturday // = 6
    case sunday // = 7
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .monday
      case 2: self = .tuesday
      case 3: self = .wednesday
      case 4: self = .thursday
      case 5: self = .friday
      case 6: self = .saturday
      case 7: self = .sunday
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .monday: return 1
      case .tuesday: return 2
      case .wednesday: return 3
      case .thursday: return 4
      case .friday: return 5
      case .saturday: return 6
      case .sunday: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [BackupProto_NotificationProfile.DayOfWeek] = [
      .unknown,
      .monday,
      .tuesday,
      .wednesday,
      .thursday,
      .friday,
      .saturday,
      .sunday,
    ]

  }

  public init() {}

  fileprivate var _emoji: String? = nil
}

public struct BackupProto_ChatFolder: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var showOnlyUnread: Bool = false

  public var showMutedChats: Bool = false

  /// Folder includes all 1:1 chats, unless excluded
  public var includeAllIndividualChats: Bool = false

  /// Folder includes all group chats, unless excluded
  public var includeAllGroupChats: Bool = false

  public var folderType: BackupProto_ChatFolder.FolderType = .unknown

  /// generated recipient id of groups, contacts, and/or note to self
  public var includedRecipientIds: [UInt64] = []

  /// generated recipient id of groups, contacts, and/or note to self
  public var excludedRecipientIds: [UInt64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Represents the default "All chats" folder record vs all other custom folders
  public enum FolderType: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Interpret as "Custom"
    case unknown // = 0
    case all // = 1
    case custom // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .all
      case 2: self = .custom
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .all: return 1
      case .custom: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [BackupProto_ChatFolder.FolderType] = [
      .unknown,
      .all,
      .custom,
    ]

  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "signal.backup"

extension BackupProto_AvatarColor: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "A100"),
    1: .same(proto: "A110"),
    2: .same(proto: "A120"),
    3: .same(proto: "A130"),
    4: .same(proto: "A140"),
    5: .same(proto: "A150"),
    6: .same(proto: "A160"),
    7: .same(proto: "A170"),
    8: .same(proto: "A180"),
    9: .same(proto: "A190"),
    10: .same(proto: "A200"),
    11: .same(proto: "A210"),
  ]
}

extension BackupProto_GroupV2AccessLevel: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "ANY"),
    2: .same(proto: "MEMBER"),
    3: .same(proto: "ADMINISTRATOR"),
    4: .same(proto: "UNSATISFIABLE"),
  ]
}

extension BackupProto_BackupInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BackupInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "backupTimeMs"),
    3: .same(proto: "mediaRootBackupKey"),
    4: .same(proto: "currentAppVersion"),
    5: .same(proto: "firstAppVersion"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.version) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.backupTimeMs) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.mediaRootBackupKey) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.currentAppVersion) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.firstAppVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != 0 {
      try visitor.visitSingularUInt64Field(value: self.version, fieldNumber: 1)
    }
    if self.backupTimeMs != 0 {
      try visitor.visitSingularUInt64Field(value: self.backupTimeMs, fieldNumber: 2)
    }
    if !self.mediaRootBackupKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.mediaRootBackupKey, fieldNumber: 3)
    }
    if !self.currentAppVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.currentAppVersion, fieldNumber: 4)
    }
    if !self.firstAppVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.firstAppVersion, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_BackupInfo, rhs: BackupProto_BackupInfo) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.backupTimeMs != rhs.backupTimeMs {return false}
    if lhs.mediaRootBackupKey != rhs.mediaRootBackupKey {return false}
    if lhs.currentAppVersion != rhs.currentAppVersion {return false}
    if lhs.firstAppVersion != rhs.firstAppVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_Frame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Frame"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "recipient"),
    3: .same(proto: "chat"),
    4: .same(proto: "chatItem"),
    5: .same(proto: "stickerPack"),
    6: .same(proto: "adHocCall"),
    7: .same(proto: "notificationProfile"),
    8: .same(proto: "chatFolder"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: BackupProto_AccountData?
        var hadOneofValue = false
        if let current = self.item {
          hadOneofValue = true
          if case .account(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.item = .account(v)
        }
      }()
      case 2: try {
        var v: BackupProto_Recipient?
        var hadOneofValue = false
        if let current = self.item {
          hadOneofValue = true
          if case .recipient(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.item = .recipient(v)
        }
      }()
      case 3: try {
        var v: BackupProto_Chat?
        var hadOneofValue = false
        if let current = self.item {
          hadOneofValue = true
          if case .chat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.item = .chat(v)
        }
      }()
      case 4: try {
        var v: BackupProto_ChatItem?
        var hadOneofValue = false
        if let current = self.item {
          hadOneofValue = true
          if case .chatItem(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.item = .chatItem(v)
        }
      }()
      case 5: try {
        var v: BackupProto_StickerPack?
        var hadOneofValue = false
        if let current = self.item {
          hadOneofValue = true
          if case .stickerPack(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.item = .stickerPack(v)
        }
      }()
      case 6: try {
        var v: BackupProto_AdHocCall?
        var hadOneofValue = false
        if let current = self.item {
          hadOneofValue = true
          if case .adHocCall(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.item = .adHocCall(v)
        }
      }()
      case 7: try {
        var v: BackupProto_NotificationProfile?
        var hadOneofValue = false
        if let current = self.item {
          hadOneofValue = true
          if case .notificationProfile(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.item = .notificationProfile(v)
        }
      }()
      case 8: try {
        var v: BackupProto_ChatFolder?
        var hadOneofValue = false
        if let current = self.item {
          hadOneofValue = true
          if case .chatFolder(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.item = .chatFolder(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.item {
    case .account?: try {
      guard case .account(let v)? = self.item else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .recipient?: try {
      guard case .recipient(let v)? = self.item else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .chat?: try {
      guard case .chat(let v)? = self.item else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .chatItem?: try {
      guard case .chatItem(let v)? = self.item else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .stickerPack?: try {
      guard case .stickerPack(let v)? = self.item else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .adHocCall?: try {
      guard case .adHocCall(let v)? = self.item else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .notificationProfile?: try {
      guard case .notificationProfile(let v)? = self.item else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .chatFolder?: try {
      guard case .chatFolder(let v)? = self.item else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_Frame, rhs: BackupProto_Frame) -> Bool {
    if lhs.item != rhs.item {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_AccountData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "profileKey"),
    2: .same(proto: "username"),
    3: .same(proto: "usernameLink"),
    4: .same(proto: "givenName"),
    5: .same(proto: "familyName"),
    6: .same(proto: "avatarUrlPath"),
    7: .same(proto: "donationSubscriberData"),
    9: .same(proto: "accountSettings"),
    10: .same(proto: "backupsSubscriberData"),
    11: .same(proto: "svrPin"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.profileKey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._username) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._usernameLink) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.givenName) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.familyName) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.avatarURLPath) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._donationSubscriberData) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._accountSettings) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._backupsSubscriberData) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.svrPin) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.profileKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.profileKey, fieldNumber: 1)
    }
    try { if let v = self._username {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._usernameLink {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.givenName.isEmpty {
      try visitor.visitSingularStringField(value: self.givenName, fieldNumber: 4)
    }
    if !self.familyName.isEmpty {
      try visitor.visitSingularStringField(value: self.familyName, fieldNumber: 5)
    }
    if !self.avatarURLPath.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURLPath, fieldNumber: 6)
    }
    try { if let v = self._donationSubscriberData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._accountSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._backupsSubscriberData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    if !self.svrPin.isEmpty {
      try visitor.visitSingularStringField(value: self.svrPin, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_AccountData, rhs: BackupProto_AccountData) -> Bool {
    if lhs.profileKey != rhs.profileKey {return false}
    if lhs._username != rhs._username {return false}
    if lhs._usernameLink != rhs._usernameLink {return false}
    if lhs.givenName != rhs.givenName {return false}
    if lhs.familyName != rhs.familyName {return false}
    if lhs.avatarURLPath != rhs.avatarURLPath {return false}
    if lhs._donationSubscriberData != rhs._donationSubscriberData {return false}
    if lhs._accountSettings != rhs._accountSettings {return false}
    if lhs._backupsSubscriberData != rhs._backupsSubscriberData {return false}
    if lhs.svrPin != rhs.svrPin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_AccountData.PhoneNumberSharingMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "EVERYBODY"),
    2: .same(proto: "NOBODY"),
  ]
}

extension BackupProto_AccountData.UsernameLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_AccountData.protoMessageName + ".UsernameLink"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entropy"),
    2: .same(proto: "serverId"),
    3: .same(proto: "color"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.entropy) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.serverID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.color) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entropy.isEmpty {
      try visitor.visitSingularBytesField(value: self.entropy, fieldNumber: 1)
    }
    if !self.serverID.isEmpty {
      try visitor.visitSingularBytesField(value: self.serverID, fieldNumber: 2)
    }
    if self.color != .unknown {
      try visitor.visitSingularEnumField(value: self.color, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_AccountData.UsernameLink, rhs: BackupProto_AccountData.UsernameLink) -> Bool {
    if lhs.entropy != rhs.entropy {return false}
    if lhs.serverID != rhs.serverID {return false}
    if lhs.color != rhs.color {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_AccountData.UsernameLink.Color: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "BLUE"),
    2: .same(proto: "WHITE"),
    3: .same(proto: "GREY"),
    4: .same(proto: "OLIVE"),
    5: .same(proto: "GREEN"),
    6: .same(proto: "ORANGE"),
    7: .same(proto: "PINK"),
    8: .same(proto: "PURPLE"),
  ]
}

extension BackupProto_AccountData.AccountSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_AccountData.protoMessageName + ".AccountSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "readReceipts"),
    2: .same(proto: "sealedSenderIndicators"),
    3: .same(proto: "typingIndicators"),
    4: .same(proto: "linkPreviews"),
    5: .same(proto: "notDiscoverableByPhoneNumber"),
    6: .same(proto: "preferContactAvatars"),
    7: .same(proto: "universalExpireTimerSeconds"),
    8: .same(proto: "preferredReactionEmoji"),
    9: .same(proto: "displayBadgesOnProfile"),
    10: .same(proto: "keepMutedChatsArchived"),
    11: .same(proto: "hasSetMyStoriesPrivacy"),
    12: .same(proto: "hasViewedOnboardingStory"),
    13: .same(proto: "storiesDisabled"),
    14: .same(proto: "storyViewReceiptsEnabled"),
    15: .same(proto: "hasSeenGroupStoryEducationSheet"),
    16: .same(proto: "hasCompletedUsernameOnboarding"),
    17: .same(proto: "phoneNumberSharingMode"),
    18: .same(proto: "defaultChatStyle"),
    19: .same(proto: "customChatColors"),
  ]

  fileprivate class _StorageClass {
    var _readReceipts: Bool = false
    var _sealedSenderIndicators: Bool = false
    var _typingIndicators: Bool = false
    var _linkPreviews: Bool = false
    var _notDiscoverableByPhoneNumber: Bool = false
    var _preferContactAvatars: Bool = false
    var _universalExpireTimerSeconds: UInt32 = 0
    var _preferredReactionEmoji: [String] = []
    var _displayBadgesOnProfile: Bool = false
    var _keepMutedChatsArchived: Bool = false
    var _hasSetMyStoriesPrivacy_p: Bool = false
    var _hasViewedOnboardingStory_p: Bool = false
    var _storiesDisabled: Bool = false
    var _storyViewReceiptsEnabled: Bool? = nil
    var _hasSeenGroupStoryEducationSheet_p: Bool = false
    var _hasCompletedUsernameOnboarding_p: Bool = false
    var _phoneNumberSharingMode: BackupProto_AccountData.PhoneNumberSharingMode = .unknown
    var _defaultChatStyle: BackupProto_ChatStyle? = nil
    var _customChatColors: [BackupProto_ChatStyle.CustomChatColor] = []

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _readReceipts = source._readReceipts
      _sealedSenderIndicators = source._sealedSenderIndicators
      _typingIndicators = source._typingIndicators
      _linkPreviews = source._linkPreviews
      _notDiscoverableByPhoneNumber = source._notDiscoverableByPhoneNumber
      _preferContactAvatars = source._preferContactAvatars
      _universalExpireTimerSeconds = source._universalExpireTimerSeconds
      _preferredReactionEmoji = source._preferredReactionEmoji
      _displayBadgesOnProfile = source._displayBadgesOnProfile
      _keepMutedChatsArchived = source._keepMutedChatsArchived
      _hasSetMyStoriesPrivacy_p = source._hasSetMyStoriesPrivacy_p
      _hasViewedOnboardingStory_p = source._hasViewedOnboardingStory_p
      _storiesDisabled = source._storiesDisabled
      _storyViewReceiptsEnabled = source._storyViewReceiptsEnabled
      _hasSeenGroupStoryEducationSheet_p = source._hasSeenGroupStoryEducationSheet_p
      _hasCompletedUsernameOnboarding_p = source._hasCompletedUsernameOnboarding_p
      _phoneNumberSharingMode = source._phoneNumberSharingMode
      _defaultChatStyle = source._defaultChatStyle
      _customChatColors = source._customChatColors
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._readReceipts) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._sealedSenderIndicators) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._typingIndicators) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._linkPreviews) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._notDiscoverableByPhoneNumber) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._preferContactAvatars) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._universalExpireTimerSeconds) }()
        case 8: try { try decoder.decodeRepeatedStringField(value: &_storage._preferredReactionEmoji) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._displayBadgesOnProfile) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._keepMutedChatsArchived) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._hasSetMyStoriesPrivacy_p) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._hasViewedOnboardingStory_p) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._storiesDisabled) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._storyViewReceiptsEnabled) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._hasSeenGroupStoryEducationSheet_p) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._hasCompletedUsernameOnboarding_p) }()
        case 17: try { try decoder.decodeSingularEnumField(value: &_storage._phoneNumberSharingMode) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._defaultChatStyle) }()
        case 19: try { try decoder.decodeRepeatedMessageField(value: &_storage._customChatColors) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._readReceipts != false {
        try visitor.visitSingularBoolField(value: _storage._readReceipts, fieldNumber: 1)
      }
      if _storage._sealedSenderIndicators != false {
        try visitor.visitSingularBoolField(value: _storage._sealedSenderIndicators, fieldNumber: 2)
      }
      if _storage._typingIndicators != false {
        try visitor.visitSingularBoolField(value: _storage._typingIndicators, fieldNumber: 3)
      }
      if _storage._linkPreviews != false {
        try visitor.visitSingularBoolField(value: _storage._linkPreviews, fieldNumber: 4)
      }
      if _storage._notDiscoverableByPhoneNumber != false {
        try visitor.visitSingularBoolField(value: _storage._notDiscoverableByPhoneNumber, fieldNumber: 5)
      }
      if _storage._preferContactAvatars != false {
        try visitor.visitSingularBoolField(value: _storage._preferContactAvatars, fieldNumber: 6)
      }
      if _storage._universalExpireTimerSeconds != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._universalExpireTimerSeconds, fieldNumber: 7)
      }
      if !_storage._preferredReactionEmoji.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._preferredReactionEmoji, fieldNumber: 8)
      }
      if _storage._displayBadgesOnProfile != false {
        try visitor.visitSingularBoolField(value: _storage._displayBadgesOnProfile, fieldNumber: 9)
      }
      if _storage._keepMutedChatsArchived != false {
        try visitor.visitSingularBoolField(value: _storage._keepMutedChatsArchived, fieldNumber: 10)
      }
      if _storage._hasSetMyStoriesPrivacy_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasSetMyStoriesPrivacy_p, fieldNumber: 11)
      }
      if _storage._hasViewedOnboardingStory_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasViewedOnboardingStory_p, fieldNumber: 12)
      }
      if _storage._storiesDisabled != false {
        try visitor.visitSingularBoolField(value: _storage._storiesDisabled, fieldNumber: 13)
      }
      try { if let v = _storage._storyViewReceiptsEnabled {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
      } }()
      if _storage._hasSeenGroupStoryEducationSheet_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasSeenGroupStoryEducationSheet_p, fieldNumber: 15)
      }
      if _storage._hasCompletedUsernameOnboarding_p != false {
        try visitor.visitSingularBoolField(value: _storage._hasCompletedUsernameOnboarding_p, fieldNumber: 16)
      }
      if _storage._phoneNumberSharingMode != .unknown {
        try visitor.visitSingularEnumField(value: _storage._phoneNumberSharingMode, fieldNumber: 17)
      }
      try { if let v = _storage._defaultChatStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      if !_storage._customChatColors.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._customChatColors, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_AccountData.AccountSettings, rhs: BackupProto_AccountData.AccountSettings) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._readReceipts != rhs_storage._readReceipts {return false}
        if _storage._sealedSenderIndicators != rhs_storage._sealedSenderIndicators {return false}
        if _storage._typingIndicators != rhs_storage._typingIndicators {return false}
        if _storage._linkPreviews != rhs_storage._linkPreviews {return false}
        if _storage._notDiscoverableByPhoneNumber != rhs_storage._notDiscoverableByPhoneNumber {return false}
        if _storage._preferContactAvatars != rhs_storage._preferContactAvatars {return false}
        if _storage._universalExpireTimerSeconds != rhs_storage._universalExpireTimerSeconds {return false}
        if _storage._preferredReactionEmoji != rhs_storage._preferredReactionEmoji {return false}
        if _storage._displayBadgesOnProfile != rhs_storage._displayBadgesOnProfile {return false}
        if _storage._keepMutedChatsArchived != rhs_storage._keepMutedChatsArchived {return false}
        if _storage._hasSetMyStoriesPrivacy_p != rhs_storage._hasSetMyStoriesPrivacy_p {return false}
        if _storage._hasViewedOnboardingStory_p != rhs_storage._hasViewedOnboardingStory_p {return false}
        if _storage._storiesDisabled != rhs_storage._storiesDisabled {return false}
        if _storage._storyViewReceiptsEnabled != rhs_storage._storyViewReceiptsEnabled {return false}
        if _storage._hasSeenGroupStoryEducationSheet_p != rhs_storage._hasSeenGroupStoryEducationSheet_p {return false}
        if _storage._hasCompletedUsernameOnboarding_p != rhs_storage._hasCompletedUsernameOnboarding_p {return false}
        if _storage._phoneNumberSharingMode != rhs_storage._phoneNumberSharingMode {return false}
        if _storage._defaultChatStyle != rhs_storage._defaultChatStyle {return false}
        if _storage._customChatColors != rhs_storage._customChatColors {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_AccountData.SubscriberData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_AccountData.protoMessageName + ".SubscriberData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscriberId"),
    2: .same(proto: "currencyCode"),
    3: .same(proto: "manuallyCancelled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.subscriberID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.currencyCode) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.manuallyCancelled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscriberID.isEmpty {
      try visitor.visitSingularBytesField(value: self.subscriberID, fieldNumber: 1)
    }
    if !self.currencyCode.isEmpty {
      try visitor.visitSingularStringField(value: self.currencyCode, fieldNumber: 2)
    }
    if self.manuallyCancelled != false {
      try visitor.visitSingularBoolField(value: self.manuallyCancelled, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_AccountData.SubscriberData, rhs: BackupProto_AccountData.SubscriberData) -> Bool {
    if lhs.subscriberID != rhs.subscriberID {return false}
    if lhs.currencyCode != rhs.currencyCode {return false}
    if lhs.manuallyCancelled != rhs.manuallyCancelled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_AccountData.IAPSubscriberData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_AccountData.protoMessageName + ".IAPSubscriberData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscriberId"),
    2: .same(proto: "purchaseToken"),
    3: .same(proto: "originalTransactionId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.subscriberID) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.iapSubscriptionID != nil {try decoder.handleConflictingOneOf()}
          self.iapSubscriptionID = .purchaseToken(v)
        }
      }()
      case 3: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.iapSubscriptionID != nil {try decoder.handleConflictingOneOf()}
          self.iapSubscriptionID = .originalTransactionID(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.subscriberID.isEmpty {
      try visitor.visitSingularBytesField(value: self.subscriberID, fieldNumber: 1)
    }
    switch self.iapSubscriptionID {
    case .purchaseToken?: try {
      guard case .purchaseToken(let v)? = self.iapSubscriptionID else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .originalTransactionID?: try {
      guard case .originalTransactionID(let v)? = self.iapSubscriptionID else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_AccountData.IAPSubscriberData, rhs: BackupProto_AccountData.IAPSubscriberData) -> Bool {
    if lhs.subscriberID != rhs.subscriberID {return false}
    if lhs.iapSubscriptionID != rhs.iapSubscriptionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_Recipient: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Recipient"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "contact"),
    3: .same(proto: "group"),
    4: .same(proto: "distributionList"),
    5: .same(proto: "self"),
    6: .same(proto: "releaseNotes"),
    7: .same(proto: "callLink"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try {
        var v: BackupProto_Contact?
        var hadOneofValue = false
        if let current = self.destination {
          hadOneofValue = true
          if case .contact(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.destination = .contact(v)
        }
      }()
      case 3: try {
        var v: BackupProto_Group?
        var hadOneofValue = false
        if let current = self.destination {
          hadOneofValue = true
          if case .group(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.destination = .group(v)
        }
      }()
      case 4: try {
        var v: BackupProto_DistributionListItem?
        var hadOneofValue = false
        if let current = self.destination {
          hadOneofValue = true
          if case .distributionList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.destination = .distributionList(v)
        }
      }()
      case 5: try {
        var v: BackupProto_Self?
        var hadOneofValue = false
        if let current = self.destination {
          hadOneofValue = true
          if case .self_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.destination = .self_p(v)
        }
      }()
      case 6: try {
        var v: BackupProto_ReleaseNotes?
        var hadOneofValue = false
        if let current = self.destination {
          hadOneofValue = true
          if case .releaseNotes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.destination = .releaseNotes(v)
        }
      }()
      case 7: try {
        var v: BackupProto_CallLink?
        var hadOneofValue = false
        if let current = self.destination {
          hadOneofValue = true
          if case .callLink(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.destination = .callLink(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    switch self.destination {
    case .contact?: try {
      guard case .contact(let v)? = self.destination else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .group?: try {
      guard case .group(let v)? = self.destination else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .distributionList?: try {
      guard case .distributionList(let v)? = self.destination else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .self_p?: try {
      guard case .self_p(let v)? = self.destination else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .releaseNotes?: try {
      guard case .releaseNotes(let v)? = self.destination else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .callLink?: try {
      guard case .callLink(let v)? = self.destination else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_Recipient, rhs: BackupProto_Recipient) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.destination != rhs.destination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_Contact: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Contact"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "aci"),
    2: .same(proto: "pni"),
    3: .same(proto: "username"),
    4: .same(proto: "e164"),
    5: .same(proto: "blocked"),
    6: .same(proto: "visibility"),
    7: .same(proto: "registered"),
    8: .same(proto: "notRegistered"),
    9: .same(proto: "profileKey"),
    10: .same(proto: "profileSharing"),
    11: .same(proto: "profileGivenName"),
    12: .same(proto: "profileFamilyName"),
    13: .same(proto: "hideStory"),
    14: .same(proto: "identityKey"),
    15: .same(proto: "identityState"),
    16: .same(proto: "nickname"),
    17: .same(proto: "note"),
    18: .same(proto: "systemGivenName"),
    19: .same(proto: "systemFamilyName"),
    20: .same(proto: "systemNickname"),
    21: .same(proto: "avatarColor"),
  ]

  fileprivate class _StorageClass {
    var _aci: Data? = nil
    var _pni: Data? = nil
    var _username: String? = nil
    var _e164: UInt64? = nil
    var _blocked: Bool = false
    var _visibility: BackupProto_Contact.Visibility = .visible
    var _registration: BackupProto_Contact.OneOf_Registration?
    var _profileKey: Data? = nil
    var _profileSharing: Bool = false
    var _profileGivenName: String? = nil
    var _profileFamilyName: String? = nil
    var _hideStory: Bool = false
    var _identityKey: Data? = nil
    var _identityState: BackupProto_Contact.IdentityState = .default
    var _nickname: BackupProto_Contact.Name? = nil
    var _note: String = String()
    var _systemGivenName: String = String()
    var _systemFamilyName: String = String()
    var _systemNickname: String = String()
    var _avatarColor: BackupProto_AvatarColor? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _aci = source._aci
      _pni = source._pni
      _username = source._username
      _e164 = source._e164
      _blocked = source._blocked
      _visibility = source._visibility
      _registration = source._registration
      _profileKey = source._profileKey
      _profileSharing = source._profileSharing
      _profileGivenName = source._profileGivenName
      _profileFamilyName = source._profileFamilyName
      _hideStory = source._hideStory
      _identityKey = source._identityKey
      _identityState = source._identityState
      _nickname = source._nickname
      _note = source._note
      _systemGivenName = source._systemGivenName
      _systemFamilyName = source._systemFamilyName
      _systemNickname = source._systemNickname
      _avatarColor = source._avatarColor
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._aci) }()
        case 2: try { try decoder.decodeSingularBytesField(value: &_storage._pni) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._username) }()
        case 4: try { try decoder.decodeSingularUInt64Field(value: &_storage._e164) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._blocked) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._visibility) }()
        case 7: try {
          var v: BackupProto_Contact.Registered?
          var hadOneofValue = false
          if let current = _storage._registration {
            hadOneofValue = true
            if case .registered(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._registration = .registered(v)
          }
        }()
        case 8: try {
          var v: BackupProto_Contact.NotRegistered?
          var hadOneofValue = false
          if let current = _storage._registration {
            hadOneofValue = true
            if case .notRegistered(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._registration = .notRegistered(v)
          }
        }()
        case 9: try { try decoder.decodeSingularBytesField(value: &_storage._profileKey) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._profileSharing) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._profileGivenName) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._profileFamilyName) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._hideStory) }()
        case 14: try { try decoder.decodeSingularBytesField(value: &_storage._identityKey) }()
        case 15: try { try decoder.decodeSingularEnumField(value: &_storage._identityState) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._nickname) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._note) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._systemGivenName) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._systemFamilyName) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._systemNickname) }()
        case 21: try { try decoder.decodeSingularEnumField(value: &_storage._avatarColor) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._aci {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._pni {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._username {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._e164 {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
      } }()
      if _storage._blocked != false {
        try visitor.visitSingularBoolField(value: _storage._blocked, fieldNumber: 5)
      }
      if _storage._visibility != .visible {
        try visitor.visitSingularEnumField(value: _storage._visibility, fieldNumber: 6)
      }
      switch _storage._registration {
      case .registered?: try {
        guard case .registered(let v)? = _storage._registration else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .notRegistered?: try {
        guard case .notRegistered(let v)? = _storage._registration else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case nil: break
      }
      try { if let v = _storage._profileKey {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 9)
      } }()
      if _storage._profileSharing != false {
        try visitor.visitSingularBoolField(value: _storage._profileSharing, fieldNumber: 10)
      }
      try { if let v = _storage._profileGivenName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._profileFamilyName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 12)
      } }()
      if _storage._hideStory != false {
        try visitor.visitSingularBoolField(value: _storage._hideStory, fieldNumber: 13)
      }
      try { if let v = _storage._identityKey {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 14)
      } }()
      if _storage._identityState != .default {
        try visitor.visitSingularEnumField(value: _storage._identityState, fieldNumber: 15)
      }
      try { if let v = _storage._nickname {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      if !_storage._note.isEmpty {
        try visitor.visitSingularStringField(value: _storage._note, fieldNumber: 17)
      }
      if !_storage._systemGivenName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._systemGivenName, fieldNumber: 18)
      }
      if !_storage._systemFamilyName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._systemFamilyName, fieldNumber: 19)
      }
      if !_storage._systemNickname.isEmpty {
        try visitor.visitSingularStringField(value: _storage._systemNickname, fieldNumber: 20)
      }
      try { if let v = _storage._avatarColor {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 21)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_Contact, rhs: BackupProto_Contact) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._aci != rhs_storage._aci {return false}
        if _storage._pni != rhs_storage._pni {return false}
        if _storage._username != rhs_storage._username {return false}
        if _storage._e164 != rhs_storage._e164 {return false}
        if _storage._blocked != rhs_storage._blocked {return false}
        if _storage._visibility != rhs_storage._visibility {return false}
        if _storage._registration != rhs_storage._registration {return false}
        if _storage._profileKey != rhs_storage._profileKey {return false}
        if _storage._profileSharing != rhs_storage._profileSharing {return false}
        if _storage._profileGivenName != rhs_storage._profileGivenName {return false}
        if _storage._profileFamilyName != rhs_storage._profileFamilyName {return false}
        if _storage._hideStory != rhs_storage._hideStory {return false}
        if _storage._identityKey != rhs_storage._identityKey {return false}
        if _storage._identityState != rhs_storage._identityState {return false}
        if _storage._nickname != rhs_storage._nickname {return false}
        if _storage._note != rhs_storage._note {return false}
        if _storage._systemGivenName != rhs_storage._systemGivenName {return false}
        if _storage._systemFamilyName != rhs_storage._systemFamilyName {return false}
        if _storage._systemNickname != rhs_storage._systemNickname {return false}
        if _storage._avatarColor != rhs_storage._avatarColor {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_Contact.IdentityState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "VERIFIED"),
    2: .same(proto: "UNVERIFIED"),
  ]
}

extension BackupProto_Contact.Visibility: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VISIBLE"),
    1: .same(proto: "HIDDEN"),
    2: .same(proto: "HIDDEN_MESSAGE_REQUEST"),
  ]
}

extension BackupProto_Contact.Registered: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_Contact.protoMessageName + ".Registered"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_Contact.Registered, rhs: BackupProto_Contact.Registered) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_Contact.NotRegistered: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_Contact.protoMessageName + ".NotRegistered"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "unregisteredTimestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.unregisteredTimestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.unregisteredTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.unregisteredTimestamp, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_Contact.NotRegistered, rhs: BackupProto_Contact.NotRegistered) -> Bool {
    if lhs.unregisteredTimestamp != rhs.unregisteredTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_Contact.Name: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_Contact.protoMessageName + ".Name"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "given"),
    2: .same(proto: "family"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.given) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.family) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.given.isEmpty {
      try visitor.visitSingularStringField(value: self.given, fieldNumber: 1)
    }
    if !self.family.isEmpty {
      try visitor.visitSingularStringField(value: self.family, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_Contact.Name, rhs: BackupProto_Contact.Name) -> Bool {
    if lhs.given != rhs.given {return false}
    if lhs.family != rhs.family {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_Group: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Group"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "masterKey"),
    2: .same(proto: "whitelisted"),
    3: .same(proto: "hideStory"),
    4: .same(proto: "storySendMode"),
    5: .same(proto: "snapshot"),
    6: .same(proto: "blocked"),
    7: .same(proto: "avatarColor"),
  ]

  fileprivate class _StorageClass {
    var _masterKey: Data = Data()
    var _whitelisted: Bool = false
    var _hideStory: Bool = false
    var _storySendMode: BackupProto_Group.StorySendMode = .default
    var _snapshot: BackupProto_Group.GroupSnapshot? = nil
    var _blocked: Bool = false
    var _avatarColor: BackupProto_AvatarColor? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _masterKey = source._masterKey
      _whitelisted = source._whitelisted
      _hideStory = source._hideStory
      _storySendMode = source._storySendMode
      _snapshot = source._snapshot
      _blocked = source._blocked
      _avatarColor = source._avatarColor
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._masterKey) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._whitelisted) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._hideStory) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._storySendMode) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._snapshot) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._blocked) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._avatarColor) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._masterKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._masterKey, fieldNumber: 1)
      }
      if _storage._whitelisted != false {
        try visitor.visitSingularBoolField(value: _storage._whitelisted, fieldNumber: 2)
      }
      if _storage._hideStory != false {
        try visitor.visitSingularBoolField(value: _storage._hideStory, fieldNumber: 3)
      }
      if _storage._storySendMode != .default {
        try visitor.visitSingularEnumField(value: _storage._storySendMode, fieldNumber: 4)
      }
      try { if let v = _storage._snapshot {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._blocked != false {
        try visitor.visitSingularBoolField(value: _storage._blocked, fieldNumber: 6)
      }
      try { if let v = _storage._avatarColor {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_Group, rhs: BackupProto_Group) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._masterKey != rhs_storage._masterKey {return false}
        if _storage._whitelisted != rhs_storage._whitelisted {return false}
        if _storage._hideStory != rhs_storage._hideStory {return false}
        if _storage._storySendMode != rhs_storage._storySendMode {return false}
        if _storage._snapshot != rhs_storage._snapshot {return false}
        if _storage._blocked != rhs_storage._blocked {return false}
        if _storage._avatarColor != rhs_storage._avatarColor {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_Group.StorySendMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "DISABLED"),
    2: .same(proto: "ENABLED"),
  ]
}

extension BackupProto_Group.GroupSnapshot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_Group.protoMessageName + ".GroupSnapshot"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "title"),
    11: .same(proto: "description"),
    3: .same(proto: "avatarUrl"),
    4: .same(proto: "disappearingMessagesTimer"),
    5: .same(proto: "accessControl"),
    6: .same(proto: "version"),
    7: .same(proto: "members"),
    8: .same(proto: "membersPendingProfileKey"),
    9: .same(proto: "membersPendingAdminApproval"),
    10: .same(proto: "inviteLinkPassword"),
    12: .standard(proto: "announcements_only"),
    13: .standard(proto: "members_banned"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.avatarURL) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._disappearingMessagesTimer) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._accessControl) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.version) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.membersPendingProfileKey) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.membersPendingAdminApproval) }()
      case 10: try { try decoder.decodeSingularBytesField(value: &self.inviteLinkPassword) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._description_p) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.announcementsOnly) }()
      case 13: try { try decoder.decodeRepeatedMessageField(value: &self.membersBanned) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._title {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.avatarURL.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarURL, fieldNumber: 3)
    }
    try { if let v = self._disappearingMessagesTimer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._accessControl {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 6)
    }
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 7)
    }
    if !self.membersPendingProfileKey.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.membersPendingProfileKey, fieldNumber: 8)
    }
    if !self.membersPendingAdminApproval.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.membersPendingAdminApproval, fieldNumber: 9)
    }
    if !self.inviteLinkPassword.isEmpty {
      try visitor.visitSingularBytesField(value: self.inviteLinkPassword, fieldNumber: 10)
    }
    try { if let v = self._description_p {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    if self.announcementsOnly != false {
      try visitor.visitSingularBoolField(value: self.announcementsOnly, fieldNumber: 12)
    }
    if !self.membersBanned.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.membersBanned, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_Group.GroupSnapshot, rhs: BackupProto_Group.GroupSnapshot) -> Bool {
    if lhs._title != rhs._title {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs.avatarURL != rhs.avatarURL {return false}
    if lhs._disappearingMessagesTimer != rhs._disappearingMessagesTimer {return false}
    if lhs._accessControl != rhs._accessControl {return false}
    if lhs.version != rhs.version {return false}
    if lhs.members != rhs.members {return false}
    if lhs.membersPendingProfileKey != rhs.membersPendingProfileKey {return false}
    if lhs.membersPendingAdminApproval != rhs.membersPendingAdminApproval {return false}
    if lhs.inviteLinkPassword != rhs.inviteLinkPassword {return false}
    if lhs.announcementsOnly != rhs.announcementsOnly {return false}
    if lhs.membersBanned != rhs.membersBanned {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_Group.GroupAttributeBlob: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_Group.protoMessageName + ".GroupAttributeBlob"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "avatar"),
    3: .same(proto: "disappearingMessagesDuration"),
    4: .same(proto: "descriptionText"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.content != nil {try decoder.handleConflictingOneOf()}
          self.content = .title(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.content != nil {try decoder.handleConflictingOneOf()}
          self.content = .avatar(v)
        }
      }()
      case 3: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.content != nil {try decoder.handleConflictingOneOf()}
          self.content = .disappearingMessagesDuration(v)
        }
      }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.content != nil {try decoder.handleConflictingOneOf()}
          self.content = .descriptionText(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.content {
    case .title?: try {
      guard case .title(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .avatar?: try {
      guard case .avatar(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .disappearingMessagesDuration?: try {
      guard case .disappearingMessagesDuration(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }()
    case .descriptionText?: try {
      guard case .descriptionText(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_Group.GroupAttributeBlob, rhs: BackupProto_Group.GroupAttributeBlob) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_Group.Member: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_Group.protoMessageName + ".Member"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "role"),
    5: .same(proto: "joinedAtVersion"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.role) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.joinedAtVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularBytesField(value: self.userID, fieldNumber: 1)
    }
    if self.role != .unknown {
      try visitor.visitSingularEnumField(value: self.role, fieldNumber: 2)
    }
    if self.joinedAtVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.joinedAtVersion, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_Group.Member, rhs: BackupProto_Group.Member) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.role != rhs.role {return false}
    if lhs.joinedAtVersion != rhs.joinedAtVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_Group.Member.Role: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "DEFAULT"),
    2: .same(proto: "ADMINISTRATOR"),
  ]
}

extension BackupProto_Group.MemberPendingProfileKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_Group.protoMessageName + ".MemberPendingProfileKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "member"),
    2: .same(proto: "addedByUserId"),
    3: .same(proto: "timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._member) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.addedByUserID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._member {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.addedByUserID.isEmpty {
      try visitor.visitSingularBytesField(value: self.addedByUserID, fieldNumber: 2)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestamp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_Group.MemberPendingProfileKey, rhs: BackupProto_Group.MemberPendingProfileKey) -> Bool {
    if lhs._member != rhs._member {return false}
    if lhs.addedByUserID != rhs.addedByUserID {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_Group.MemberPendingAdminApproval: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_Group.protoMessageName + ".MemberPendingAdminApproval"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    4: .same(proto: "timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularBytesField(value: self.userID, fieldNumber: 1)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestamp, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_Group.MemberPendingAdminApproval, rhs: BackupProto_Group.MemberPendingAdminApproval) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_Group.MemberBanned: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_Group.protoMessageName + ".MemberBanned"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userId"),
    2: .same(proto: "timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularBytesField(value: self.userID, fieldNumber: 1)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestamp, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_Group.MemberBanned, rhs: BackupProto_Group.MemberBanned) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_Group.AccessControl: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_Group.protoMessageName + ".AccessControl"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "attributes"),
    2: .same(proto: "members"),
    3: .same(proto: "addFromInviteLink"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.attributes) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.members) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.addFromInviteLink) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.attributes != .unknown {
      try visitor.visitSingularEnumField(value: self.attributes, fieldNumber: 1)
    }
    if self.members != .unknown {
      try visitor.visitSingularEnumField(value: self.members, fieldNumber: 2)
    }
    if self.addFromInviteLink != .unknown {
      try visitor.visitSingularEnumField(value: self.addFromInviteLink, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_Group.AccessControl, rhs: BackupProto_Group.AccessControl) -> Bool {
    if lhs.attributes != rhs.attributes {return false}
    if lhs.members != rhs.members {return false}
    if lhs.addFromInviteLink != rhs.addFromInviteLink {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_Group.AccessControl.AccessRequired: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "ANY"),
    2: .same(proto: "MEMBER"),
    3: .same(proto: "ADMINISTRATOR"),
    4: .same(proto: "UNSATISFIABLE"),
  ]
}

extension BackupProto_Self: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Self"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "avatarColor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._avatarColor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._avatarColor {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_Self, rhs: BackupProto_Self) -> Bool {
    if lhs._avatarColor != rhs._avatarColor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_ReleaseNotes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReleaseNotes"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_ReleaseNotes, rhs: BackupProto_ReleaseNotes) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_Chat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Chat"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "recipientId"),
    3: .same(proto: "archived"),
    4: .same(proto: "pinnedOrder"),
    5: .same(proto: "expirationTimerMs"),
    6: .same(proto: "muteUntilMs"),
    7: .same(proto: "markedUnread"),
    8: .same(proto: "dontNotifyForMentionsIfMuted"),
    9: .same(proto: "style"),
    10: .same(proto: "expireTimerVersion"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.recipientID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.archived) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._pinnedOrder) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self._expirationTimerMs) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self._muteUntilMs) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.markedUnread) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.dontNotifyForMentionsIfMuted) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._style) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self.expireTimerVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if self.recipientID != 0 {
      try visitor.visitSingularUInt64Field(value: self.recipientID, fieldNumber: 2)
    }
    if self.archived != false {
      try visitor.visitSingularBoolField(value: self.archived, fieldNumber: 3)
    }
    try { if let v = self._pinnedOrder {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._expirationTimerMs {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._muteUntilMs {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    } }()
    if self.markedUnread != false {
      try visitor.visitSingularBoolField(value: self.markedUnread, fieldNumber: 7)
    }
    if self.dontNotifyForMentionsIfMuted != false {
      try visitor.visitSingularBoolField(value: self.dontNotifyForMentionsIfMuted, fieldNumber: 8)
    }
    try { if let v = self._style {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    if self.expireTimerVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.expireTimerVersion, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_Chat, rhs: BackupProto_Chat) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.recipientID != rhs.recipientID {return false}
    if lhs.archived != rhs.archived {return false}
    if lhs._pinnedOrder != rhs._pinnedOrder {return false}
    if lhs._expirationTimerMs != rhs._expirationTimerMs {return false}
    if lhs._muteUntilMs != rhs._muteUntilMs {return false}
    if lhs.markedUnread != rhs.markedUnread {return false}
    if lhs.dontNotifyForMentionsIfMuted != rhs.dontNotifyForMentionsIfMuted {return false}
    if lhs._style != rhs._style {return false}
    if lhs.expireTimerVersion != rhs.expireTimerVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_CallLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CallLink"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rootKey"),
    2: .same(proto: "adminKey"),
    3: .same(proto: "name"),
    4: .same(proto: "restrictions"),
    5: .same(proto: "expirationMs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.rootKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._adminKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.restrictions) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.expirationMs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.rootKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.rootKey, fieldNumber: 1)
    }
    try { if let v = self._adminKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if self.restrictions != .unknown {
      try visitor.visitSingularEnumField(value: self.restrictions, fieldNumber: 4)
    }
    if self.expirationMs != 0 {
      try visitor.visitSingularUInt64Field(value: self.expirationMs, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_CallLink, rhs: BackupProto_CallLink) -> Bool {
    if lhs.rootKey != rhs.rootKey {return false}
    if lhs._adminKey != rhs._adminKey {return false}
    if lhs.name != rhs.name {return false}
    if lhs.restrictions != rhs.restrictions {return false}
    if lhs.expirationMs != rhs.expirationMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_CallLink.Restrictions: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "NONE"),
    2: .same(proto: "ADMIN_APPROVAL"),
  ]
}

extension BackupProto_AdHocCall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdHocCall"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "callId"),
    2: .same(proto: "recipientId"),
    3: .same(proto: "state"),
    4: .same(proto: "callTimestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.callID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.recipientID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.callTimestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.callID != 0 {
      try visitor.visitSingularUInt64Field(value: self.callID, fieldNumber: 1)
    }
    if self.recipientID != 0 {
      try visitor.visitSingularUInt64Field(value: self.recipientID, fieldNumber: 2)
    }
    if self.state != .unknownState {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 3)
    }
    if self.callTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.callTimestamp, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_AdHocCall, rhs: BackupProto_AdHocCall) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs.recipientID != rhs.recipientID {return false}
    if lhs.state != rhs.state {return false}
    if lhs.callTimestamp != rhs.callTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_AdHocCall.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_STATE"),
    1: .same(proto: "GENERIC"),
  ]
}

extension BackupProto_DistributionListItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DistributionListItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "distributionId"),
    2: .same(proto: "deletionTimestamp"),
    3: .same(proto: "distributionList"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.distributionID) }()
      case 2: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.item != nil {try decoder.handleConflictingOneOf()}
          self.item = .deletionTimestamp(v)
        }
      }()
      case 3: try {
        var v: BackupProto_DistributionList?
        var hadOneofValue = false
        if let current = self.item {
          hadOneofValue = true
          if case .distributionList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.item = .distributionList(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.distributionID.isEmpty {
      try visitor.visitSingularBytesField(value: self.distributionID, fieldNumber: 1)
    }
    switch self.item {
    case .deletionTimestamp?: try {
      guard case .deletionTimestamp(let v)? = self.item else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }()
    case .distributionList?: try {
      guard case .distributionList(let v)? = self.item else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_DistributionListItem, rhs: BackupProto_DistributionListItem) -> Bool {
    if lhs.distributionID != rhs.distributionID {return false}
    if lhs.item != rhs.item {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_DistributionList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DistributionList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "allowReplies"),
    3: .same(proto: "privacyMode"),
    4: .same(proto: "memberRecipientIds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.allowReplies) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.privacyMode) }()
      case 4: try { try decoder.decodeRepeatedUInt64Field(value: &self.memberRecipientIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.allowReplies != false {
      try visitor.visitSingularBoolField(value: self.allowReplies, fieldNumber: 2)
    }
    if self.privacyMode != .unknown {
      try visitor.visitSingularEnumField(value: self.privacyMode, fieldNumber: 3)
    }
    if !self.memberRecipientIds.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.memberRecipientIds, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_DistributionList, rhs: BackupProto_DistributionList) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.allowReplies != rhs.allowReplies {return false}
    if lhs.privacyMode != rhs.privacyMode {return false}
    if lhs.memberRecipientIds != rhs.memberRecipientIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_DistributionList.PrivacyMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "ONLY_WITH"),
    2: .same(proto: "ALL_EXCEPT"),
    3: .same(proto: "ALL"),
  ]
}

extension BackupProto_ChatItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chatId"),
    2: .same(proto: "authorId"),
    3: .same(proto: "dateSent"),
    4: .same(proto: "expireStartDate"),
    5: .same(proto: "expiresInMs"),
    6: .same(proto: "revisions"),
    7: .same(proto: "sms"),
    8: .same(proto: "incoming"),
    9: .same(proto: "outgoing"),
    10: .same(proto: "directionless"),
    11: .same(proto: "standardMessage"),
    12: .same(proto: "contactMessage"),
    13: .same(proto: "stickerMessage"),
    14: .same(proto: "remoteDeletedMessage"),
    15: .same(proto: "updateMessage"),
    16: .same(proto: "paymentNotification"),
    17: .same(proto: "giftBadge"),
    18: .same(proto: "viewOnceMessage"),
    19: .same(proto: "directStoryReplyMessage"),
  ]

  fileprivate class _StorageClass {
    var _chatID: UInt64 = 0
    var _authorID: UInt64 = 0
    var _dateSent: UInt64 = 0
    var _expireStartDate: UInt64? = nil
    var _expiresInMs: UInt64? = nil
    var _revisions: [BackupProto_ChatItem] = []
    var _sms: Bool = false
    var _directionalDetails: BackupProto_ChatItem.OneOf_DirectionalDetails?
    var _item: BackupProto_ChatItem.OneOf_Item?

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _chatID = source._chatID
      _authorID = source._authorID
      _dateSent = source._dateSent
      _expireStartDate = source._expireStartDate
      _expiresInMs = source._expiresInMs
      _revisions = source._revisions
      _sms = source._sms
      _directionalDetails = source._directionalDetails
      _item = source._item
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._chatID) }()
        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._authorID) }()
        case 3: try { try decoder.decodeSingularUInt64Field(value: &_storage._dateSent) }()
        case 4: try { try decoder.decodeSingularUInt64Field(value: &_storage._expireStartDate) }()
        case 5: try { try decoder.decodeSingularUInt64Field(value: &_storage._expiresInMs) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._revisions) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._sms) }()
        case 8: try {
          var v: BackupProto_ChatItem.IncomingMessageDetails?
          var hadOneofValue = false
          if let current = _storage._directionalDetails {
            hadOneofValue = true
            if case .incoming(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._directionalDetails = .incoming(v)
          }
        }()
        case 9: try {
          var v: BackupProto_ChatItem.OutgoingMessageDetails?
          var hadOneofValue = false
          if let current = _storage._directionalDetails {
            hadOneofValue = true
            if case .outgoing(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._directionalDetails = .outgoing(v)
          }
        }()
        case 10: try {
          var v: BackupProto_ChatItem.DirectionlessMessageDetails?
          var hadOneofValue = false
          if let current = _storage._directionalDetails {
            hadOneofValue = true
            if case .directionless(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._directionalDetails = .directionless(v)
          }
        }()
        case 11: try {
          var v: BackupProto_StandardMessage?
          var hadOneofValue = false
          if let current = _storage._item {
            hadOneofValue = true
            if case .standardMessage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._item = .standardMessage(v)
          }
        }()
        case 12: try {
          var v: BackupProto_ContactMessage?
          var hadOneofValue = false
          if let current = _storage._item {
            hadOneofValue = true
            if case .contactMessage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._item = .contactMessage(v)
          }
        }()
        case 13: try {
          var v: BackupProto_StickerMessage?
          var hadOneofValue = false
          if let current = _storage._item {
            hadOneofValue = true
            if case .stickerMessage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._item = .stickerMessage(v)
          }
        }()
        case 14: try {
          var v: BackupProto_RemoteDeletedMessage?
          var hadOneofValue = false
          if let current = _storage._item {
            hadOneofValue = true
            if case .remoteDeletedMessage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._item = .remoteDeletedMessage(v)
          }
        }()
        case 15: try {
          var v: BackupProto_ChatUpdateMessage?
          var hadOneofValue = false
          if let current = _storage._item {
            hadOneofValue = true
            if case .updateMessage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._item = .updateMessage(v)
          }
        }()
        case 16: try {
          var v: BackupProto_PaymentNotification?
          var hadOneofValue = false
          if let current = _storage._item {
            hadOneofValue = true
            if case .paymentNotification(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._item = .paymentNotification(v)
          }
        }()
        case 17: try {
          var v: BackupProto_GiftBadge?
          var hadOneofValue = false
          if let current = _storage._item {
            hadOneofValue = true
            if case .giftBadge(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._item = .giftBadge(v)
          }
        }()
        case 18: try {
          var v: BackupProto_ViewOnceMessage?
          var hadOneofValue = false
          if let current = _storage._item {
            hadOneofValue = true
            if case .viewOnceMessage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._item = .viewOnceMessage(v)
          }
        }()
        case 19: try {
          var v: BackupProto_DirectStoryReplyMessage?
          var hadOneofValue = false
          if let current = _storage._item {
            hadOneofValue = true
            if case .directStoryReplyMessage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._item = .directStoryReplyMessage(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._chatID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._chatID, fieldNumber: 1)
      }
      if _storage._authorID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._authorID, fieldNumber: 2)
      }
      if _storage._dateSent != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._dateSent, fieldNumber: 3)
      }
      try { if let v = _storage._expireStartDate {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._expiresInMs {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
      } }()
      if !_storage._revisions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._revisions, fieldNumber: 6)
      }
      if _storage._sms != false {
        try visitor.visitSingularBoolField(value: _storage._sms, fieldNumber: 7)
      }
      switch _storage._directionalDetails {
      case .incoming?: try {
        guard case .incoming(let v)? = _storage._directionalDetails else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .outgoing?: try {
        guard case .outgoing(let v)? = _storage._directionalDetails else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .directionless?: try {
        guard case .directionless(let v)? = _storage._directionalDetails else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case nil: break
      }
      switch _storage._item {
      case .standardMessage?: try {
        guard case .standardMessage(let v)? = _storage._item else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .contactMessage?: try {
        guard case .contactMessage(let v)? = _storage._item else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .stickerMessage?: try {
        guard case .stickerMessage(let v)? = _storage._item else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .remoteDeletedMessage?: try {
        guard case .remoteDeletedMessage(let v)? = _storage._item else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .updateMessage?: try {
        guard case .updateMessage(let v)? = _storage._item else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case .paymentNotification?: try {
        guard case .paymentNotification(let v)? = _storage._item else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }()
      case .giftBadge?: try {
        guard case .giftBadge(let v)? = _storage._item else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }()
      case .viewOnceMessage?: try {
        guard case .viewOnceMessage(let v)? = _storage._item else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }()
      case .directStoryReplyMessage?: try {
        guard case .directStoryReplyMessage(let v)? = _storage._item else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_ChatItem, rhs: BackupProto_ChatItem) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._chatID != rhs_storage._chatID {return false}
        if _storage._authorID != rhs_storage._authorID {return false}
        if _storage._dateSent != rhs_storage._dateSent {return false}
        if _storage._expireStartDate != rhs_storage._expireStartDate {return false}
        if _storage._expiresInMs != rhs_storage._expiresInMs {return false}
        if _storage._revisions != rhs_storage._revisions {return false}
        if _storage._sms != rhs_storage._sms {return false}
        if _storage._directionalDetails != rhs_storage._directionalDetails {return false}
        if _storage._item != rhs_storage._item {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_ChatItem.IncomingMessageDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_ChatItem.protoMessageName + ".IncomingMessageDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dateReceived"),
    2: .same(proto: "dateServerSent"),
    3: .same(proto: "read"),
    4: .same(proto: "sealedSender"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.dateReceived) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._dateServerSent) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.read) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.sealedSender) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.dateReceived != 0 {
      try visitor.visitSingularUInt64Field(value: self.dateReceived, fieldNumber: 1)
    }
    try { if let v = self._dateServerSent {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    if self.read != false {
      try visitor.visitSingularBoolField(value: self.read, fieldNumber: 3)
    }
    if self.sealedSender != false {
      try visitor.visitSingularBoolField(value: self.sealedSender, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_ChatItem.IncomingMessageDetails, rhs: BackupProto_ChatItem.IncomingMessageDetails) -> Bool {
    if lhs.dateReceived != rhs.dateReceived {return false}
    if lhs._dateServerSent != rhs._dateServerSent {return false}
    if lhs.read != rhs.read {return false}
    if lhs.sealedSender != rhs.sealedSender {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_ChatItem.OutgoingMessageDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_ChatItem.protoMessageName + ".OutgoingMessageDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sendStatus"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sendStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sendStatus.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sendStatus, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_ChatItem.OutgoingMessageDetails, rhs: BackupProto_ChatItem.OutgoingMessageDetails) -> Bool {
    if lhs.sendStatus != rhs.sendStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_ChatItem.DirectionlessMessageDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_ChatItem.protoMessageName + ".DirectionlessMessageDetails"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_ChatItem.DirectionlessMessageDetails, rhs: BackupProto_ChatItem.DirectionlessMessageDetails) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_SendStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "recipientId"),
    2: .same(proto: "timestamp"),
    3: .same(proto: "pending"),
    4: .same(proto: "sent"),
    5: .same(proto: "delivered"),
    6: .same(proto: "read"),
    7: .same(proto: "viewed"),
    8: .same(proto: "skipped"),
    9: .same(proto: "failed"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.recipientID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.timestamp) }()
      case 3: try {
        var v: BackupProto_SendStatus.Pending?
        var hadOneofValue = false
        if let current = self.deliveryStatus {
          hadOneofValue = true
          if case .pending(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.deliveryStatus = .pending(v)
        }
      }()
      case 4: try {
        var v: BackupProto_SendStatus.Sent?
        var hadOneofValue = false
        if let current = self.deliveryStatus {
          hadOneofValue = true
          if case .sent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.deliveryStatus = .sent(v)
        }
      }()
      case 5: try {
        var v: BackupProto_SendStatus.Delivered?
        var hadOneofValue = false
        if let current = self.deliveryStatus {
          hadOneofValue = true
          if case .delivered(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.deliveryStatus = .delivered(v)
        }
      }()
      case 6: try {
        var v: BackupProto_SendStatus.Read?
        var hadOneofValue = false
        if let current = self.deliveryStatus {
          hadOneofValue = true
          if case .read(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.deliveryStatus = .read(v)
        }
      }()
      case 7: try {
        var v: BackupProto_SendStatus.Viewed?
        var hadOneofValue = false
        if let current = self.deliveryStatus {
          hadOneofValue = true
          if case .viewed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.deliveryStatus = .viewed(v)
        }
      }()
      case 8: try {
        var v: BackupProto_SendStatus.Skipped?
        var hadOneofValue = false
        if let current = self.deliveryStatus {
          hadOneofValue = true
          if case .skipped(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.deliveryStatus = .skipped(v)
        }
      }()
      case 9: try {
        var v: BackupProto_SendStatus.Failed?
        var hadOneofValue = false
        if let current = self.deliveryStatus {
          hadOneofValue = true
          if case .failed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.deliveryStatus = .failed(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.recipientID != 0 {
      try visitor.visitSingularUInt64Field(value: self.recipientID, fieldNumber: 1)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestamp, fieldNumber: 2)
    }
    switch self.deliveryStatus {
    case .pending?: try {
      guard case .pending(let v)? = self.deliveryStatus else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .sent?: try {
      guard case .sent(let v)? = self.deliveryStatus else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .delivered?: try {
      guard case .delivered(let v)? = self.deliveryStatus else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .read?: try {
      guard case .read(let v)? = self.deliveryStatus else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .viewed?: try {
      guard case .viewed(let v)? = self.deliveryStatus else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .skipped?: try {
      guard case .skipped(let v)? = self.deliveryStatus else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .failed?: try {
      guard case .failed(let v)? = self.deliveryStatus else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_SendStatus, rhs: BackupProto_SendStatus) -> Bool {
    if lhs.recipientID != rhs.recipientID {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.deliveryStatus != rhs.deliveryStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_SendStatus.Pending: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_SendStatus.protoMessageName + ".Pending"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_SendStatus.Pending, rhs: BackupProto_SendStatus.Pending) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_SendStatus.Sent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_SendStatus.protoMessageName + ".Sent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sealedSender"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.sealedSender) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sealedSender != false {
      try visitor.visitSingularBoolField(value: self.sealedSender, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_SendStatus.Sent, rhs: BackupProto_SendStatus.Sent) -> Bool {
    if lhs.sealedSender != rhs.sealedSender {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_SendStatus.Delivered: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_SendStatus.protoMessageName + ".Delivered"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sealedSender"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.sealedSender) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sealedSender != false {
      try visitor.visitSingularBoolField(value: self.sealedSender, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_SendStatus.Delivered, rhs: BackupProto_SendStatus.Delivered) -> Bool {
    if lhs.sealedSender != rhs.sealedSender {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_SendStatus.Read: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_SendStatus.protoMessageName + ".Read"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sealedSender"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.sealedSender) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sealedSender != false {
      try visitor.visitSingularBoolField(value: self.sealedSender, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_SendStatus.Read, rhs: BackupProto_SendStatus.Read) -> Bool {
    if lhs.sealedSender != rhs.sealedSender {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_SendStatus.Viewed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_SendStatus.protoMessageName + ".Viewed"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sealedSender"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.sealedSender) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sealedSender != false {
      try visitor.visitSingularBoolField(value: self.sealedSender, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_SendStatus.Viewed, rhs: BackupProto_SendStatus.Viewed) -> Bool {
    if lhs.sealedSender != rhs.sealedSender {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_SendStatus.Skipped: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_SendStatus.protoMessageName + ".Skipped"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_SendStatus.Skipped, rhs: BackupProto_SendStatus.Skipped) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_SendStatus.Failed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_SendStatus.protoMessageName + ".Failed"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reason != .unknown {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_SendStatus.Failed, rhs: BackupProto_SendStatus.Failed) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_SendStatus.Failed.FailureReason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "NETWORK"),
    2: .same(proto: "IDENTITY_KEY_MISMATCH"),
  ]
}

extension BackupProto_Text: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Text"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "body"),
    2: .same(proto: "bodyRanges"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.body) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.bodyRanges) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.body.isEmpty {
      try visitor.visitSingularStringField(value: self.body, fieldNumber: 1)
    }
    if !self.bodyRanges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bodyRanges, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_Text, rhs: BackupProto_Text) -> Bool {
    if lhs.body != rhs.body {return false}
    if lhs.bodyRanges != rhs.bodyRanges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_StandardMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StandardMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "quote"),
    2: .same(proto: "text"),
    3: .same(proto: "attachments"),
    4: .same(proto: "linkPreview"),
    5: .same(proto: "longText"),
    6: .same(proto: "reactions"),
  ]

  fileprivate class _StorageClass {
    var _quote: BackupProto_Quote? = nil
    var _text: BackupProto_Text? = nil
    var _attachments: [BackupProto_MessageAttachment] = []
    var _linkPreview: [BackupProto_LinkPreview] = []
    var _longText: BackupProto_FilePointer? = nil
    var _reactions: [BackupProto_Reaction] = []

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _quote = source._quote
      _text = source._text
      _attachments = source._attachments
      _linkPreview = source._linkPreview
      _longText = source._longText
      _reactions = source._reactions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._quote) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._text) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._attachments) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._linkPreview) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._longText) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._reactions) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._quote {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._text {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._attachments.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._attachments, fieldNumber: 3)
      }
      if !_storage._linkPreview.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._linkPreview, fieldNumber: 4)
      }
      try { if let v = _storage._longText {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._reactions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._reactions, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_StandardMessage, rhs: BackupProto_StandardMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._quote != rhs_storage._quote {return false}
        if _storage._text != rhs_storage._text {return false}
        if _storage._attachments != rhs_storage._attachments {return false}
        if _storage._linkPreview != rhs_storage._linkPreview {return false}
        if _storage._longText != rhs_storage._longText {return false}
        if _storage._reactions != rhs_storage._reactions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_ContactMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContactMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contact"),
    2: .same(proto: "reactions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._contact) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.reactions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._contact {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.reactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reactions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_ContactMessage, rhs: BackupProto_ContactMessage) -> Bool {
    if lhs._contact != rhs._contact {return false}
    if lhs.reactions != rhs.reactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_DirectStoryReplyMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DirectStoryReplyMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "textReply"),
    2: .same(proto: "emoji"),
    3: .same(proto: "reactions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: BackupProto_DirectStoryReplyMessage.TextReply?
        var hadOneofValue = false
        if let current = self.reply {
          hadOneofValue = true
          if case .textReply(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reply = .textReply(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.reply != nil {try decoder.handleConflictingOneOf()}
          self.reply = .emoji(v)
        }
      }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.reactions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.reply {
    case .textReply?: try {
      guard case .textReply(let v)? = self.reply else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .emoji?: try {
      guard case .emoji(let v)? = self.reply else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if !self.reactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reactions, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_DirectStoryReplyMessage, rhs: BackupProto_DirectStoryReplyMessage) -> Bool {
    if lhs.reply != rhs.reply {return false}
    if lhs.reactions != rhs.reactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_DirectStoryReplyMessage.TextReply: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_DirectStoryReplyMessage.protoMessageName + ".TextReply"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "longText"),
  ]

  fileprivate class _StorageClass {
    var _text: BackupProto_Text? = nil
    var _longText: BackupProto_FilePointer? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _text = source._text
      _longText = source._longText
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._text) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._longText) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._text {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._longText {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_DirectStoryReplyMessage.TextReply, rhs: BackupProto_DirectStoryReplyMessage.TextReply) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._text != rhs_storage._text {return false}
        if _storage._longText != rhs_storage._longText {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_PaymentNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PaymentNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amountMob"),
    2: .same(proto: "feeMob"),
    3: .same(proto: "note"),
    4: .same(proto: "transactionDetails"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._amountMob) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._feeMob) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._note) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._transactionDetails) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._amountMob {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._feeMob {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._note {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._transactionDetails {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_PaymentNotification, rhs: BackupProto_PaymentNotification) -> Bool {
    if lhs._amountMob != rhs._amountMob {return false}
    if lhs._feeMob != rhs._feeMob {return false}
    if lhs._note != rhs._note {return false}
    if lhs._transactionDetails != rhs._transactionDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_PaymentNotification.TransactionDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_PaymentNotification.protoMessageName + ".TransactionDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transaction"),
    2: .same(proto: "failedTransaction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: BackupProto_PaymentNotification.TransactionDetails.Transaction?
        var hadOneofValue = false
        if let current = self.payment {
          hadOneofValue = true
          if case .transaction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payment = .transaction(v)
        }
      }()
      case 2: try {
        var v: BackupProto_PaymentNotification.TransactionDetails.FailedTransaction?
        var hadOneofValue = false
        if let current = self.payment {
          hadOneofValue = true
          if case .failedTransaction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payment = .failedTransaction(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payment {
    case .transaction?: try {
      guard case .transaction(let v)? = self.payment else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .failedTransaction?: try {
      guard case .failedTransaction(let v)? = self.payment else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_PaymentNotification.TransactionDetails, rhs: BackupProto_PaymentNotification.TransactionDetails) -> Bool {
    if lhs.payment != rhs.payment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_PaymentNotification.TransactionDetails.MobileCoinTxoIdentification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_PaymentNotification.TransactionDetails.protoMessageName + ".MobileCoinTxoIdentification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicKey"),
    2: .same(proto: "keyImages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.publicKey) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.keyImages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.publicKey, fieldNumber: 1)
    }
    if !self.keyImages.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.keyImages, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_PaymentNotification.TransactionDetails.MobileCoinTxoIdentification, rhs: BackupProto_PaymentNotification.TransactionDetails.MobileCoinTxoIdentification) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.keyImages != rhs.keyImages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_PaymentNotification.TransactionDetails.FailedTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_PaymentNotification.TransactionDetails.protoMessageName + ".FailedTransaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reason != .generic {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_PaymentNotification.TransactionDetails.FailedTransaction, rhs: BackupProto_PaymentNotification.TransactionDetails.FailedTransaction) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_PaymentNotification.TransactionDetails.FailedTransaction.FailureReason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GENERIC"),
    1: .same(proto: "NETWORK"),
    2: .same(proto: "INSUFFICIENT_FUNDS"),
  ]
}

extension BackupProto_PaymentNotification.TransactionDetails.Transaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_PaymentNotification.TransactionDetails.protoMessageName + ".Transaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "mobileCoinIdentification"),
    3: .same(proto: "timestamp"),
    4: .same(proto: "blockIndex"),
    5: .same(proto: "blockTimestamp"),
    6: .same(proto: "transaction"),
    7: .same(proto: "receipt"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._mobileCoinIdentification) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._blockIndex) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self._blockTimestamp) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self._transaction) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self._receipt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.status != .initial {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try { if let v = self._mobileCoinIdentification {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._blockIndex {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._blockTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._transaction {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._receipt {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_PaymentNotification.TransactionDetails.Transaction, rhs: BackupProto_PaymentNotification.TransactionDetails.Transaction) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs._mobileCoinIdentification != rhs._mobileCoinIdentification {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._blockIndex != rhs._blockIndex {return false}
    if lhs._blockTimestamp != rhs._blockTimestamp {return false}
    if lhs._transaction != rhs._transaction {return false}
    if lhs._receipt != rhs._receipt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_PaymentNotification.TransactionDetails.Transaction.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INITIAL"),
    1: .same(proto: "SUBMITTED"),
    2: .same(proto: "SUCCESSFUL"),
  ]
}

extension BackupProto_GiftBadge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GiftBadge"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "receiptCredentialPresentation"),
    2: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.receiptCredentialPresentation) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.receiptCredentialPresentation.isEmpty {
      try visitor.visitSingularBytesField(value: self.receiptCredentialPresentation, fieldNumber: 1)
    }
    if self.state != .unopened {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_GiftBadge, rhs: BackupProto_GiftBadge) -> Bool {
    if lhs.receiptCredentialPresentation != rhs.receiptCredentialPresentation {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_GiftBadge.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNOPENED"),
    1: .same(proto: "OPENED"),
    2: .same(proto: "REDEEMED"),
    3: .same(proto: "FAILED"),
  ]
}

extension BackupProto_ViewOnceMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ViewOnceMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "attachment"),
    2: .same(proto: "reactions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._attachment) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.reactions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._attachment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.reactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reactions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_ViewOnceMessage, rhs: BackupProto_ViewOnceMessage) -> Bool {
    if lhs._attachment != rhs._attachment {return false}
    if lhs.reactions != rhs.reactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_ContactAttachment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContactAttachment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .same(proto: "number"),
    4: .same(proto: "email"),
    5: .same(proto: "address"),
    6: .same(proto: "avatar"),
    7: .same(proto: "organization"),
  ]

  fileprivate class _StorageClass {
    var _name: BackupProto_ContactAttachment.Name? = nil
    var _number: [BackupProto_ContactAttachment.Phone] = []
    var _email: [BackupProto_ContactAttachment.Email] = []
    var _address: [BackupProto_ContactAttachment.PostalAddress] = []
    var _avatar: BackupProto_FilePointer? = nil
    var _organization: String = String()

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _number = source._number
      _email = source._email
      _address = source._address
      _avatar = source._avatar
      _organization = source._organization
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._name) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._number) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._email) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._address) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._avatar) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._organization) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._name {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._number.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._number, fieldNumber: 3)
      }
      if !_storage._email.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._email, fieldNumber: 4)
      }
      if !_storage._address.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._address, fieldNumber: 5)
      }
      try { if let v = _storage._avatar {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._organization.isEmpty {
        try visitor.visitSingularStringField(value: _storage._organization, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_ContactAttachment, rhs: BackupProto_ContactAttachment) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._number != rhs_storage._number {return false}
        if _storage._email != rhs_storage._email {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._avatar != rhs_storage._avatar {return false}
        if _storage._organization != rhs_storage._organization {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_ContactAttachment.Name: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_ContactAttachment.protoMessageName + ".Name"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "givenName"),
    2: .same(proto: "familyName"),
    3: .same(proto: "prefix"),
    4: .same(proto: "suffix"),
    5: .same(proto: "middleName"),
    6: .same(proto: "nickname"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.givenName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.familyName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.prefix) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.suffix) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.middleName) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.givenName.isEmpty {
      try visitor.visitSingularStringField(value: self.givenName, fieldNumber: 1)
    }
    if !self.familyName.isEmpty {
      try visitor.visitSingularStringField(value: self.familyName, fieldNumber: 2)
    }
    if !self.prefix.isEmpty {
      try visitor.visitSingularStringField(value: self.prefix, fieldNumber: 3)
    }
    if !self.suffix.isEmpty {
      try visitor.visitSingularStringField(value: self.suffix, fieldNumber: 4)
    }
    if !self.middleName.isEmpty {
      try visitor.visitSingularStringField(value: self.middleName, fieldNumber: 5)
    }
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_ContactAttachment.Name, rhs: BackupProto_ContactAttachment.Name) -> Bool {
    if lhs.givenName != rhs.givenName {return false}
    if lhs.familyName != rhs.familyName {return false}
    if lhs.prefix != rhs.prefix {return false}
    if lhs.suffix != rhs.suffix {return false}
    if lhs.middleName != rhs.middleName {return false}
    if lhs.nickname != rhs.nickname {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_ContactAttachment.Phone: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_ContactAttachment.protoMessageName + ".Phone"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "type"),
    3: .same(proto: "label"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.label) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_ContactAttachment.Phone, rhs: BackupProto_ContactAttachment.Phone) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.type != rhs.type {return false}
    if lhs.label != rhs.label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_ContactAttachment.Phone.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "HOME"),
    2: .same(proto: "MOBILE"),
    3: .same(proto: "WORK"),
    4: .same(proto: "CUSTOM"),
  ]
}

extension BackupProto_ContactAttachment.Email: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_ContactAttachment.protoMessageName + ".Email"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "type"),
    3: .same(proto: "label"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.label) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_ContactAttachment.Email, rhs: BackupProto_ContactAttachment.Email) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.type != rhs.type {return false}
    if lhs.label != rhs.label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_ContactAttachment.Email.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "HOME"),
    2: .same(proto: "MOBILE"),
    3: .same(proto: "WORK"),
    4: .same(proto: "CUSTOM"),
  ]
}

extension BackupProto_ContactAttachment.PostalAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_ContactAttachment.protoMessageName + ".PostalAddress"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "label"),
    3: .same(proto: "street"),
    4: .same(proto: "pobox"),
    5: .same(proto: "neighborhood"),
    6: .same(proto: "city"),
    7: .same(proto: "region"),
    8: .same(proto: "postcode"),
    9: .same(proto: "country"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.street) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pobox) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.neighborhood) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.city) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.region) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.postcode) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.country) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 2)
    }
    if !self.street.isEmpty {
      try visitor.visitSingularStringField(value: self.street, fieldNumber: 3)
    }
    if !self.pobox.isEmpty {
      try visitor.visitSingularStringField(value: self.pobox, fieldNumber: 4)
    }
    if !self.neighborhood.isEmpty {
      try visitor.visitSingularStringField(value: self.neighborhood, fieldNumber: 5)
    }
    if !self.city.isEmpty {
      try visitor.visitSingularStringField(value: self.city, fieldNumber: 6)
    }
    if !self.region.isEmpty {
      try visitor.visitSingularStringField(value: self.region, fieldNumber: 7)
    }
    if !self.postcode.isEmpty {
      try visitor.visitSingularStringField(value: self.postcode, fieldNumber: 8)
    }
    if !self.country.isEmpty {
      try visitor.visitSingularStringField(value: self.country, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_ContactAttachment.PostalAddress, rhs: BackupProto_ContactAttachment.PostalAddress) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.label != rhs.label {return false}
    if lhs.street != rhs.street {return false}
    if lhs.pobox != rhs.pobox {return false}
    if lhs.neighborhood != rhs.neighborhood {return false}
    if lhs.city != rhs.city {return false}
    if lhs.region != rhs.region {return false}
    if lhs.postcode != rhs.postcode {return false}
    if lhs.country != rhs.country {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_ContactAttachment.PostalAddress.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "HOME"),
    2: .same(proto: "WORK"),
    3: .same(proto: "CUSTOM"),
  ]
}

extension BackupProto_StickerMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StickerMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sticker"),
    2: .same(proto: "reactions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sticker) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.reactions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sticker {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.reactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reactions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_StickerMessage, rhs: BackupProto_StickerMessage) -> Bool {
    if lhs._sticker != rhs._sticker {return false}
    if lhs.reactions != rhs.reactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_RemoteDeletedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoteDeletedMessage"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_RemoteDeletedMessage, rhs: BackupProto_RemoteDeletedMessage) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_Sticker: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Sticker"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "packId"),
    2: .same(proto: "packKey"),
    3: .same(proto: "stickerId"),
    4: .same(proto: "emoji"),
    5: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _packID: Data = Data()
    var _packKey: Data = Data()
    var _stickerID: UInt32 = 0
    var _emoji: String? = nil
    var _data: BackupProto_FilePointer? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _packID = source._packID
      _packKey = source._packKey
      _stickerID = source._stickerID
      _emoji = source._emoji
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._packID) }()
        case 2: try { try decoder.decodeSingularBytesField(value: &_storage._packKey) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._stickerID) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._emoji) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._data) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._packID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._packID, fieldNumber: 1)
      }
      if !_storage._packKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._packKey, fieldNumber: 2)
      }
      if _storage._stickerID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._stickerID, fieldNumber: 3)
      }
      try { if let v = _storage._emoji {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_Sticker, rhs: BackupProto_Sticker) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._packID != rhs_storage._packID {return false}
        if _storage._packKey != rhs_storage._packKey {return false}
        if _storage._stickerID != rhs_storage._stickerID {return false}
        if _storage._emoji != rhs_storage._emoji {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_LinkPreview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LinkPreview"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "title"),
    3: .same(proto: "image"),
    4: .same(proto: "description"),
    5: .same(proto: "date"),
  ]

  fileprivate class _StorageClass {
    var _url: String = String()
    var _title: String? = nil
    var _image: BackupProto_FilePointer? = nil
    var _description_p: String? = nil
    var _date: UInt64? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _url = source._url
      _title = source._title
      _image = source._image
      _description_p = source._description_p
      _date = source._date
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._url) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._image) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 5: try { try decoder.decodeSingularUInt64Field(value: &_storage._date) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._url.isEmpty {
        try visitor.visitSingularStringField(value: _storage._url, fieldNumber: 1)
      }
      try { if let v = _storage._title {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._image {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._description_p {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._date {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_LinkPreview, rhs: BackupProto_LinkPreview) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._url != rhs_storage._url {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._image != rhs_storage._image {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._date != rhs_storage._date {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_MessageAttachment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageAttachment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pointer"),
    2: .same(proto: "flag"),
    3: .same(proto: "wasDownloaded"),
    4: .same(proto: "clientUuid"),
  ]

  fileprivate class _StorageClass {
    var _pointer: BackupProto_FilePointer? = nil
    var _flag: BackupProto_MessageAttachment.Flag = .none
    var _wasDownloaded: Bool = false
    var _clientUuid: Data? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _pointer = source._pointer
      _flag = source._flag
      _wasDownloaded = source._wasDownloaded
      _clientUuid = source._clientUuid
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._pointer) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._flag) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._wasDownloaded) }()
        case 4: try { try decoder.decodeSingularBytesField(value: &_storage._clientUuid) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._pointer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if _storage._flag != .none {
        try visitor.visitSingularEnumField(value: _storage._flag, fieldNumber: 2)
      }
      if _storage._wasDownloaded != false {
        try visitor.visitSingularBoolField(value: _storage._wasDownloaded, fieldNumber: 3)
      }
      try { if let v = _storage._clientUuid {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_MessageAttachment, rhs: BackupProto_MessageAttachment) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._pointer != rhs_storage._pointer {return false}
        if _storage._flag != rhs_storage._flag {return false}
        if _storage._wasDownloaded != rhs_storage._wasDownloaded {return false}
        if _storage._clientUuid != rhs_storage._clientUuid {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_MessageAttachment.Flag: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "VOICE_MESSAGE"),
    2: .same(proto: "BORDERLESS"),
    3: .same(proto: "GIF"),
  ]
}

extension BackupProto_FilePointer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FilePointer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "backupLocator"),
    2: .same(proto: "attachmentLocator"),
    3: .same(proto: "invalidAttachmentLocator"),
    4: .same(proto: "contentType"),
    5: .same(proto: "incrementalMac"),
    6: .same(proto: "incrementalMacChunkSize"),
    7: .same(proto: "fileName"),
    8: .same(proto: "width"),
    9: .same(proto: "height"),
    10: .same(proto: "caption"),
    11: .same(proto: "blurHash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: BackupProto_FilePointer.BackupLocator?
        var hadOneofValue = false
        if let current = self.locator {
          hadOneofValue = true
          if case .backupLocator(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.locator = .backupLocator(v)
        }
      }()
      case 2: try {
        var v: BackupProto_FilePointer.AttachmentLocator?
        var hadOneofValue = false
        if let current = self.locator {
          hadOneofValue = true
          if case .attachmentLocator(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.locator = .attachmentLocator(v)
        }
      }()
      case 3: try {
        var v: BackupProto_FilePointer.InvalidAttachmentLocator?
        var hadOneofValue = false
        if let current = self.locator {
          hadOneofValue = true
          if case .invalidAttachmentLocator(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.locator = .invalidAttachmentLocator(v)
        }
      }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._contentType) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._incrementalMac) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._incrementalMacChunkSize) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._fileName) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self._width) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self._height) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self._caption) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self._blurHash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.locator {
    case .backupLocator?: try {
      guard case .backupLocator(let v)? = self.locator else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .attachmentLocator?: try {
      guard case .attachmentLocator(let v)? = self.locator else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .invalidAttachmentLocator?: try {
      guard case .invalidAttachmentLocator(let v)? = self.locator else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try { if let v = self._contentType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._incrementalMac {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._incrementalMacChunkSize {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._fileName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._width {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._height {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._caption {
      try visitor.visitSingularStringField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._blurHash {
      try visitor.visitSingularStringField(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_FilePointer, rhs: BackupProto_FilePointer) -> Bool {
    if lhs.locator != rhs.locator {return false}
    if lhs._contentType != rhs._contentType {return false}
    if lhs._incrementalMac != rhs._incrementalMac {return false}
    if lhs._incrementalMacChunkSize != rhs._incrementalMacChunkSize {return false}
    if lhs._fileName != rhs._fileName {return false}
    if lhs._width != rhs._width {return false}
    if lhs._height != rhs._height {return false}
    if lhs._caption != rhs._caption {return false}
    if lhs._blurHash != rhs._blurHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_FilePointer.BackupLocator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_FilePointer.protoMessageName + ".BackupLocator"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mediaName"),
    2: .same(proto: "cdnNumber"),
    3: .same(proto: "key"),
    4: .same(proto: "digest"),
    5: .same(proto: "size"),
    6: .same(proto: "transitCdnKey"),
    7: .same(proto: "transitCdnNumber"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mediaName) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._cdnNumber) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.digest) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.size) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._transitCdnKey) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._transitCdnNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.mediaName.isEmpty {
      try visitor.visitSingularStringField(value: self.mediaName, fieldNumber: 1)
    }
    try { if let v = self._cdnNumber {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 3)
    }
    if !self.digest.isEmpty {
      try visitor.visitSingularBytesField(value: self.digest, fieldNumber: 4)
    }
    if self.size != 0 {
      try visitor.visitSingularUInt32Field(value: self.size, fieldNumber: 5)
    }
    try { if let v = self._transitCdnKey {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._transitCdnNumber {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_FilePointer.BackupLocator, rhs: BackupProto_FilePointer.BackupLocator) -> Bool {
    if lhs.mediaName != rhs.mediaName {return false}
    if lhs._cdnNumber != rhs._cdnNumber {return false}
    if lhs.key != rhs.key {return false}
    if lhs.digest != rhs.digest {return false}
    if lhs.size != rhs.size {return false}
    if lhs._transitCdnKey != rhs._transitCdnKey {return false}
    if lhs._transitCdnNumber != rhs._transitCdnNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_FilePointer.AttachmentLocator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_FilePointer.protoMessageName + ".AttachmentLocator"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cdnKey"),
    2: .same(proto: "cdnNumber"),
    3: .same(proto: "uploadTimestamp"),
    4: .same(proto: "key"),
    5: .same(proto: "digest"),
    6: .same(proto: "size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cdnKey) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.cdnNumber) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._uploadTimestamp) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.digest) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.size) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.cdnKey.isEmpty {
      try visitor.visitSingularStringField(value: self.cdnKey, fieldNumber: 1)
    }
    if self.cdnNumber != 0 {
      try visitor.visitSingularUInt32Field(value: self.cdnNumber, fieldNumber: 2)
    }
    try { if let v = self._uploadTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 4)
    }
    if !self.digest.isEmpty {
      try visitor.visitSingularBytesField(value: self.digest, fieldNumber: 5)
    }
    if self.size != 0 {
      try visitor.visitSingularUInt32Field(value: self.size, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_FilePointer.AttachmentLocator, rhs: BackupProto_FilePointer.AttachmentLocator) -> Bool {
    if lhs.cdnKey != rhs.cdnKey {return false}
    if lhs.cdnNumber != rhs.cdnNumber {return false}
    if lhs._uploadTimestamp != rhs._uploadTimestamp {return false}
    if lhs.key != rhs.key {return false}
    if lhs.digest != rhs.digest {return false}
    if lhs.size != rhs.size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_FilePointer.InvalidAttachmentLocator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_FilePointer.protoMessageName + ".InvalidAttachmentLocator"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_FilePointer.InvalidAttachmentLocator, rhs: BackupProto_FilePointer.InvalidAttachmentLocator) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_Quote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Quote"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targetSentTimestamp"),
    2: .same(proto: "authorId"),
    3: .same(proto: "text"),
    4: .same(proto: "attachments"),
    5: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._targetSentTimestamp) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.authorID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._text) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.attachments) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._targetSentTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    if self.authorID != 0 {
      try visitor.visitSingularUInt64Field(value: self.authorID, fieldNumber: 2)
    }
    try { if let v = self._text {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.attachments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attachments, fieldNumber: 4)
    }
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_Quote, rhs: BackupProto_Quote) -> Bool {
    if lhs._targetSentTimestamp != rhs._targetSentTimestamp {return false}
    if lhs.authorID != rhs.authorID {return false}
    if lhs._text != rhs._text {return false}
    if lhs.attachments != rhs.attachments {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_Quote.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "NORMAL"),
    2: .same(proto: "GIFT_BADGE"),
    3: .same(proto: "VIEW_ONCE"),
  ]
}

extension BackupProto_Quote.QuotedAttachment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_Quote.protoMessageName + ".QuotedAttachment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contentType"),
    2: .same(proto: "fileName"),
    3: .same(proto: "thumbnail"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._contentType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._fileName) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._thumbnail) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._contentType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._fileName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._thumbnail {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_Quote.QuotedAttachment, rhs: BackupProto_Quote.QuotedAttachment) -> Bool {
    if lhs._contentType != rhs._contentType {return false}
    if lhs._fileName != rhs._fileName {return false}
    if lhs._thumbnail != rhs._thumbnail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_BodyRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BodyRange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "length"),
    3: .same(proto: "mentionAci"),
    4: .same(proto: "style"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.start) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.length) }()
      case 3: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.associatedValue != nil {try decoder.handleConflictingOneOf()}
          self.associatedValue = .mentionAci(v)
        }
      }()
      case 4: try {
        var v: BackupProto_BodyRange.Style?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.associatedValue != nil {try decoder.handleConflictingOneOf()}
          self.associatedValue = .style(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.start != 0 {
      try visitor.visitSingularUInt32Field(value: self.start, fieldNumber: 1)
    }
    if self.length != 0 {
      try visitor.visitSingularUInt32Field(value: self.length, fieldNumber: 2)
    }
    switch self.associatedValue {
    case .mentionAci?: try {
      guard case .mentionAci(let v)? = self.associatedValue else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }()
    case .style?: try {
      guard case .style(let v)? = self.associatedValue else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_BodyRange, rhs: BackupProto_BodyRange) -> Bool {
    if lhs.start != rhs.start {return false}
    if lhs.length != rhs.length {return false}
    if lhs.associatedValue != rhs.associatedValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_BodyRange.Style: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "BOLD"),
    2: .same(proto: "ITALIC"),
    3: .same(proto: "SPOILER"),
    4: .same(proto: "STRIKETHROUGH"),
    5: .same(proto: "MONOSPACE"),
  ]
}

extension BackupProto_Reaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Reaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "emoji"),
    2: .same(proto: "authorId"),
    3: .same(proto: "sentTimestamp"),
    4: .same(proto: "sortOrder"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.emoji) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.authorID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.sentTimestamp) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.sortOrder) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.emoji.isEmpty {
      try visitor.visitSingularStringField(value: self.emoji, fieldNumber: 1)
    }
    if self.authorID != 0 {
      try visitor.visitSingularUInt64Field(value: self.authorID, fieldNumber: 2)
    }
    if self.sentTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.sentTimestamp, fieldNumber: 3)
    }
    if self.sortOrder != 0 {
      try visitor.visitSingularUInt64Field(value: self.sortOrder, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_Reaction, rhs: BackupProto_Reaction) -> Bool {
    if lhs.emoji != rhs.emoji {return false}
    if lhs.authorID != rhs.authorID {return false}
    if lhs.sentTimestamp != rhs.sentTimestamp {return false}
    if lhs.sortOrder != rhs.sortOrder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_ChatUpdateMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatUpdateMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "simpleUpdate"),
    2: .same(proto: "groupChange"),
    3: .same(proto: "expirationTimerChange"),
    4: .same(proto: "profileChange"),
    5: .same(proto: "threadMerge"),
    6: .same(proto: "sessionSwitchover"),
    7: .same(proto: "individualCall"),
    8: .same(proto: "groupCall"),
    9: .same(proto: "learnedProfileChange"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: BackupProto_SimpleChatUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .simpleUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .simpleUpdate(v)
        }
      }()
      case 2: try {
        var v: BackupProto_GroupChangeChatUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .groupChange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .groupChange(v)
        }
      }()
      case 3: try {
        var v: BackupProto_ExpirationTimerChatUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .expirationTimerChange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .expirationTimerChange(v)
        }
      }()
      case 4: try {
        var v: BackupProto_ProfileChangeChatUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .profileChange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .profileChange(v)
        }
      }()
      case 5: try {
        var v: BackupProto_ThreadMergeChatUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .threadMerge(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .threadMerge(v)
        }
      }()
      case 6: try {
        var v: BackupProto_SessionSwitchoverChatUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .sessionSwitchover(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .sessionSwitchover(v)
        }
      }()
      case 7: try {
        var v: BackupProto_IndividualCall?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .individualCall(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .individualCall(v)
        }
      }()
      case 8: try {
        var v: BackupProto_GroupCall?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .groupCall(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .groupCall(v)
        }
      }()
      case 9: try {
        var v: BackupProto_LearnedProfileChatUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .learnedProfileChange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .learnedProfileChange(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.update {
    case .simpleUpdate?: try {
      guard case .simpleUpdate(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .groupChange?: try {
      guard case .groupChange(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .expirationTimerChange?: try {
      guard case .expirationTimerChange(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .profileChange?: try {
      guard case .profileChange(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .threadMerge?: try {
      guard case .threadMerge(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .sessionSwitchover?: try {
      guard case .sessionSwitchover(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .individualCall?: try {
      guard case .individualCall(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .groupCall?: try {
      guard case .groupCall(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .learnedProfileChange?: try {
      guard case .learnedProfileChange(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_ChatUpdateMessage, rhs: BackupProto_ChatUpdateMessage) -> Bool {
    if lhs.update != rhs.update {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_IndividualCall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IndividualCall"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "callId"),
    2: .same(proto: "type"),
    3: .same(proto: "direction"),
    4: .same(proto: "state"),
    5: .same(proto: "startedCallTimestamp"),
    6: .same(proto: "read"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._callID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.startedCallTimestamp) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.read) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._callID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    if self.type != .unknownType {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if self.direction != .unknownDirection {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 3)
    }
    if self.state != .unknownState {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 4)
    }
    if self.startedCallTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.startedCallTimestamp, fieldNumber: 5)
    }
    if self.read != false {
      try visitor.visitSingularBoolField(value: self.read, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_IndividualCall, rhs: BackupProto_IndividualCall) -> Bool {
    if lhs._callID != rhs._callID {return false}
    if lhs.type != rhs.type {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.state != rhs.state {return false}
    if lhs.startedCallTimestamp != rhs.startedCallTimestamp {return false}
    if lhs.read != rhs.read {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_IndividualCall.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_TYPE"),
    1: .same(proto: "AUDIO_CALL"),
    2: .same(proto: "VIDEO_CALL"),
  ]
}

extension BackupProto_IndividualCall.Direction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_DIRECTION"),
    1: .same(proto: "INCOMING"),
    2: .same(proto: "OUTGOING"),
  ]
}

extension BackupProto_IndividualCall.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_STATE"),
    1: .same(proto: "ACCEPTED"),
    2: .same(proto: "NOT_ACCEPTED"),
    3: .same(proto: "MISSED"),
    4: .same(proto: "MISSED_NOTIFICATION_PROFILE"),
  ]
}

extension BackupProto_GroupCall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupCall"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "callId"),
    2: .same(proto: "state"),
    3: .same(proto: "ringerRecipientId"),
    4: .same(proto: "startedCallRecipientId"),
    5: .same(proto: "startedCallTimestamp"),
    6: .same(proto: "endedCallTimestamp"),
    7: .same(proto: "read"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._callID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._ringerRecipientID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._startedCallRecipientID) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.startedCallTimestamp) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self._endedCallTimestamp) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.read) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._callID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    if self.state != .unknownState {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 2)
    }
    try { if let v = self._ringerRecipientID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._startedCallRecipientID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    if self.startedCallTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.startedCallTimestamp, fieldNumber: 5)
    }
    try { if let v = self._endedCallTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    } }()
    if self.read != false {
      try visitor.visitSingularBoolField(value: self.read, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_GroupCall, rhs: BackupProto_GroupCall) -> Bool {
    if lhs._callID != rhs._callID {return false}
    if lhs.state != rhs.state {return false}
    if lhs._ringerRecipientID != rhs._ringerRecipientID {return false}
    if lhs._startedCallRecipientID != rhs._startedCallRecipientID {return false}
    if lhs.startedCallTimestamp != rhs.startedCallTimestamp {return false}
    if lhs._endedCallTimestamp != rhs._endedCallTimestamp {return false}
    if lhs.read != rhs.read {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_GroupCall.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_STATE"),
    1: .same(proto: "GENERIC"),
    2: .same(proto: "JOINED"),
    3: .same(proto: "RINGING"),
    4: .same(proto: "ACCEPTED"),
    5: .same(proto: "DECLINED"),
    6: .same(proto: "MISSED"),
    7: .same(proto: "MISSED_NOTIFICATION_PROFILE"),
    8: .same(proto: "OUTGOING_RING"),
  ]
}

extension BackupProto_SimpleChatUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SimpleChatUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_SimpleChatUpdate, rhs: BackupProto_SimpleChatUpdate) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_SimpleChatUpdate.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "JOINED_SIGNAL"),
    2: .same(proto: "IDENTITY_UPDATE"),
    3: .same(proto: "IDENTITY_VERIFIED"),
    4: .same(proto: "IDENTITY_DEFAULT"),
    5: .same(proto: "CHANGE_NUMBER"),
    6: .same(proto: "RELEASE_CHANNEL_DONATION_REQUEST"),
    7: .same(proto: "END_SESSION"),
    8: .same(proto: "CHAT_SESSION_REFRESH"),
    9: .same(proto: "BAD_DECRYPT"),
    10: .same(proto: "PAYMENTS_ACTIVATED"),
    11: .same(proto: "PAYMENT_ACTIVATION_REQUEST"),
    12: .same(proto: "UNSUPPORTED_PROTOCOL_MESSAGE"),
    13: .same(proto: "REPORTED_SPAM"),
    14: .same(proto: "BLOCKED"),
    15: .same(proto: "UNBLOCKED"),
    16: .same(proto: "MESSAGE_REQUEST_ACCEPTED"),
  ]
}

extension BackupProto_ExpirationTimerChatUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExpirationTimerChatUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "expiresInMs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.expiresInMs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.expiresInMs != 0 {
      try visitor.visitSingularUInt64Field(value: self.expiresInMs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_ExpirationTimerChatUpdate, rhs: BackupProto_ExpirationTimerChatUpdate) -> Bool {
    if lhs.expiresInMs != rhs.expiresInMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_ProfileChangeChatUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProfileChangeChatUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "previousName"),
    2: .same(proto: "newName"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.previousName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.newName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.previousName.isEmpty {
      try visitor.visitSingularStringField(value: self.previousName, fieldNumber: 1)
    }
    if !self.newName.isEmpty {
      try visitor.visitSingularStringField(value: self.newName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_ProfileChangeChatUpdate, rhs: BackupProto_ProfileChangeChatUpdate) -> Bool {
    if lhs.previousName != rhs.previousName {return false}
    if lhs.newName != rhs.newName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_LearnedProfileChatUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LearnedProfileChatUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "e164"),
    2: .same(proto: "username"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.previousName != nil {try decoder.handleConflictingOneOf()}
          self.previousName = .e164(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.previousName != nil {try decoder.handleConflictingOneOf()}
          self.previousName = .username(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.previousName {
    case .e164?: try {
      guard case .e164(let v)? = self.previousName else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    }()
    case .username?: try {
      guard case .username(let v)? = self.previousName else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_LearnedProfileChatUpdate, rhs: BackupProto_LearnedProfileChatUpdate) -> Bool {
    if lhs.previousName != rhs.previousName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_ThreadMergeChatUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ThreadMergeChatUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "previousE164"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.previousE164) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.previousE164 != 0 {
      try visitor.visitSingularUInt64Field(value: self.previousE164, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_ThreadMergeChatUpdate, rhs: BackupProto_ThreadMergeChatUpdate) -> Bool {
    if lhs.previousE164 != rhs.previousE164 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_SessionSwitchoverChatUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SessionSwitchoverChatUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "e164"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.e164) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.e164 != 0 {
      try visitor.visitSingularUInt64Field(value: self.e164, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_SessionSwitchoverChatUpdate, rhs: BackupProto_SessionSwitchoverChatUpdate) -> Bool {
    if lhs.e164 != rhs.e164 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_GroupChangeChatUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupChangeChatUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.updates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.updates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.updates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_GroupChangeChatUpdate, rhs: BackupProto_GroupChangeChatUpdate) -> Bool {
    if lhs.updates != rhs.updates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_GroupChangeChatUpdate.Update: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_GroupChangeChatUpdate.protoMessageName + ".Update"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "genericGroupUpdate"),
    2: .same(proto: "groupCreationUpdate"),
    3: .same(proto: "groupNameUpdate"),
    4: .same(proto: "groupAvatarUpdate"),
    5: .same(proto: "groupDescriptionUpdate"),
    6: .same(proto: "groupMembershipAccessLevelChangeUpdate"),
    7: .same(proto: "groupAttributesAccessLevelChangeUpdate"),
    8: .same(proto: "groupAnnouncementOnlyChangeUpdate"),
    9: .same(proto: "groupAdminStatusUpdate"),
    10: .same(proto: "groupMemberLeftUpdate"),
    11: .same(proto: "groupMemberRemovedUpdate"),
    12: .same(proto: "selfInvitedToGroupUpdate"),
    13: .same(proto: "selfInvitedOtherUserToGroupUpdate"),
    14: .same(proto: "groupUnknownInviteeUpdate"),
    15: .same(proto: "groupInvitationAcceptedUpdate"),
    16: .same(proto: "groupInvitationDeclinedUpdate"),
    17: .same(proto: "groupMemberJoinedUpdate"),
    18: .same(proto: "groupMemberAddedUpdate"),
    19: .same(proto: "groupSelfInvitationRevokedUpdate"),
    20: .same(proto: "groupInvitationRevokedUpdate"),
    21: .same(proto: "groupJoinRequestUpdate"),
    22: .same(proto: "groupJoinRequestApprovalUpdate"),
    23: .same(proto: "groupJoinRequestCanceledUpdate"),
    24: .same(proto: "groupInviteLinkResetUpdate"),
    25: .same(proto: "groupInviteLinkEnabledUpdate"),
    26: .same(proto: "groupInviteLinkAdminApprovalUpdate"),
    27: .same(proto: "groupInviteLinkDisabledUpdate"),
    28: .same(proto: "groupMemberJoinedByLinkUpdate"),
    29: .same(proto: "groupV2MigrationUpdate"),
    30: .same(proto: "groupV2MigrationSelfInvitedUpdate"),
    31: .same(proto: "groupV2MigrationInvitedMembersUpdate"),
    32: .same(proto: "groupV2MigrationDroppedMembersUpdate"),
    33: .same(proto: "groupSequenceOfRequestsAndCancelsUpdate"),
    34: .same(proto: "groupExpirationTimerUpdate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: BackupProto_GenericGroupUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .genericGroupUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .genericGroupUpdate(v)
        }
      }()
      case 2: try {
        var v: BackupProto_GroupCreationUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .groupCreationUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .groupCreationUpdate(v)
        }
      }()
      case 3: try {
        var v: BackupProto_GroupNameUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .groupNameUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .groupNameUpdate(v)
        }
      }()
      case 4: try {
        var v: BackupProto_GroupAvatarUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .groupAvatarUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .groupAvatarUpdate(v)
        }
      }()
      case 5: try {
        var v: BackupProto_GroupDescriptionUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .groupDescriptionUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .groupDescriptionUpdate(v)
        }
      }()
      case 6: try {
        var v: BackupProto_GroupMembershipAccessLevelChangeUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .groupMembershipAccessLevelChangeUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .groupMembershipAccessLevelChangeUpdate(v)
        }
      }()
      case 7: try {
        var v: BackupProto_GroupAttributesAccessLevelChangeUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .groupAttributesAccessLevelChangeUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .groupAttributesAccessLevelChangeUpdate(v)
        }
      }()
      case 8: try {
        var v: BackupProto_GroupAnnouncementOnlyChangeUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .groupAnnouncementOnlyChangeUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .groupAnnouncementOnlyChangeUpdate(v)
        }
      }()
      case 9: try {
        var v: BackupProto_GroupAdminStatusUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .groupAdminStatusUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .groupAdminStatusUpdate(v)
        }
      }()
      case 10: try {
        var v: BackupProto_GroupMemberLeftUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .groupMemberLeftUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .groupMemberLeftUpdate(v)
        }
      }()
      case 11: try {
        var v: BackupProto_GroupMemberRemovedUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .groupMemberRemovedUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .groupMemberRemovedUpdate(v)
        }
      }()
      case 12: try {
        var v: BackupProto_SelfInvitedToGroupUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .selfInvitedToGroupUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .selfInvitedToGroupUpdate(v)
        }
      }()
      case 13: try {
        var v: BackupProto_SelfInvitedOtherUserToGroupUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .selfInvitedOtherUserToGroupUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .selfInvitedOtherUserToGroupUpdate(v)
        }
      }()
      case 14: try {
        var v: BackupProto_GroupUnknownInviteeUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .groupUnknownInviteeUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .groupUnknownInviteeUpdate(v)
        }
      }()
      case 15: try {
        var v: BackupProto_GroupInvitationAcceptedUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .groupInvitationAcceptedUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .groupInvitationAcceptedUpdate(v)
        }
      }()
      case 16: try {
        var v: BackupProto_GroupInvitationDeclinedUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .groupInvitationDeclinedUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .groupInvitationDeclinedUpdate(v)
        }
      }()
      case 17: try {
        var v: BackupProto_GroupMemberJoinedUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .groupMemberJoinedUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .groupMemberJoinedUpdate(v)
        }
      }()
      case 18: try {
        var v: BackupProto_GroupMemberAddedUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .groupMemberAddedUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .groupMemberAddedUpdate(v)
        }
      }()
      case 19: try {
        var v: BackupProto_GroupSelfInvitationRevokedUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .groupSelfInvitationRevokedUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .groupSelfInvitationRevokedUpdate(v)
        }
      }()
      case 20: try {
        var v: BackupProto_GroupInvitationRevokedUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .groupInvitationRevokedUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .groupInvitationRevokedUpdate(v)
        }
      }()
      case 21: try {
        var v: BackupProto_GroupJoinRequestUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .groupJoinRequestUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .groupJoinRequestUpdate(v)
        }
      }()
      case 22: try {
        var v: BackupProto_GroupJoinRequestApprovalUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .groupJoinRequestApprovalUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .groupJoinRequestApprovalUpdate(v)
        }
      }()
      case 23: try {
        var v: BackupProto_GroupJoinRequestCanceledUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .groupJoinRequestCanceledUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .groupJoinRequestCanceledUpdate(v)
        }
      }()
      case 24: try {
        var v: BackupProto_GroupInviteLinkResetUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .groupInviteLinkResetUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .groupInviteLinkResetUpdate(v)
        }
      }()
      case 25: try {
        var v: BackupProto_GroupInviteLinkEnabledUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .groupInviteLinkEnabledUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .groupInviteLinkEnabledUpdate(v)
        }
      }()
      case 26: try {
        var v: BackupProto_GroupInviteLinkAdminApprovalUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .groupInviteLinkAdminApprovalUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .groupInviteLinkAdminApprovalUpdate(v)
        }
      }()
      case 27: try {
        var v: BackupProto_GroupInviteLinkDisabledUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .groupInviteLinkDisabledUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .groupInviteLinkDisabledUpdate(v)
        }
      }()
      case 28: try {
        var v: BackupProto_GroupMemberJoinedByLinkUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .groupMemberJoinedByLinkUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .groupMemberJoinedByLinkUpdate(v)
        }
      }()
      case 29: try {
        var v: BackupProto_GroupV2MigrationUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .groupV2MigrationUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .groupV2MigrationUpdate(v)
        }
      }()
      case 30: try {
        var v: BackupProto_GroupV2MigrationSelfInvitedUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .groupV2MigrationSelfInvitedUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .groupV2MigrationSelfInvitedUpdate(v)
        }
      }()
      case 31: try {
        var v: BackupProto_GroupV2MigrationInvitedMembersUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .groupV2MigrationInvitedMembersUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .groupV2MigrationInvitedMembersUpdate(v)
        }
      }()
      case 32: try {
        var v: BackupProto_GroupV2MigrationDroppedMembersUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .groupV2MigrationDroppedMembersUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .groupV2MigrationDroppedMembersUpdate(v)
        }
      }()
      case 33: try {
        var v: BackupProto_GroupSequenceOfRequestsAndCancelsUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .groupSequenceOfRequestsAndCancelsUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .groupSequenceOfRequestsAndCancelsUpdate(v)
        }
      }()
      case 34: try {
        var v: BackupProto_GroupExpirationTimerUpdate?
        var hadOneofValue = false
        if let current = self.update {
          hadOneofValue = true
          if case .groupExpirationTimerUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.update = .groupExpirationTimerUpdate(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.update {
    case .genericGroupUpdate?: try {
      guard case .genericGroupUpdate(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .groupCreationUpdate?: try {
      guard case .groupCreationUpdate(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .groupNameUpdate?: try {
      guard case .groupNameUpdate(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .groupAvatarUpdate?: try {
      guard case .groupAvatarUpdate(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .groupDescriptionUpdate?: try {
      guard case .groupDescriptionUpdate(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .groupMembershipAccessLevelChangeUpdate?: try {
      guard case .groupMembershipAccessLevelChangeUpdate(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .groupAttributesAccessLevelChangeUpdate?: try {
      guard case .groupAttributesAccessLevelChangeUpdate(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .groupAnnouncementOnlyChangeUpdate?: try {
      guard case .groupAnnouncementOnlyChangeUpdate(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .groupAdminStatusUpdate?: try {
      guard case .groupAdminStatusUpdate(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .groupMemberLeftUpdate?: try {
      guard case .groupMemberLeftUpdate(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .groupMemberRemovedUpdate?: try {
      guard case .groupMemberRemovedUpdate(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .selfInvitedToGroupUpdate?: try {
      guard case .selfInvitedToGroupUpdate(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .selfInvitedOtherUserToGroupUpdate?: try {
      guard case .selfInvitedOtherUserToGroupUpdate(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .groupUnknownInviteeUpdate?: try {
      guard case .groupUnknownInviteeUpdate(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .groupInvitationAcceptedUpdate?: try {
      guard case .groupInvitationAcceptedUpdate(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .groupInvitationDeclinedUpdate?: try {
      guard case .groupInvitationDeclinedUpdate(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .groupMemberJoinedUpdate?: try {
      guard case .groupMemberJoinedUpdate(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .groupMemberAddedUpdate?: try {
      guard case .groupMemberAddedUpdate(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .groupSelfInvitationRevokedUpdate?: try {
      guard case .groupSelfInvitationRevokedUpdate(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .groupInvitationRevokedUpdate?: try {
      guard case .groupInvitationRevokedUpdate(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .groupJoinRequestUpdate?: try {
      guard case .groupJoinRequestUpdate(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .groupJoinRequestApprovalUpdate?: try {
      guard case .groupJoinRequestApprovalUpdate(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .groupJoinRequestCanceledUpdate?: try {
      guard case .groupJoinRequestCanceledUpdate(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .groupInviteLinkResetUpdate?: try {
      guard case .groupInviteLinkResetUpdate(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    case .groupInviteLinkEnabledUpdate?: try {
      guard case .groupInviteLinkEnabledUpdate(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case .groupInviteLinkAdminApprovalUpdate?: try {
      guard case .groupInviteLinkAdminApprovalUpdate(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
    }()
    case .groupInviteLinkDisabledUpdate?: try {
      guard case .groupInviteLinkDisabledUpdate(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
    }()
    case .groupMemberJoinedByLinkUpdate?: try {
      guard case .groupMemberJoinedByLinkUpdate(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
    }()
    case .groupV2MigrationUpdate?: try {
      guard case .groupV2MigrationUpdate(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
    }()
    case .groupV2MigrationSelfInvitedUpdate?: try {
      guard case .groupV2MigrationSelfInvitedUpdate(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case .groupV2MigrationInvitedMembersUpdate?: try {
      guard case .groupV2MigrationInvitedMembersUpdate(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }()
    case .groupV2MigrationDroppedMembersUpdate?: try {
      guard case .groupV2MigrationDroppedMembersUpdate(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
    }()
    case .groupSequenceOfRequestsAndCancelsUpdate?: try {
      guard case .groupSequenceOfRequestsAndCancelsUpdate(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
    }()
    case .groupExpirationTimerUpdate?: try {
      guard case .groupExpirationTimerUpdate(let v)? = self.update else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_GroupChangeChatUpdate.Update, rhs: BackupProto_GroupChangeChatUpdate.Update) -> Bool {
    if lhs.update != rhs.update {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_GenericGroupUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenericGroupUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updaterAci"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._updaterAci) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updaterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_GenericGroupUpdate, rhs: BackupProto_GenericGroupUpdate) -> Bool {
    if lhs._updaterAci != rhs._updaterAci {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_GroupCreationUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupCreationUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updaterAci"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._updaterAci) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updaterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_GroupCreationUpdate, rhs: BackupProto_GroupCreationUpdate) -> Bool {
    if lhs._updaterAci != rhs._updaterAci {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_GroupNameUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupNameUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updaterAci"),
    2: .same(proto: "newGroupName"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._updaterAci) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._newGroupName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updaterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._newGroupName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_GroupNameUpdate, rhs: BackupProto_GroupNameUpdate) -> Bool {
    if lhs._updaterAci != rhs._updaterAci {return false}
    if lhs._newGroupName != rhs._newGroupName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_GroupAvatarUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupAvatarUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updaterAci"),
    2: .same(proto: "wasRemoved"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._updaterAci) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.wasRemoved) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updaterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    if self.wasRemoved != false {
      try visitor.visitSingularBoolField(value: self.wasRemoved, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_GroupAvatarUpdate, rhs: BackupProto_GroupAvatarUpdate) -> Bool {
    if lhs._updaterAci != rhs._updaterAci {return false}
    if lhs.wasRemoved != rhs.wasRemoved {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_GroupDescriptionUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupDescriptionUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updaterAci"),
    2: .same(proto: "newDescription"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._updaterAci) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._newDescription) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updaterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._newDescription {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_GroupDescriptionUpdate, rhs: BackupProto_GroupDescriptionUpdate) -> Bool {
    if lhs._updaterAci != rhs._updaterAci {return false}
    if lhs._newDescription != rhs._newDescription {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_GroupMembershipAccessLevelChangeUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupMembershipAccessLevelChangeUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updaterAci"),
    2: .same(proto: "accessLevel"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._updaterAci) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.accessLevel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updaterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    if self.accessLevel != .unknown {
      try visitor.visitSingularEnumField(value: self.accessLevel, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_GroupMembershipAccessLevelChangeUpdate, rhs: BackupProto_GroupMembershipAccessLevelChangeUpdate) -> Bool {
    if lhs._updaterAci != rhs._updaterAci {return false}
    if lhs.accessLevel != rhs.accessLevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_GroupAttributesAccessLevelChangeUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupAttributesAccessLevelChangeUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updaterAci"),
    2: .same(proto: "accessLevel"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._updaterAci) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.accessLevel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updaterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    if self.accessLevel != .unknown {
      try visitor.visitSingularEnumField(value: self.accessLevel, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_GroupAttributesAccessLevelChangeUpdate, rhs: BackupProto_GroupAttributesAccessLevelChangeUpdate) -> Bool {
    if lhs._updaterAci != rhs._updaterAci {return false}
    if lhs.accessLevel != rhs.accessLevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_GroupAnnouncementOnlyChangeUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupAnnouncementOnlyChangeUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updaterAci"),
    2: .same(proto: "isAnnouncementOnly"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._updaterAci) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isAnnouncementOnly) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updaterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    if self.isAnnouncementOnly != false {
      try visitor.visitSingularBoolField(value: self.isAnnouncementOnly, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_GroupAnnouncementOnlyChangeUpdate, rhs: BackupProto_GroupAnnouncementOnlyChangeUpdate) -> Bool {
    if lhs._updaterAci != rhs._updaterAci {return false}
    if lhs.isAnnouncementOnly != rhs.isAnnouncementOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_GroupAdminStatusUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupAdminStatusUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updaterAci"),
    2: .same(proto: "memberAci"),
    3: .same(proto: "wasAdminStatusGranted"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._updaterAci) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.memberAci) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.wasAdminStatusGranted) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updaterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    if !self.memberAci.isEmpty {
      try visitor.visitSingularBytesField(value: self.memberAci, fieldNumber: 2)
    }
    if self.wasAdminStatusGranted != false {
      try visitor.visitSingularBoolField(value: self.wasAdminStatusGranted, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_GroupAdminStatusUpdate, rhs: BackupProto_GroupAdminStatusUpdate) -> Bool {
    if lhs._updaterAci != rhs._updaterAci {return false}
    if lhs.memberAci != rhs.memberAci {return false}
    if lhs.wasAdminStatusGranted != rhs.wasAdminStatusGranted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_GroupMemberLeftUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupMemberLeftUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "aci"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.aci) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.aci.isEmpty {
      try visitor.visitSingularBytesField(value: self.aci, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_GroupMemberLeftUpdate, rhs: BackupProto_GroupMemberLeftUpdate) -> Bool {
    if lhs.aci != rhs.aci {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_GroupMemberRemovedUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupMemberRemovedUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "removerAci"),
    2: .same(proto: "removedAci"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._removerAci) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.removedAci) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._removerAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    if !self.removedAci.isEmpty {
      try visitor.visitSingularBytesField(value: self.removedAci, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_GroupMemberRemovedUpdate, rhs: BackupProto_GroupMemberRemovedUpdate) -> Bool {
    if lhs._removerAci != rhs._removerAci {return false}
    if lhs.removedAci != rhs.removedAci {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_SelfInvitedToGroupUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SelfInvitedToGroupUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inviterAci"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._inviterAci) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._inviterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_SelfInvitedToGroupUpdate, rhs: BackupProto_SelfInvitedToGroupUpdate) -> Bool {
    if lhs._inviterAci != rhs._inviterAci {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_SelfInvitedOtherUserToGroupUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SelfInvitedOtherUserToGroupUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inviteeServiceId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.inviteeServiceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inviteeServiceID.isEmpty {
      try visitor.visitSingularBytesField(value: self.inviteeServiceID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_SelfInvitedOtherUserToGroupUpdate, rhs: BackupProto_SelfInvitedOtherUserToGroupUpdate) -> Bool {
    if lhs.inviteeServiceID != rhs.inviteeServiceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_GroupUnknownInviteeUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupUnknownInviteeUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inviterAci"),
    2: .same(proto: "inviteeCount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._inviterAci) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.inviteeCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._inviterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    if self.inviteeCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.inviteeCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_GroupUnknownInviteeUpdate, rhs: BackupProto_GroupUnknownInviteeUpdate) -> Bool {
    if lhs._inviterAci != rhs._inviterAci {return false}
    if lhs.inviteeCount != rhs.inviteeCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_GroupInvitationAcceptedUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupInvitationAcceptedUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inviterAci"),
    2: .same(proto: "newMemberAci"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._inviterAci) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.newMemberAci) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._inviterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    if !self.newMemberAci.isEmpty {
      try visitor.visitSingularBytesField(value: self.newMemberAci, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_GroupInvitationAcceptedUpdate, rhs: BackupProto_GroupInvitationAcceptedUpdate) -> Bool {
    if lhs._inviterAci != rhs._inviterAci {return false}
    if lhs.newMemberAci != rhs.newMemberAci {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_GroupInvitationDeclinedUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupInvitationDeclinedUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inviterAci"),
    2: .same(proto: "inviteeAci"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._inviterAci) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._inviteeAci) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._inviterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._inviteeAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_GroupInvitationDeclinedUpdate, rhs: BackupProto_GroupInvitationDeclinedUpdate) -> Bool {
    if lhs._inviterAci != rhs._inviterAci {return false}
    if lhs._inviteeAci != rhs._inviteeAci {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_GroupMemberJoinedUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupMemberJoinedUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "newMemberAci"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.newMemberAci) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.newMemberAci.isEmpty {
      try visitor.visitSingularBytesField(value: self.newMemberAci, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_GroupMemberJoinedUpdate, rhs: BackupProto_GroupMemberJoinedUpdate) -> Bool {
    if lhs.newMemberAci != rhs.newMemberAci {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_GroupMemberAddedUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupMemberAddedUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updaterAci"),
    2: .same(proto: "newMemberAci"),
    3: .same(proto: "hadOpenInvitation"),
    4: .same(proto: "inviterAci"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._updaterAci) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.newMemberAci) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.hadOpenInvitation) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._inviterAci) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updaterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    if !self.newMemberAci.isEmpty {
      try visitor.visitSingularBytesField(value: self.newMemberAci, fieldNumber: 2)
    }
    if self.hadOpenInvitation != false {
      try visitor.visitSingularBoolField(value: self.hadOpenInvitation, fieldNumber: 3)
    }
    try { if let v = self._inviterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_GroupMemberAddedUpdate, rhs: BackupProto_GroupMemberAddedUpdate) -> Bool {
    if lhs._updaterAci != rhs._updaterAci {return false}
    if lhs.newMemberAci != rhs.newMemberAci {return false}
    if lhs.hadOpenInvitation != rhs.hadOpenInvitation {return false}
    if lhs._inviterAci != rhs._inviterAci {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_GroupSelfInvitationRevokedUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupSelfInvitationRevokedUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "revokerAci"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._revokerAci) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._revokerAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_GroupSelfInvitationRevokedUpdate, rhs: BackupProto_GroupSelfInvitationRevokedUpdate) -> Bool {
    if lhs._revokerAci != rhs._revokerAci {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_GroupInvitationRevokedUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupInvitationRevokedUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updaterAci"),
    2: .same(proto: "invitees"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._updaterAci) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.invitees) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updaterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    if !self.invitees.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.invitees, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_GroupInvitationRevokedUpdate, rhs: BackupProto_GroupInvitationRevokedUpdate) -> Bool {
    if lhs._updaterAci != rhs._updaterAci {return false}
    if lhs.invitees != rhs.invitees {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_GroupInvitationRevokedUpdate.Invitee: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_GroupInvitationRevokedUpdate.protoMessageName + ".Invitee"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inviterAci"),
    2: .same(proto: "inviteeAci"),
    3: .same(proto: "inviteePni"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._inviterAci) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._inviteeAci) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._inviteePni) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._inviterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._inviteeAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._inviteePni {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_GroupInvitationRevokedUpdate.Invitee, rhs: BackupProto_GroupInvitationRevokedUpdate.Invitee) -> Bool {
    if lhs._inviterAci != rhs._inviterAci {return false}
    if lhs._inviteeAci != rhs._inviteeAci {return false}
    if lhs._inviteePni != rhs._inviteePni {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_GroupJoinRequestUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupJoinRequestUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "requestorAci"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.requestorAci) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestorAci.isEmpty {
      try visitor.visitSingularBytesField(value: self.requestorAci, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_GroupJoinRequestUpdate, rhs: BackupProto_GroupJoinRequestUpdate) -> Bool {
    if lhs.requestorAci != rhs.requestorAci {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_GroupJoinRequestApprovalUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupJoinRequestApprovalUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "requestorAci"),
    2: .same(proto: "updaterAci"),
    3: .same(proto: "wasApproved"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.requestorAci) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._updaterAci) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.wasApproved) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.requestorAci.isEmpty {
      try visitor.visitSingularBytesField(value: self.requestorAci, fieldNumber: 1)
    }
    try { if let v = self._updaterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    if self.wasApproved != false {
      try visitor.visitSingularBoolField(value: self.wasApproved, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_GroupJoinRequestApprovalUpdate, rhs: BackupProto_GroupJoinRequestApprovalUpdate) -> Bool {
    if lhs.requestorAci != rhs.requestorAci {return false}
    if lhs._updaterAci != rhs._updaterAci {return false}
    if lhs.wasApproved != rhs.wasApproved {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_GroupJoinRequestCanceledUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupJoinRequestCanceledUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "requestorAci"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.requestorAci) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestorAci.isEmpty {
      try visitor.visitSingularBytesField(value: self.requestorAci, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_GroupJoinRequestCanceledUpdate, rhs: BackupProto_GroupJoinRequestCanceledUpdate) -> Bool {
    if lhs.requestorAci != rhs.requestorAci {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_GroupSequenceOfRequestsAndCancelsUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupSequenceOfRequestsAndCancelsUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "requestorAci"),
    2: .same(proto: "count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.requestorAci) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.count) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestorAci.isEmpty {
      try visitor.visitSingularBytesField(value: self.requestorAci, fieldNumber: 1)
    }
    if self.count != 0 {
      try visitor.visitSingularUInt32Field(value: self.count, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_GroupSequenceOfRequestsAndCancelsUpdate, rhs: BackupProto_GroupSequenceOfRequestsAndCancelsUpdate) -> Bool {
    if lhs.requestorAci != rhs.requestorAci {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_GroupInviteLinkResetUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupInviteLinkResetUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updaterAci"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._updaterAci) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updaterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_GroupInviteLinkResetUpdate, rhs: BackupProto_GroupInviteLinkResetUpdate) -> Bool {
    if lhs._updaterAci != rhs._updaterAci {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_GroupInviteLinkEnabledUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupInviteLinkEnabledUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updaterAci"),
    2: .same(proto: "linkRequiresAdminApproval"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._updaterAci) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.linkRequiresAdminApproval) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updaterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    if self.linkRequiresAdminApproval != false {
      try visitor.visitSingularBoolField(value: self.linkRequiresAdminApproval, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_GroupInviteLinkEnabledUpdate, rhs: BackupProto_GroupInviteLinkEnabledUpdate) -> Bool {
    if lhs._updaterAci != rhs._updaterAci {return false}
    if lhs.linkRequiresAdminApproval != rhs.linkRequiresAdminApproval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_GroupInviteLinkAdminApprovalUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupInviteLinkAdminApprovalUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updaterAci"),
    2: .same(proto: "linkRequiresAdminApproval"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._updaterAci) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.linkRequiresAdminApproval) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updaterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    if self.linkRequiresAdminApproval != false {
      try visitor.visitSingularBoolField(value: self.linkRequiresAdminApproval, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_GroupInviteLinkAdminApprovalUpdate, rhs: BackupProto_GroupInviteLinkAdminApprovalUpdate) -> Bool {
    if lhs._updaterAci != rhs._updaterAci {return false}
    if lhs.linkRequiresAdminApproval != rhs.linkRequiresAdminApproval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_GroupInviteLinkDisabledUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupInviteLinkDisabledUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "updaterAci"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._updaterAci) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updaterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_GroupInviteLinkDisabledUpdate, rhs: BackupProto_GroupInviteLinkDisabledUpdate) -> Bool {
    if lhs._updaterAci != rhs._updaterAci {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_GroupMemberJoinedByLinkUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupMemberJoinedByLinkUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "newMemberAci"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.newMemberAci) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.newMemberAci.isEmpty {
      try visitor.visitSingularBytesField(value: self.newMemberAci, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_GroupMemberJoinedByLinkUpdate, rhs: BackupProto_GroupMemberJoinedByLinkUpdate) -> Bool {
    if lhs.newMemberAci != rhs.newMemberAci {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_GroupV2MigrationUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupV2MigrationUpdate"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_GroupV2MigrationUpdate, rhs: BackupProto_GroupV2MigrationUpdate) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_GroupV2MigrationSelfInvitedUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupV2MigrationSelfInvitedUpdate"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_GroupV2MigrationSelfInvitedUpdate, rhs: BackupProto_GroupV2MigrationSelfInvitedUpdate) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_GroupV2MigrationInvitedMembersUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupV2MigrationInvitedMembersUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "invitedMembersCount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.invitedMembersCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.invitedMembersCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.invitedMembersCount, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_GroupV2MigrationInvitedMembersUpdate, rhs: BackupProto_GroupV2MigrationInvitedMembersUpdate) -> Bool {
    if lhs.invitedMembersCount != rhs.invitedMembersCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_GroupV2MigrationDroppedMembersUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupV2MigrationDroppedMembersUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "droppedMembersCount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.droppedMembersCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.droppedMembersCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.droppedMembersCount, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_GroupV2MigrationDroppedMembersUpdate, rhs: BackupProto_GroupV2MigrationDroppedMembersUpdate) -> Bool {
    if lhs.droppedMembersCount != rhs.droppedMembersCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_GroupExpirationTimerUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupExpirationTimerUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "expiresInMs"),
    2: .same(proto: "updaterAci"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.expiresInMs) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._updaterAci) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.expiresInMs != 0 {
      try visitor.visitSingularUInt64Field(value: self.expiresInMs, fieldNumber: 1)
    }
    try { if let v = self._updaterAci {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_GroupExpirationTimerUpdate, rhs: BackupProto_GroupExpirationTimerUpdate) -> Bool {
    if lhs.expiresInMs != rhs.expiresInMs {return false}
    if lhs._updaterAci != rhs._updaterAci {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_StickerPack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StickerPack"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "packId"),
    2: .same(proto: "packKey"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.packID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.packKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.packID.isEmpty {
      try visitor.visitSingularBytesField(value: self.packID, fieldNumber: 1)
    }
    if !self.packKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.packKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_StickerPack, rhs: BackupProto_StickerPack) -> Bool {
    if lhs.packID != rhs.packID {return false}
    if lhs.packKey != rhs.packKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_ChatStyle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatStyle"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "wallpaperPreset"),
    2: .same(proto: "wallpaperPhoto"),
    3: .same(proto: "autoBubbleColor"),
    4: .same(proto: "bubbleColorPreset"),
    5: .same(proto: "customColorId"),
    7: .same(proto: "dimWallpaperInDarkMode"),
  ]

  fileprivate class _StorageClass {
    var _wallpaper: BackupProto_ChatStyle.OneOf_Wallpaper?
    var _bubbleColor: BackupProto_ChatStyle.OneOf_BubbleColor?
    var _dimWallpaperInDarkMode: Bool = false

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _wallpaper = source._wallpaper
      _bubbleColor = source._bubbleColor
      _dimWallpaperInDarkMode = source._dimWallpaperInDarkMode
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try {
          var v: BackupProto_ChatStyle.WallpaperPreset?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {
            if _storage._wallpaper != nil {try decoder.handleConflictingOneOf()}
            _storage._wallpaper = .wallpaperPreset(v)
          }
        }()
        case 2: try {
          var v: BackupProto_FilePointer?
          var hadOneofValue = false
          if let current = _storage._wallpaper {
            hadOneofValue = true
            if case .wallpaperPhoto(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._wallpaper = .wallpaperPhoto(v)
          }
        }()
        case 3: try {
          var v: BackupProto_ChatStyle.AutomaticBubbleColor?
          var hadOneofValue = false
          if let current = _storage._bubbleColor {
            hadOneofValue = true
            if case .autoBubbleColor(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._bubbleColor = .autoBubbleColor(v)
          }
        }()
        case 4: try {
          var v: BackupProto_ChatStyle.BubbleColorPreset?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {
            if _storage._bubbleColor != nil {try decoder.handleConflictingOneOf()}
            _storage._bubbleColor = .bubbleColorPreset(v)
          }
        }()
        case 5: try {
          var v: UInt64?
          try decoder.decodeSingularUInt64Field(value: &v)
          if let v = v {
            if _storage._bubbleColor != nil {try decoder.handleConflictingOneOf()}
            _storage._bubbleColor = .customColorID(v)
          }
        }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._dimWallpaperInDarkMode) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      switch _storage._wallpaper {
      case .wallpaperPreset?: try {
        guard case .wallpaperPreset(let v)? = _storage._wallpaper else { preconditionFailure() }
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      }()
      case .wallpaperPhoto?: try {
        guard case .wallpaperPhoto(let v)? = _storage._wallpaper else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case nil: break
      }
      switch _storage._bubbleColor {
      case .autoBubbleColor?: try {
        guard case .autoBubbleColor(let v)? = _storage._bubbleColor else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .bubbleColorPreset?: try {
        guard case .bubbleColorPreset(let v)? = _storage._bubbleColor else { preconditionFailure() }
        try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
      }()
      case .customColorID?: try {
        guard case .customColorID(let v)? = _storage._bubbleColor else { preconditionFailure() }
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
      }()
      case nil: break
      }
      if _storage._dimWallpaperInDarkMode != false {
        try visitor.visitSingularBoolField(value: _storage._dimWallpaperInDarkMode, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_ChatStyle, rhs: BackupProto_ChatStyle) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._wallpaper != rhs_storage._wallpaper {return false}
        if _storage._bubbleColor != rhs_storage._bubbleColor {return false}
        if _storage._dimWallpaperInDarkMode != rhs_storage._dimWallpaperInDarkMode {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_ChatStyle.WallpaperPreset: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_WALLPAPER_PRESET"),
    1: .same(proto: "SOLID_BLUSH"),
    2: .same(proto: "SOLID_COPPER"),
    3: .same(proto: "SOLID_DUST"),
    4: .same(proto: "SOLID_CELADON"),
    5: .same(proto: "SOLID_RAINFOREST"),
    6: .same(proto: "SOLID_PACIFIC"),
    7: .same(proto: "SOLID_FROST"),
    8: .same(proto: "SOLID_NAVY"),
    9: .same(proto: "SOLID_LILAC"),
    10: .same(proto: "SOLID_PINK"),
    11: .same(proto: "SOLID_EGGPLANT"),
    12: .same(proto: "SOLID_SILVER"),
    13: .same(proto: "GRADIENT_SUNSET"),
    14: .same(proto: "GRADIENT_NOIR"),
    15: .same(proto: "GRADIENT_HEATMAP"),
    16: .same(proto: "GRADIENT_AQUA"),
    17: .same(proto: "GRADIENT_IRIDESCENT"),
    18: .same(proto: "GRADIENT_MONSTERA"),
    19: .same(proto: "GRADIENT_BLISS"),
    20: .same(proto: "GRADIENT_SKY"),
    21: .same(proto: "GRADIENT_PEACH"),
  ]
}

extension BackupProto_ChatStyle.BubbleColorPreset: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_BUBBLE_COLOR_PRESET"),
    1: .same(proto: "SOLID_ULTRAMARINE"),
    2: .same(proto: "SOLID_CRIMSON"),
    3: .same(proto: "SOLID_VERMILION"),
    4: .same(proto: "SOLID_BURLAP"),
    5: .same(proto: "SOLID_FOREST"),
    6: .same(proto: "SOLID_WINTERGREEN"),
    7: .same(proto: "SOLID_TEAL"),
    8: .same(proto: "SOLID_BLUE"),
    9: .same(proto: "SOLID_INDIGO"),
    10: .same(proto: "SOLID_VIOLET"),
    11: .same(proto: "SOLID_PLUM"),
    12: .same(proto: "SOLID_TAUPE"),
    13: .same(proto: "SOLID_STEEL"),
    14: .same(proto: "GRADIENT_EMBER"),
    15: .same(proto: "GRADIENT_MIDNIGHT"),
    16: .same(proto: "GRADIENT_INFRARED"),
    17: .same(proto: "GRADIENT_LAGOON"),
    18: .same(proto: "GRADIENT_FLUORESCENT"),
    19: .same(proto: "GRADIENT_BASIL"),
    20: .same(proto: "GRADIENT_SUBLIME"),
    21: .same(proto: "GRADIENT_SEA"),
    22: .same(proto: "GRADIENT_TANGERINE"),
  ]
}

extension BackupProto_ChatStyle.Gradient: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_ChatStyle.protoMessageName + ".Gradient"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "angle"),
    2: .same(proto: "colors"),
    3: .same(proto: "positions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.angle) }()
      case 2: try { try decoder.decodeRepeatedFixed32Field(value: &self.colors) }()
      case 3: try { try decoder.decodeRepeatedFloatField(value: &self.positions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.angle != 0 {
      try visitor.visitSingularUInt32Field(value: self.angle, fieldNumber: 1)
    }
    if !self.colors.isEmpty {
      try visitor.visitPackedFixed32Field(value: self.colors, fieldNumber: 2)
    }
    if !self.positions.isEmpty {
      try visitor.visitPackedFloatField(value: self.positions, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_ChatStyle.Gradient, rhs: BackupProto_ChatStyle.Gradient) -> Bool {
    if lhs.angle != rhs.angle {return false}
    if lhs.colors != rhs.colors {return false}
    if lhs.positions != rhs.positions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_ChatStyle.CustomChatColor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_ChatStyle.protoMessageName + ".CustomChatColor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "solid"),
    3: .same(proto: "gradient"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try {
        var v: UInt32?
        try decoder.decodeSingularFixed32Field(value: &v)
        if let v = v {
          if self.color != nil {try decoder.handleConflictingOneOf()}
          self.color = .solid(v)
        }
      }()
      case 3: try {
        var v: BackupProto_ChatStyle.Gradient?
        var hadOneofValue = false
        if let current = self.color {
          hadOneofValue = true
          if case .gradient(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.color = .gradient(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    switch self.color {
    case .solid?: try {
      guard case .solid(let v)? = self.color else { preconditionFailure() }
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    }()
    case .gradient?: try {
      guard case .gradient(let v)? = self.color else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_ChatStyle.CustomChatColor, rhs: BackupProto_ChatStyle.CustomChatColor) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.color != rhs.color {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_ChatStyle.AutomaticBubbleColor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BackupProto_ChatStyle.protoMessageName + ".AutomaticBubbleColor"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_ChatStyle.AutomaticBubbleColor, rhs: BackupProto_ChatStyle.AutomaticBubbleColor) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_NotificationProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NotificationProfile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "emoji"),
    3: .same(proto: "color"),
    4: .same(proto: "createdAtMs"),
    5: .same(proto: "allowAllCalls"),
    6: .same(proto: "allowAllMentions"),
    7: .same(proto: "allowedMembers"),
    8: .same(proto: "scheduleEnabled"),
    9: .same(proto: "scheduleStartTime"),
    10: .same(proto: "scheduleEndTime"),
    11: .same(proto: "scheduleDaysEnabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._emoji) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self.color) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.createdAtMs) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.allowAllCalls) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.allowAllMentions) }()
      case 7: try { try decoder.decodeRepeatedUInt64Field(value: &self.allowedMembers) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.scheduleEnabled) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.scheduleStartTime) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self.scheduleEndTime) }()
      case 11: try { try decoder.decodeRepeatedEnumField(value: &self.scheduleDaysEnabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._emoji {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if self.color != 0 {
      try visitor.visitSingularFixed32Field(value: self.color, fieldNumber: 3)
    }
    if self.createdAtMs != 0 {
      try visitor.visitSingularUInt64Field(value: self.createdAtMs, fieldNumber: 4)
    }
    if self.allowAllCalls != false {
      try visitor.visitSingularBoolField(value: self.allowAllCalls, fieldNumber: 5)
    }
    if self.allowAllMentions != false {
      try visitor.visitSingularBoolField(value: self.allowAllMentions, fieldNumber: 6)
    }
    if !self.allowedMembers.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.allowedMembers, fieldNumber: 7)
    }
    if self.scheduleEnabled != false {
      try visitor.visitSingularBoolField(value: self.scheduleEnabled, fieldNumber: 8)
    }
    if self.scheduleStartTime != 0 {
      try visitor.visitSingularUInt32Field(value: self.scheduleStartTime, fieldNumber: 9)
    }
    if self.scheduleEndTime != 0 {
      try visitor.visitSingularUInt32Field(value: self.scheduleEndTime, fieldNumber: 10)
    }
    if !self.scheduleDaysEnabled.isEmpty {
      try visitor.visitPackedEnumField(value: self.scheduleDaysEnabled, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_NotificationProfile, rhs: BackupProto_NotificationProfile) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._emoji != rhs._emoji {return false}
    if lhs.color != rhs.color {return false}
    if lhs.createdAtMs != rhs.createdAtMs {return false}
    if lhs.allowAllCalls != rhs.allowAllCalls {return false}
    if lhs.allowAllMentions != rhs.allowAllMentions {return false}
    if lhs.allowedMembers != rhs.allowedMembers {return false}
    if lhs.scheduleEnabled != rhs.scheduleEnabled {return false}
    if lhs.scheduleStartTime != rhs.scheduleStartTime {return false}
    if lhs.scheduleEndTime != rhs.scheduleEndTime {return false}
    if lhs.scheduleDaysEnabled != rhs.scheduleDaysEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_NotificationProfile.DayOfWeek: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "MONDAY"),
    2: .same(proto: "TUESDAY"),
    3: .same(proto: "WEDNESDAY"),
    4: .same(proto: "THURSDAY"),
    5: .same(proto: "FRIDAY"),
    6: .same(proto: "SATURDAY"),
    7: .same(proto: "SUNDAY"),
  ]
}

extension BackupProto_ChatFolder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatFolder"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "showOnlyUnread"),
    3: .same(proto: "showMutedChats"),
    4: .same(proto: "includeAllIndividualChats"),
    5: .same(proto: "includeAllGroupChats"),
    6: .same(proto: "folderType"),
    7: .same(proto: "includedRecipientIds"),
    8: .same(proto: "excludedRecipientIds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.showOnlyUnread) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.showMutedChats) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.includeAllIndividualChats) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.includeAllGroupChats) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.folderType) }()
      case 7: try { try decoder.decodeRepeatedUInt64Field(value: &self.includedRecipientIds) }()
      case 8: try { try decoder.decodeRepeatedUInt64Field(value: &self.excludedRecipientIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.showOnlyUnread != false {
      try visitor.visitSingularBoolField(value: self.showOnlyUnread, fieldNumber: 2)
    }
    if self.showMutedChats != false {
      try visitor.visitSingularBoolField(value: self.showMutedChats, fieldNumber: 3)
    }
    if self.includeAllIndividualChats != false {
      try visitor.visitSingularBoolField(value: self.includeAllIndividualChats, fieldNumber: 4)
    }
    if self.includeAllGroupChats != false {
      try visitor.visitSingularBoolField(value: self.includeAllGroupChats, fieldNumber: 5)
    }
    if self.folderType != .unknown {
      try visitor.visitSingularEnumField(value: self.folderType, fieldNumber: 6)
    }
    if !self.includedRecipientIds.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.includedRecipientIds, fieldNumber: 7)
    }
    if !self.excludedRecipientIds.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.excludedRecipientIds, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BackupProto_ChatFolder, rhs: BackupProto_ChatFolder) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.showOnlyUnread != rhs.showOnlyUnread {return false}
    if lhs.showMutedChats != rhs.showMutedChats {return false}
    if lhs.includeAllIndividualChats != rhs.includeAllIndividualChats {return false}
    if lhs.includeAllGroupChats != rhs.includeAllGroupChats {return false}
    if lhs.folderType != rhs.folderType {return false}
    if lhs.includedRecipientIds != rhs.includedRecipientIds {return false}
    if lhs.excludedRecipientIds != rhs.excludedRecipientIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BackupProto_ChatFolder.FolderType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "ALL"),
    2: .same(proto: "CUSTOM"),
  ]
}
