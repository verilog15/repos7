//
// Copyright 2018 Signal Messenger, LLC
// SPDX-License-Identifier: AGPL-3.0-only
//

// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: SignalService.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
// Copyright 2014 Signal Messenger, LLC
// SPDX-License-Identifier: AGPL-3.0-only

/// iOS - since we use a modern proto-compiler, we must specify
/// the legacy proto format.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct SignalServiceProtos_Envelope: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: SignalServiceProtos_Envelope.TypeEnum {
    get {return _type ?? .unknown}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var sourceDevice: UInt32 {
    get {return _sourceDevice ?? 0}
    set {_sourceDevice = newValue}
  }
  /// Returns true if `sourceDevice` has been explicitly set.
  var hasSourceDevice: Bool {return self._sourceDevice != nil}
  /// Clears the value of `sourceDevice`. Subsequent reads from it will return its default value.
  mutating func clearSourceDevice() {self._sourceDevice = nil}

  var destinationServiceID: String {
    get {return _destinationServiceID ?? String()}
    set {_destinationServiceID = newValue}
  }
  /// Returns true if `destinationServiceID` has been explicitly set.
  var hasDestinationServiceID: Bool {return self._destinationServiceID != nil}
  /// Clears the value of `destinationServiceID`. Subsequent reads from it will return its default value.
  mutating func clearDestinationServiceID() {self._destinationServiceID = nil}

  /// @required
  var timestamp: UInt64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  /// Contains an encrypted Content
  var content: Data {
    get {return _content ?? Data()}
    set {_content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  var hasContent: Bool {return self._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  mutating func clearContent() {self._content = nil}

  /// We may eventually want to make this required.
  var serverGuid: String {
    get {return _serverGuid ?? String()}
    set {_serverGuid = newValue}
  }
  /// Returns true if `serverGuid` has been explicitly set.
  var hasServerGuid: Bool {return self._serverGuid != nil}
  /// Clears the value of `serverGuid`. Subsequent reads from it will return its default value.
  mutating func clearServerGuid() {self._serverGuid = nil}

  /// We may eventually want to make this required.
  var serverTimestamp: UInt64 {
    get {return _serverTimestamp ?? 0}
    set {_serverTimestamp = newValue}
  }
  /// Returns true if `serverTimestamp` has been explicitly set.
  var hasServerTimestamp: Bool {return self._serverTimestamp != nil}
  /// Clears the value of `serverTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearServerTimestamp() {self._serverTimestamp = nil}

  var sourceServiceID: String {
    get {return _sourceServiceID ?? String()}
    set {_sourceServiceID = newValue}
  }
  /// Returns true if `sourceServiceID` has been explicitly set.
  var hasSourceServiceID: Bool {return self._sourceServiceID != nil}
  /// Clears the value of `sourceServiceID`. Subsequent reads from it will return its default value.
  mutating func clearSourceServiceID() {self._sourceServiceID = nil}

  /// On change-number sync messages delivered to linked devices, this will
  /// contain the account's new PNI.
  var updatedPni: String {
    get {return _updatedPni ?? String()}
    set {_updatedPni = newValue}
  }
  /// Returns true if `updatedPni` has been explicitly set.
  var hasUpdatedPni: Bool {return self._updatedPni != nil}
  /// Clears the value of `updatedPni`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedPni() {self._updatedPni = nil}

  var story: Bool {
    get {return _story ?? false}
    set {_story = newValue}
  }
  /// Returns true if `story` has been explicitly set.
  var hasStory: Bool {return self._story != nil}
  /// Clears the value of `story`. Subsequent reads from it will return its default value.
  mutating func clearStory() {self._story = nil}

  var spamReportingToken: Data {
    get {return _spamReportingToken ?? Data()}
    set {_spamReportingToken = newValue}
  }
  /// Returns true if `spamReportingToken` has been explicitly set.
  var hasSpamReportingToken: Bool {return self._spamReportingToken != nil}
  /// Clears the value of `spamReportingToken`. Subsequent reads from it will return its default value.
  mutating func clearSpamReportingToken() {self._spamReportingToken = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case unknown = 0
    case ciphertext = 1
    case prekeyBundle = 3
    case receipt = 5
    case unidentifiedSender = 6
    case plaintextContent = 8

    init() {
      self = .unknown
    }

  }

  init() {}

  fileprivate var _type: SignalServiceProtos_Envelope.TypeEnum? = nil
  fileprivate var _sourceDevice: UInt32? = nil
  fileprivate var _destinationServiceID: String? = nil
  fileprivate var _timestamp: UInt64? = nil
  fileprivate var _content: Data? = nil
  fileprivate var _serverGuid: String? = nil
  fileprivate var _serverTimestamp: UInt64? = nil
  fileprivate var _sourceServiceID: String? = nil
  fileprivate var _updatedPni: String? = nil
  fileprivate var _story: Bool? = nil
  fileprivate var _spamReportingToken: Data? = nil
}

struct SignalServiceProtos_TypingMessage: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var timestamp: UInt64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var action: SignalServiceProtos_TypingMessage.Action {
    get {return _action ?? .started}
    set {_action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  var hasAction: Bool {return self._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  mutating func clearAction() {self._action = nil}

  var groupID: Data {
    get {return _groupID ?? Data()}
    set {_groupID = newValue}
  }
  /// Returns true if `groupID` has been explicitly set.
  var hasGroupID: Bool {return self._groupID != nil}
  /// Clears the value of `groupID`. Subsequent reads from it will return its default value.
  mutating func clearGroupID() {self._groupID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Action: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case started = 0
    case stopped = 1

    init() {
      self = .started
    }

  }

  init() {}

  fileprivate var _timestamp: UInt64? = nil
  fileprivate var _action: SignalServiceProtos_TypingMessage.Action? = nil
  fileprivate var _groupID: Data? = nil
}

struct SignalServiceProtos_StoryMessage: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var profileKey: Data {
    get {return _storage._profileKey ?? Data()}
    set {_uniqueStorage()._profileKey = newValue}
  }
  /// Returns true if `profileKey` has been explicitly set.
  var hasProfileKey: Bool {return _storage._profileKey != nil}
  /// Clears the value of `profileKey`. Subsequent reads from it will return its default value.
  mutating func clearProfileKey() {_uniqueStorage()._profileKey = nil}

  var group: SignalServiceProtos_GroupContextV2 {
    get {return _storage._group ?? SignalServiceProtos_GroupContextV2()}
    set {_uniqueStorage()._group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  var hasGroup: Bool {return _storage._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  mutating func clearGroup() {_uniqueStorage()._group = nil}

  /// oneof attachment {
  var fileAttachment: SignalServiceProtos_AttachmentPointer {
    get {return _storage._fileAttachment ?? SignalServiceProtos_AttachmentPointer()}
    set {_uniqueStorage()._fileAttachment = newValue}
  }
  /// Returns true if `fileAttachment` has been explicitly set.
  var hasFileAttachment: Bool {return _storage._fileAttachment != nil}
  /// Clears the value of `fileAttachment`. Subsequent reads from it will return its default value.
  mutating func clearFileAttachment() {_uniqueStorage()._fileAttachment = nil}

  var textAttachment: SignalServiceProtos_TextAttachment {
    get {return _storage._textAttachment ?? SignalServiceProtos_TextAttachment()}
    set {_uniqueStorage()._textAttachment = newValue}
  }
  /// Returns true if `textAttachment` has been explicitly set.
  var hasTextAttachment: Bool {return _storage._textAttachment != nil}
  /// Clears the value of `textAttachment`. Subsequent reads from it will return its default value.
  mutating func clearTextAttachment() {_uniqueStorage()._textAttachment = nil}

  /// }
  var allowsReplies: Bool {
    get {return _storage._allowsReplies ?? false}
    set {_uniqueStorage()._allowsReplies = newValue}
  }
  /// Returns true if `allowsReplies` has been explicitly set.
  var hasAllowsReplies: Bool {return _storage._allowsReplies != nil}
  /// Clears the value of `allowsReplies`. Subsequent reads from it will return its default value.
  mutating func clearAllowsReplies() {_uniqueStorage()._allowsReplies = nil}

  var bodyRanges: [SignalServiceProtos_BodyRange] {
    get {return _storage._bodyRanges}
    set {_uniqueStorage()._bodyRanges = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SignalServiceProtos_Preview: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var url: String {
    get {return _storage._url ?? String()}
    set {_uniqueStorage()._url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  var hasURL: Bool {return _storage._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  mutating func clearURL() {_uniqueStorage()._url = nil}

  var title: String {
    get {return _storage._title ?? String()}
    set {_uniqueStorage()._title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  var hasTitle: Bool {return _storage._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  mutating func clearTitle() {_uniqueStorage()._title = nil}

  var image: SignalServiceProtos_AttachmentPointer {
    get {return _storage._image ?? SignalServiceProtos_AttachmentPointer()}
    set {_uniqueStorage()._image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  var hasImage: Bool {return _storage._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  mutating func clearImage() {_uniqueStorage()._image = nil}

  var previewDescription: String {
    get {return _storage._previewDescription ?? String()}
    set {_uniqueStorage()._previewDescription = newValue}
  }
  /// Returns true if `previewDescription` has been explicitly set.
  var hasPreviewDescription: Bool {return _storage._previewDescription != nil}
  /// Clears the value of `previewDescription`. Subsequent reads from it will return its default value.
  mutating func clearPreviewDescription() {_uniqueStorage()._previewDescription = nil}

  var date: UInt64 {
    get {return _storage._date ?? 0}
    set {_uniqueStorage()._date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  var hasDate: Bool {return _storage._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  mutating func clearDate() {_uniqueStorage()._date = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SignalServiceProtos_TextAttachment: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var text: String {
    get {return _text ?? String()}
    set {_text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  var hasText: Bool {return self._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  mutating func clearText() {self._text = nil}

  var textStyle: SignalServiceProtos_TextAttachment.Style {
    get {return _textStyle ?? .default}
    set {_textStyle = newValue}
  }
  /// Returns true if `textStyle` has been explicitly set.
  var hasTextStyle: Bool {return self._textStyle != nil}
  /// Clears the value of `textStyle`. Subsequent reads from it will return its default value.
  mutating func clearTextStyle() {self._textStyle = nil}

  /// integer representation of hex color
  var textForegroundColor: UInt32 {
    get {return _textForegroundColor ?? 0}
    set {_textForegroundColor = newValue}
  }
  /// Returns true if `textForegroundColor` has been explicitly set.
  var hasTextForegroundColor: Bool {return self._textForegroundColor != nil}
  /// Clears the value of `textForegroundColor`. Subsequent reads from it will return its default value.
  mutating func clearTextForegroundColor() {self._textForegroundColor = nil}

  var textBackgroundColor: UInt32 {
    get {return _textBackgroundColor ?? 0}
    set {_textBackgroundColor = newValue}
  }
  /// Returns true if `textBackgroundColor` has been explicitly set.
  var hasTextBackgroundColor: Bool {return self._textBackgroundColor != nil}
  /// Clears the value of `textBackgroundColor`. Subsequent reads from it will return its default value.
  mutating func clearTextBackgroundColor() {self._textBackgroundColor = nil}

  var preview: SignalServiceProtos_Preview {
    get {return _preview ?? SignalServiceProtos_Preview()}
    set {_preview = newValue}
  }
  /// Returns true if `preview` has been explicitly set.
  var hasPreview: Bool {return self._preview != nil}
  /// Clears the value of `preview`. Subsequent reads from it will return its default value.
  mutating func clearPreview() {self._preview = nil}

  /// oneof background {
  var gradient: SignalServiceProtos_TextAttachment.Gradient {
    get {return _gradient ?? SignalServiceProtos_TextAttachment.Gradient()}
    set {_gradient = newValue}
  }
  /// Returns true if `gradient` has been explicitly set.
  var hasGradient: Bool {return self._gradient != nil}
  /// Clears the value of `gradient`. Subsequent reads from it will return its default value.
  mutating func clearGradient() {self._gradient = nil}

  /// }
  var color: UInt32 {
    get {return _color ?? 0}
    set {_color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  var hasColor: Bool {return self._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  mutating func clearColor() {self._color = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Style: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case `default` = 0
    case regular = 1
    case bold = 2
    case serif = 3
    case script = 4
    case condensed = 5

    init() {
      self = .default
    }

  }

  struct Gradient: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// deprecated: this field will be removed in a future release.
    var startColor: UInt32 {
      get {return _startColor ?? 0}
      set {_startColor = newValue}
    }
    /// Returns true if `startColor` has been explicitly set.
    var hasStartColor: Bool {return self._startColor != nil}
    /// Clears the value of `startColor`. Subsequent reads from it will return its default value.
    mutating func clearStartColor() {self._startColor = nil}

    /// deprecated: this field will be removed in a future release.
    var endColor: UInt32 {
      get {return _endColor ?? 0}
      set {_endColor = newValue}
    }
    /// Returns true if `endColor` has been explicitly set.
    var hasEndColor: Bool {return self._endColor != nil}
    /// Clears the value of `endColor`. Subsequent reads from it will return its default value.
    mutating func clearEndColor() {self._endColor = nil}

    /// degrees
    var angle: UInt32 {
      get {return _angle ?? 0}
      set {_angle = newValue}
    }
    /// Returns true if `angle` has been explicitly set.
    var hasAngle: Bool {return self._angle != nil}
    /// Clears the value of `angle`. Subsequent reads from it will return its default value.
    mutating func clearAngle() {self._angle = nil}

    var colors: [UInt32] = []

    /// percent from 0 to 1
    var positions: [Float] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _startColor: UInt32? = nil
    fileprivate var _endColor: UInt32? = nil
    fileprivate var _angle: UInt32? = nil
  }

  init() {}

  fileprivate var _text: String? = nil
  fileprivate var _textStyle: SignalServiceProtos_TextAttachment.Style? = nil
  fileprivate var _textForegroundColor: UInt32? = nil
  fileprivate var _textBackgroundColor: UInt32? = nil
  fileprivate var _preview: SignalServiceProtos_Preview? = nil
  fileprivate var _gradient: SignalServiceProtos_TextAttachment.Gradient? = nil
  fileprivate var _color: UInt32? = nil
}

struct SignalServiceProtos_Content: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var dataMessage: SignalServiceProtos_DataMessage {
    get {return _storage._dataMessage ?? SignalServiceProtos_DataMessage()}
    set {_uniqueStorage()._dataMessage = newValue}
  }
  /// Returns true if `dataMessage` has been explicitly set.
  var hasDataMessage: Bool {return _storage._dataMessage != nil}
  /// Clears the value of `dataMessage`. Subsequent reads from it will return its default value.
  mutating func clearDataMessage() {_uniqueStorage()._dataMessage = nil}

  var syncMessage: SignalServiceProtos_SyncMessage {
    get {return _storage._syncMessage ?? SignalServiceProtos_SyncMessage()}
    set {_uniqueStorage()._syncMessage = newValue}
  }
  /// Returns true if `syncMessage` has been explicitly set.
  var hasSyncMessage: Bool {return _storage._syncMessage != nil}
  /// Clears the value of `syncMessage`. Subsequent reads from it will return its default value.
  mutating func clearSyncMessage() {_uniqueStorage()._syncMessage = nil}

  var callMessage: SignalServiceProtos_CallMessage {
    get {return _storage._callMessage ?? SignalServiceProtos_CallMessage()}
    set {_uniqueStorage()._callMessage = newValue}
  }
  /// Returns true if `callMessage` has been explicitly set.
  var hasCallMessage: Bool {return _storage._callMessage != nil}
  /// Clears the value of `callMessage`. Subsequent reads from it will return its default value.
  mutating func clearCallMessage() {_uniqueStorage()._callMessage = nil}

  var nullMessage: SignalServiceProtos_NullMessage {
    get {return _storage._nullMessage ?? SignalServiceProtos_NullMessage()}
    set {_uniqueStorage()._nullMessage = newValue}
  }
  /// Returns true if `nullMessage` has been explicitly set.
  var hasNullMessage: Bool {return _storage._nullMessage != nil}
  /// Clears the value of `nullMessage`. Subsequent reads from it will return its default value.
  mutating func clearNullMessage() {_uniqueStorage()._nullMessage = nil}

  var receiptMessage: SignalServiceProtos_ReceiptMessage {
    get {return _storage._receiptMessage ?? SignalServiceProtos_ReceiptMessage()}
    set {_uniqueStorage()._receiptMessage = newValue}
  }
  /// Returns true if `receiptMessage` has been explicitly set.
  var hasReceiptMessage: Bool {return _storage._receiptMessage != nil}
  /// Clears the value of `receiptMessage`. Subsequent reads from it will return its default value.
  mutating func clearReceiptMessage() {_uniqueStorage()._receiptMessage = nil}

  var typingMessage: SignalServiceProtos_TypingMessage {
    get {return _storage._typingMessage ?? SignalServiceProtos_TypingMessage()}
    set {_uniqueStorage()._typingMessage = newValue}
  }
  /// Returns true if `typingMessage` has been explicitly set.
  var hasTypingMessage: Bool {return _storage._typingMessage != nil}
  /// Clears the value of `typingMessage`. Subsequent reads from it will return its default value.
  mutating func clearTypingMessage() {_uniqueStorage()._typingMessage = nil}

  /// Serialized SKDM
  var senderKeyDistributionMessage: Data {
    get {return _storage._senderKeyDistributionMessage ?? Data()}
    set {_uniqueStorage()._senderKeyDistributionMessage = newValue}
  }
  /// Returns true if `senderKeyDistributionMessage` has been explicitly set.
  var hasSenderKeyDistributionMessage: Bool {return _storage._senderKeyDistributionMessage != nil}
  /// Clears the value of `senderKeyDistributionMessage`. Subsequent reads from it will return its default value.
  mutating func clearSenderKeyDistributionMessage() {_uniqueStorage()._senderKeyDistributionMessage = nil}

  /// Serialized decryption error
  var decryptionErrorMessage: Data {
    get {return _storage._decryptionErrorMessage ?? Data()}
    set {_uniqueStorage()._decryptionErrorMessage = newValue}
  }
  /// Returns true if `decryptionErrorMessage` has been explicitly set.
  var hasDecryptionErrorMessage: Bool {return _storage._decryptionErrorMessage != nil}
  /// Clears the value of `decryptionErrorMessage`. Subsequent reads from it will return its default value.
  mutating func clearDecryptionErrorMessage() {_uniqueStorage()._decryptionErrorMessage = nil}

  var storyMessage: SignalServiceProtos_StoryMessage {
    get {return _storage._storyMessage ?? SignalServiceProtos_StoryMessage()}
    set {_uniqueStorage()._storyMessage = newValue}
  }
  /// Returns true if `storyMessage` has been explicitly set.
  var hasStoryMessage: Bool {return _storage._storyMessage != nil}
  /// Clears the value of `storyMessage`. Subsequent reads from it will return its default value.
  mutating func clearStoryMessage() {_uniqueStorage()._storyMessage = nil}

  var pniSignatureMessage: SignalServiceProtos_PniSignatureMessage {
    get {return _storage._pniSignatureMessage ?? SignalServiceProtos_PniSignatureMessage()}
    set {_uniqueStorage()._pniSignatureMessage = newValue}
  }
  /// Returns true if `pniSignatureMessage` has been explicitly set.
  var hasPniSignatureMessage: Bool {return _storage._pniSignatureMessage != nil}
  /// Clears the value of `pniSignatureMessage`. Subsequent reads from it will return its default value.
  mutating func clearPniSignatureMessage() {_uniqueStorage()._pniSignatureMessage = nil}

  var editMessage: SignalServiceProtos_EditMessage {
    get {return _storage._editMessage ?? SignalServiceProtos_EditMessage()}
    set {_uniqueStorage()._editMessage = newValue}
  }
  /// Returns true if `editMessage` has been explicitly set.
  var hasEditMessage: Bool {return _storage._editMessage != nil}
  /// Clears the value of `editMessage`. Subsequent reads from it will return its default value.
  mutating func clearEditMessage() {_uniqueStorage()._editMessage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SignalServiceProtos_CallMessage: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var offer: SignalServiceProtos_CallMessage.Offer {
    get {return _offer ?? SignalServiceProtos_CallMessage.Offer()}
    set {_offer = newValue}
  }
  /// Returns true if `offer` has been explicitly set.
  var hasOffer: Bool {return self._offer != nil}
  /// Clears the value of `offer`. Subsequent reads from it will return its default value.
  mutating func clearOffer() {self._offer = nil}

  var answer: SignalServiceProtos_CallMessage.Answer {
    get {return _answer ?? SignalServiceProtos_CallMessage.Answer()}
    set {_answer = newValue}
  }
  /// Returns true if `answer` has been explicitly set.
  var hasAnswer: Bool {return self._answer != nil}
  /// Clears the value of `answer`. Subsequent reads from it will return its default value.
  mutating func clearAnswer() {self._answer = nil}

  var iceUpdate: [SignalServiceProtos_CallMessage.IceUpdate] = []

  var busy: SignalServiceProtos_CallMessage.Busy {
    get {return _busy ?? SignalServiceProtos_CallMessage.Busy()}
    set {_busy = newValue}
  }
  /// Returns true if `busy` has been explicitly set.
  var hasBusy: Bool {return self._busy != nil}
  /// Clears the value of `busy`. Subsequent reads from it will return its default value.
  mutating func clearBusy() {self._busy = nil}

  var profileKey: Data {
    get {return _profileKey ?? Data()}
    set {_profileKey = newValue}
  }
  /// Returns true if `profileKey` has been explicitly set.
  var hasProfileKey: Bool {return self._profileKey != nil}
  /// Clears the value of `profileKey`. Subsequent reads from it will return its default value.
  mutating func clearProfileKey() {self._profileKey = nil}

  var hangup: SignalServiceProtos_CallMessage.Hangup {
    get {return _hangup ?? SignalServiceProtos_CallMessage.Hangup()}
    set {_hangup = newValue}
  }
  /// Returns true if `hangup` has been explicitly set.
  var hasHangup: Bool {return self._hangup != nil}
  /// Clears the value of `hangup`. Subsequent reads from it will return its default value.
  mutating func clearHangup() {self._hangup = nil}

  var destinationDeviceID: UInt32 {
    get {return _destinationDeviceID ?? 0}
    set {_destinationDeviceID = newValue}
  }
  /// Returns true if `destinationDeviceID` has been explicitly set.
  var hasDestinationDeviceID: Bool {return self._destinationDeviceID != nil}
  /// Clears the value of `destinationDeviceID`. Subsequent reads from it will return its default value.
  mutating func clearDestinationDeviceID() {self._destinationDeviceID = nil}

  var opaque: SignalServiceProtos_CallMessage.Opaque {
    get {return _opaque ?? SignalServiceProtos_CallMessage.Opaque()}
    set {_opaque = newValue}
  }
  /// Returns true if `opaque` has been explicitly set.
  var hasOpaque: Bool {return self._opaque != nil}
  /// Clears the value of `opaque`. Subsequent reads from it will return its default value.
  mutating func clearOpaque() {self._opaque = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Offer: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var id: UInt64 {
      get {return _id ?? 0}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating func clearID() {self._id = nil}

    var type: SignalServiceProtos_CallMessage.Offer.TypeEnum {
      get {return _type ?? .offerAudioCall}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() {self._type = nil}

    var opaque: Data {
      get {return _opaque ?? Data()}
      set {_opaque = newValue}
    }
    /// Returns true if `opaque` has been explicitly set.
    var hasOpaque: Bool {return self._opaque != nil}
    /// Clears the value of `opaque`. Subsequent reads from it will return its default value.
    mutating func clearOpaque() {self._opaque = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TypeEnum: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
      case offerAudioCall = 0

      /// next index 3, skip 2 – it was the unused "NEED_PERMISSION" type
      case offerVideoCall = 1

      init() {
        self = .offerAudioCall
      }

    }

    init() {}

    fileprivate var _id: UInt64? = nil
    fileprivate var _type: SignalServiceProtos_CallMessage.Offer.TypeEnum? = nil
    fileprivate var _opaque: Data? = nil
  }

  struct Answer: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var id: UInt64 {
      get {return _id ?? 0}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating func clearID() {self._id = nil}

    var opaque: Data {
      get {return _opaque ?? Data()}
      set {_opaque = newValue}
    }
    /// Returns true if `opaque` has been explicitly set.
    var hasOpaque: Bool {return self._opaque != nil}
    /// Clears the value of `opaque`. Subsequent reads from it will return its default value.
    mutating func clearOpaque() {self._opaque = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _id: UInt64? = nil
    fileprivate var _opaque: Data? = nil
  }

  struct IceUpdate: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var id: UInt64 {
      get {return _id ?? 0}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating func clearID() {self._id = nil}

    var opaque: Data {
      get {return _opaque ?? Data()}
      set {_opaque = newValue}
    }
    /// Returns true if `opaque` has been explicitly set.
    var hasOpaque: Bool {return self._opaque != nil}
    /// Clears the value of `opaque`. Subsequent reads from it will return its default value.
    mutating func clearOpaque() {self._opaque = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _id: UInt64? = nil
    fileprivate var _opaque: Data? = nil
  }

  struct Busy: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var id: UInt64 {
      get {return _id ?? 0}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating func clearID() {self._id = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _id: UInt64? = nil
  }

  struct Hangup: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var id: UInt64 {
      get {return _id ?? 0}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating func clearID() {self._id = nil}

    var type: SignalServiceProtos_CallMessage.Hangup.TypeEnum {
      get {return _type ?? .hangupNormal}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() {self._type = nil}

    var deviceID: UInt32 {
      get {return _deviceID ?? 0}
      set {_deviceID = newValue}
    }
    /// Returns true if `deviceID` has been explicitly set.
    var hasDeviceID: Bool {return self._deviceID != nil}
    /// Clears the value of `deviceID`. Subsequent reads from it will return its default value.
    mutating func clearDeviceID() {self._deviceID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TypeEnum: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
      case hangupNormal = 0
      case hangupAccepted = 1
      case hangupDeclined = 2
      case hangupBusy = 3
      case hangupNeedPermission = 4

      init() {
        self = .hangupNormal
      }

    }

    init() {}

    fileprivate var _id: UInt64? = nil
    fileprivate var _type: SignalServiceProtos_CallMessage.Hangup.TypeEnum? = nil
    fileprivate var _deviceID: UInt32? = nil
  }

  struct Opaque: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var data: Data {
      get {return _data ?? Data()}
      set {_data = newValue}
    }
    /// Returns true if `data` has been explicitly set.
    var hasData: Bool {return self._data != nil}
    /// Clears the value of `data`. Subsequent reads from it will return its default value.
    mutating func clearData() {self._data = nil}

    var urgency: SignalServiceProtos_CallMessage.Opaque.Urgency {
      get {return _urgency ?? .droppable}
      set {_urgency = newValue}
    }
    /// Returns true if `urgency` has been explicitly set.
    var hasUrgency: Bool {return self._urgency != nil}
    /// Clears the value of `urgency`. Subsequent reads from it will return its default value.
    mutating func clearUrgency() {self._urgency = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Urgency: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
      case droppable = 0
      case handleImmediately = 1

      init() {
        self = .droppable
      }

    }

    init() {}

    fileprivate var _data: Data? = nil
    fileprivate var _urgency: SignalServiceProtos_CallMessage.Opaque.Urgency? = nil
  }

  init() {}

  fileprivate var _offer: SignalServiceProtos_CallMessage.Offer? = nil
  fileprivate var _answer: SignalServiceProtos_CallMessage.Answer? = nil
  fileprivate var _busy: SignalServiceProtos_CallMessage.Busy? = nil
  fileprivate var _profileKey: Data? = nil
  fileprivate var _hangup: SignalServiceProtos_CallMessage.Hangup? = nil
  fileprivate var _destinationDeviceID: UInt32? = nil
  fileprivate var _opaque: SignalServiceProtos_CallMessage.Opaque? = nil
}

struct SignalServiceProtos_DataMessage: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var body: String {
    get {return _storage._body ?? String()}
    set {_uniqueStorage()._body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  var hasBody: Bool {return _storage._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  mutating func clearBody() {_uniqueStorage()._body = nil}

  var attachments: [SignalServiceProtos_AttachmentPointer] {
    get {return _storage._attachments}
    set {_uniqueStorage()._attachments = newValue}
  }

  var groupV2: SignalServiceProtos_GroupContextV2 {
    get {return _storage._groupV2 ?? SignalServiceProtos_GroupContextV2()}
    set {_uniqueStorage()._groupV2 = newValue}
  }
  /// Returns true if `groupV2` has been explicitly set.
  var hasGroupV2: Bool {return _storage._groupV2 != nil}
  /// Clears the value of `groupV2`. Subsequent reads from it will return its default value.
  mutating func clearGroupV2() {_uniqueStorage()._groupV2 = nil}

  var flags: UInt32 {
    get {return _storage._flags ?? 0}
    set {_uniqueStorage()._flags = newValue}
  }
  /// Returns true if `flags` has been explicitly set.
  var hasFlags: Bool {return _storage._flags != nil}
  /// Clears the value of `flags`. Subsequent reads from it will return its default value.
  mutating func clearFlags() {_uniqueStorage()._flags = nil}

  var expireTimer: UInt32 {
    get {return _storage._expireTimer ?? 0}
    set {_uniqueStorage()._expireTimer = newValue}
  }
  /// Returns true if `expireTimer` has been explicitly set.
  var hasExpireTimer: Bool {return _storage._expireTimer != nil}
  /// Clears the value of `expireTimer`. Subsequent reads from it will return its default value.
  mutating func clearExpireTimer() {_uniqueStorage()._expireTimer = nil}

  var expireTimerVersion: UInt32 {
    get {return _storage._expireTimerVersion ?? 0}
    set {_uniqueStorage()._expireTimerVersion = newValue}
  }
  /// Returns true if `expireTimerVersion` has been explicitly set.
  var hasExpireTimerVersion: Bool {return _storage._expireTimerVersion != nil}
  /// Clears the value of `expireTimerVersion`. Subsequent reads from it will return its default value.
  mutating func clearExpireTimerVersion() {_uniqueStorage()._expireTimerVersion = nil}

  var profileKey: Data {
    get {return _storage._profileKey ?? Data()}
    set {_uniqueStorage()._profileKey = newValue}
  }
  /// Returns true if `profileKey` has been explicitly set.
  var hasProfileKey: Bool {return _storage._profileKey != nil}
  /// Clears the value of `profileKey`. Subsequent reads from it will return its default value.
  mutating func clearProfileKey() {_uniqueStorage()._profileKey = nil}

  var timestamp: UInt64 {
    get {return _storage._timestamp ?? 0}
    set {_uniqueStorage()._timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return _storage._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {_uniqueStorage()._timestamp = nil}

  var quote: SignalServiceProtos_DataMessage.Quote {
    get {return _storage._quote ?? SignalServiceProtos_DataMessage.Quote()}
    set {_uniqueStorage()._quote = newValue}
  }
  /// Returns true if `quote` has been explicitly set.
  var hasQuote: Bool {return _storage._quote != nil}
  /// Clears the value of `quote`. Subsequent reads from it will return its default value.
  mutating func clearQuote() {_uniqueStorage()._quote = nil}

  var contact: [SignalServiceProtos_DataMessage.Contact] {
    get {return _storage._contact}
    set {_uniqueStorage()._contact = newValue}
  }

  var preview: [SignalServiceProtos_Preview] {
    get {return _storage._preview}
    set {_uniqueStorage()._preview = newValue}
  }

  var sticker: SignalServiceProtos_DataMessage.Sticker {
    get {return _storage._sticker ?? SignalServiceProtos_DataMessage.Sticker()}
    set {_uniqueStorage()._sticker = newValue}
  }
  /// Returns true if `sticker` has been explicitly set.
  var hasSticker: Bool {return _storage._sticker != nil}
  /// Clears the value of `sticker`. Subsequent reads from it will return its default value.
  mutating func clearSticker() {_uniqueStorage()._sticker = nil}

  var requiredProtocolVersion: UInt32 {
    get {return _storage._requiredProtocolVersion ?? 0}
    set {_uniqueStorage()._requiredProtocolVersion = newValue}
  }
  /// Returns true if `requiredProtocolVersion` has been explicitly set.
  var hasRequiredProtocolVersion: Bool {return _storage._requiredProtocolVersion != nil}
  /// Clears the value of `requiredProtocolVersion`. Subsequent reads from it will return its default value.
  mutating func clearRequiredProtocolVersion() {_uniqueStorage()._requiredProtocolVersion = nil}

  var isViewOnce: Bool {
    get {return _storage._isViewOnce ?? false}
    set {_uniqueStorage()._isViewOnce = newValue}
  }
  /// Returns true if `isViewOnce` has been explicitly set.
  var hasIsViewOnce: Bool {return _storage._isViewOnce != nil}
  /// Clears the value of `isViewOnce`. Subsequent reads from it will return its default value.
  mutating func clearIsViewOnce() {_uniqueStorage()._isViewOnce = nil}

  var reaction: SignalServiceProtos_DataMessage.Reaction {
    get {return _storage._reaction ?? SignalServiceProtos_DataMessage.Reaction()}
    set {_uniqueStorage()._reaction = newValue}
  }
  /// Returns true if `reaction` has been explicitly set.
  var hasReaction: Bool {return _storage._reaction != nil}
  /// Clears the value of `reaction`. Subsequent reads from it will return its default value.
  mutating func clearReaction() {_uniqueStorage()._reaction = nil}

  var delete: SignalServiceProtos_DataMessage.Delete {
    get {return _storage._delete ?? SignalServiceProtos_DataMessage.Delete()}
    set {_uniqueStorage()._delete = newValue}
  }
  /// Returns true if `delete` has been explicitly set.
  var hasDelete: Bool {return _storage._delete != nil}
  /// Clears the value of `delete`. Subsequent reads from it will return its default value.
  mutating func clearDelete() {_uniqueStorage()._delete = nil}

  var bodyRanges: [SignalServiceProtos_BodyRange] {
    get {return _storage._bodyRanges}
    set {_uniqueStorage()._bodyRanges = newValue}
  }

  var groupCallUpdate: SignalServiceProtos_DataMessage.GroupCallUpdate {
    get {return _storage._groupCallUpdate ?? SignalServiceProtos_DataMessage.GroupCallUpdate()}
    set {_uniqueStorage()._groupCallUpdate = newValue}
  }
  /// Returns true if `groupCallUpdate` has been explicitly set.
  var hasGroupCallUpdate: Bool {return _storage._groupCallUpdate != nil}
  /// Clears the value of `groupCallUpdate`. Subsequent reads from it will return its default value.
  mutating func clearGroupCallUpdate() {_uniqueStorage()._groupCallUpdate = nil}

  var payment: SignalServiceProtos_DataMessage.Payment {
    get {return _storage._payment ?? SignalServiceProtos_DataMessage.Payment()}
    set {_uniqueStorage()._payment = newValue}
  }
  /// Returns true if `payment` has been explicitly set.
  var hasPayment: Bool {return _storage._payment != nil}
  /// Clears the value of `payment`. Subsequent reads from it will return its default value.
  mutating func clearPayment() {_uniqueStorage()._payment = nil}

  var storyContext: SignalServiceProtos_DataMessage.StoryContext {
    get {return _storage._storyContext ?? SignalServiceProtos_DataMessage.StoryContext()}
    set {_uniqueStorage()._storyContext = newValue}
  }
  /// Returns true if `storyContext` has been explicitly set.
  var hasStoryContext: Bool {return _storage._storyContext != nil}
  /// Clears the value of `storyContext`. Subsequent reads from it will return its default value.
  mutating func clearStoryContext() {_uniqueStorage()._storyContext = nil}

  /// NEXT ID: 24
  var giftBadge: SignalServiceProtos_DataMessage.GiftBadge {
    get {return _storage._giftBadge ?? SignalServiceProtos_DataMessage.GiftBadge()}
    set {_uniqueStorage()._giftBadge = newValue}
  }
  /// Returns true if `giftBadge` has been explicitly set.
  var hasGiftBadge: Bool {return _storage._giftBadge != nil}
  /// Clears the value of `giftBadge`. Subsequent reads from it will return its default value.
  mutating func clearGiftBadge() {_uniqueStorage()._giftBadge = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Flags: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case endSession = 1
    case expirationTimerUpdate = 2
    case profileKeyUpdate = 4

    init() {
      self = .endSession
    }

  }

  enum ProtocolVersion: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case initial = 0
    case messageTimers = 1
    case viewOnce = 2
    case viewOnceVideo = 3
    case reactions = 4
    case cdnSelectorAttachments = 5
    case mentions = 6
    case payments = 7
    static let current = payments

    init() {
      self = .initial
    }

  }

  struct Quote: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var id: UInt64 {
      get {return _id ?? 0}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating func clearID() {self._id = nil}

    var authorAci: String {
      get {return _authorAci ?? String()}
      set {_authorAci = newValue}
    }
    /// Returns true if `authorAci` has been explicitly set.
    var hasAuthorAci: Bool {return self._authorAci != nil}
    /// Clears the value of `authorAci`. Subsequent reads from it will return its default value.
    mutating func clearAuthorAci() {self._authorAci = nil}

    var text: String {
      get {return _text ?? String()}
      set {_text = newValue}
    }
    /// Returns true if `text` has been explicitly set.
    var hasText: Bool {return self._text != nil}
    /// Clears the value of `text`. Subsequent reads from it will return its default value.
    mutating func clearText() {self._text = nil}

    var attachments: [SignalServiceProtos_DataMessage.Quote.QuotedAttachment] = []

    var bodyRanges: [SignalServiceProtos_BodyRange] = []

    var type: SignalServiceProtos_DataMessage.Quote.TypeEnum {
      get {return _type ?? .normal}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() {self._type = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TypeEnum: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
      case normal = 0
      case giftBadge = 1

      init() {
        self = .normal
      }

    }

    struct QuotedAttachment: @unchecked Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var contentType: String {
        get {return _storage._contentType ?? String()}
        set {_uniqueStorage()._contentType = newValue}
      }
      /// Returns true if `contentType` has been explicitly set.
      var hasContentType: Bool {return _storage._contentType != nil}
      /// Clears the value of `contentType`. Subsequent reads from it will return its default value.
      mutating func clearContentType() {_uniqueStorage()._contentType = nil}

      var fileName: String {
        get {return _storage._fileName ?? String()}
        set {_uniqueStorage()._fileName = newValue}
      }
      /// Returns true if `fileName` has been explicitly set.
      var hasFileName: Bool {return _storage._fileName != nil}
      /// Clears the value of `fileName`. Subsequent reads from it will return its default value.
      mutating func clearFileName() {_uniqueStorage()._fileName = nil}

      var thumbnail: SignalServiceProtos_AttachmentPointer {
        get {return _storage._thumbnail ?? SignalServiceProtos_AttachmentPointer()}
        set {_uniqueStorage()._thumbnail = newValue}
      }
      /// Returns true if `thumbnail` has been explicitly set.
      var hasThumbnail: Bool {return _storage._thumbnail != nil}
      /// Clears the value of `thumbnail`. Subsequent reads from it will return its default value.
      mutating func clearThumbnail() {_uniqueStorage()._thumbnail = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    init() {}

    fileprivate var _id: UInt64? = nil
    fileprivate var _authorAci: String? = nil
    fileprivate var _text: String? = nil
    fileprivate var _type: SignalServiceProtos_DataMessage.Quote.TypeEnum? = nil
  }

  struct Contact: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: SignalServiceProtos_DataMessage.Contact.Name {
      get {return _name ?? SignalServiceProtos_DataMessage.Contact.Name()}
      set {_name = newValue}
    }
    /// Returns true if `name` has been explicitly set.
    var hasName: Bool {return self._name != nil}
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    mutating func clearName() {self._name = nil}

    var number: [SignalServiceProtos_DataMessage.Contact.Phone] = []

    var email: [SignalServiceProtos_DataMessage.Contact.Email] = []

    var address: [SignalServiceProtos_DataMessage.Contact.PostalAddress] = []

    var avatar: SignalServiceProtos_DataMessage.Contact.Avatar {
      get {return _avatar ?? SignalServiceProtos_DataMessage.Contact.Avatar()}
      set {_avatar = newValue}
    }
    /// Returns true if `avatar` has been explicitly set.
    var hasAvatar: Bool {return self._avatar != nil}
    /// Clears the value of `avatar`. Subsequent reads from it will return its default value.
    mutating func clearAvatar() {self._avatar = nil}

    var organization: String {
      get {return _organization ?? String()}
      set {_organization = newValue}
    }
    /// Returns true if `organization` has been explicitly set.
    var hasOrganization: Bool {return self._organization != nil}
    /// Clears the value of `organization`. Subsequent reads from it will return its default value.
    mutating func clearOrganization() {self._organization = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Name: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var givenName: String {
        get {return _givenName ?? String()}
        set {_givenName = newValue}
      }
      /// Returns true if `givenName` has been explicitly set.
      var hasGivenName: Bool {return self._givenName != nil}
      /// Clears the value of `givenName`. Subsequent reads from it will return its default value.
      mutating func clearGivenName() {self._givenName = nil}

      var familyName: String {
        get {return _familyName ?? String()}
        set {_familyName = newValue}
      }
      /// Returns true if `familyName` has been explicitly set.
      var hasFamilyName: Bool {return self._familyName != nil}
      /// Clears the value of `familyName`. Subsequent reads from it will return its default value.
      mutating func clearFamilyName() {self._familyName = nil}

      var prefix: String {
        get {return _prefix ?? String()}
        set {_prefix = newValue}
      }
      /// Returns true if `prefix` has been explicitly set.
      var hasPrefix: Bool {return self._prefix != nil}
      /// Clears the value of `prefix`. Subsequent reads from it will return its default value.
      mutating func clearPrefix() {self._prefix = nil}

      var suffix: String {
        get {return _suffix ?? String()}
        set {_suffix = newValue}
      }
      /// Returns true if `suffix` has been explicitly set.
      var hasSuffix: Bool {return self._suffix != nil}
      /// Clears the value of `suffix`. Subsequent reads from it will return its default value.
      mutating func clearSuffix() {self._suffix = nil}

      var middleName: String {
        get {return _middleName ?? String()}
        set {_middleName = newValue}
      }
      /// Returns true if `middleName` has been explicitly set.
      var hasMiddleName: Bool {return self._middleName != nil}
      /// Clears the value of `middleName`. Subsequent reads from it will return its default value.
      mutating func clearMiddleName() {self._middleName = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _givenName: String? = nil
      fileprivate var _familyName: String? = nil
      fileprivate var _prefix: String? = nil
      fileprivate var _suffix: String? = nil
      fileprivate var _middleName: String? = nil
    }

    struct Phone: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var value: String {
        get {return _value ?? String()}
        set {_value = newValue}
      }
      /// Returns true if `value` has been explicitly set.
      var hasValue: Bool {return self._value != nil}
      /// Clears the value of `value`. Subsequent reads from it will return its default value.
      mutating func clearValue() {self._value = nil}

      var type: SignalServiceProtos_DataMessage.Contact.Phone.TypeEnum {
        get {return _type ?? .home}
        set {_type = newValue}
      }
      /// Returns true if `type` has been explicitly set.
      var hasType: Bool {return self._type != nil}
      /// Clears the value of `type`. Subsequent reads from it will return its default value.
      mutating func clearType() {self._type = nil}

      var label: String {
        get {return _label ?? String()}
        set {_label = newValue}
      }
      /// Returns true if `label` has been explicitly set.
      var hasLabel: Bool {return self._label != nil}
      /// Clears the value of `label`. Subsequent reads from it will return its default value.
      mutating func clearLabel() {self._label = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum TypeEnum: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
        case home = 1
        case mobile = 2
        case work = 3
        case custom = 4

        init() {
          self = .home
        }

      }

      init() {}

      fileprivate var _value: String? = nil
      fileprivate var _type: SignalServiceProtos_DataMessage.Contact.Phone.TypeEnum? = nil
      fileprivate var _label: String? = nil
    }

    struct Email: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var value: String {
        get {return _value ?? String()}
        set {_value = newValue}
      }
      /// Returns true if `value` has been explicitly set.
      var hasValue: Bool {return self._value != nil}
      /// Clears the value of `value`. Subsequent reads from it will return its default value.
      mutating func clearValue() {self._value = nil}

      var type: SignalServiceProtos_DataMessage.Contact.Email.TypeEnum {
        get {return _type ?? .home}
        set {_type = newValue}
      }
      /// Returns true if `type` has been explicitly set.
      var hasType: Bool {return self._type != nil}
      /// Clears the value of `type`. Subsequent reads from it will return its default value.
      mutating func clearType() {self._type = nil}

      var label: String {
        get {return _label ?? String()}
        set {_label = newValue}
      }
      /// Returns true if `label` has been explicitly set.
      var hasLabel: Bool {return self._label != nil}
      /// Clears the value of `label`. Subsequent reads from it will return its default value.
      mutating func clearLabel() {self._label = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum TypeEnum: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
        case home = 1
        case mobile = 2
        case work = 3
        case custom = 4

        init() {
          self = .home
        }

      }

      init() {}

      fileprivate var _value: String? = nil
      fileprivate var _type: SignalServiceProtos_DataMessage.Contact.Email.TypeEnum? = nil
      fileprivate var _label: String? = nil
    }

    struct PostalAddress: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var type: SignalServiceProtos_DataMessage.Contact.PostalAddress.TypeEnum {
        get {return _type ?? .home}
        set {_type = newValue}
      }
      /// Returns true if `type` has been explicitly set.
      var hasType: Bool {return self._type != nil}
      /// Clears the value of `type`. Subsequent reads from it will return its default value.
      mutating func clearType() {self._type = nil}

      var label: String {
        get {return _label ?? String()}
        set {_label = newValue}
      }
      /// Returns true if `label` has been explicitly set.
      var hasLabel: Bool {return self._label != nil}
      /// Clears the value of `label`. Subsequent reads from it will return its default value.
      mutating func clearLabel() {self._label = nil}

      var street: String {
        get {return _street ?? String()}
        set {_street = newValue}
      }
      /// Returns true if `street` has been explicitly set.
      var hasStreet: Bool {return self._street != nil}
      /// Clears the value of `street`. Subsequent reads from it will return its default value.
      mutating func clearStreet() {self._street = nil}

      var pobox: String {
        get {return _pobox ?? String()}
        set {_pobox = newValue}
      }
      /// Returns true if `pobox` has been explicitly set.
      var hasPobox: Bool {return self._pobox != nil}
      /// Clears the value of `pobox`. Subsequent reads from it will return its default value.
      mutating func clearPobox() {self._pobox = nil}

      var neighborhood: String {
        get {return _neighborhood ?? String()}
        set {_neighborhood = newValue}
      }
      /// Returns true if `neighborhood` has been explicitly set.
      var hasNeighborhood: Bool {return self._neighborhood != nil}
      /// Clears the value of `neighborhood`. Subsequent reads from it will return its default value.
      mutating func clearNeighborhood() {self._neighborhood = nil}

      var city: String {
        get {return _city ?? String()}
        set {_city = newValue}
      }
      /// Returns true if `city` has been explicitly set.
      var hasCity: Bool {return self._city != nil}
      /// Clears the value of `city`. Subsequent reads from it will return its default value.
      mutating func clearCity() {self._city = nil}

      var region: String {
        get {return _region ?? String()}
        set {_region = newValue}
      }
      /// Returns true if `region` has been explicitly set.
      var hasRegion: Bool {return self._region != nil}
      /// Clears the value of `region`. Subsequent reads from it will return its default value.
      mutating func clearRegion() {self._region = nil}

      var postcode: String {
        get {return _postcode ?? String()}
        set {_postcode = newValue}
      }
      /// Returns true if `postcode` has been explicitly set.
      var hasPostcode: Bool {return self._postcode != nil}
      /// Clears the value of `postcode`. Subsequent reads from it will return its default value.
      mutating func clearPostcode() {self._postcode = nil}

      var country: String {
        get {return _country ?? String()}
        set {_country = newValue}
      }
      /// Returns true if `country` has been explicitly set.
      var hasCountry: Bool {return self._country != nil}
      /// Clears the value of `country`. Subsequent reads from it will return its default value.
      mutating func clearCountry() {self._country = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum TypeEnum: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
        case home = 1
        case work = 2
        case custom = 3

        init() {
          self = .home
        }

      }

      init() {}

      fileprivate var _type: SignalServiceProtos_DataMessage.Contact.PostalAddress.TypeEnum? = nil
      fileprivate var _label: String? = nil
      fileprivate var _street: String? = nil
      fileprivate var _pobox: String? = nil
      fileprivate var _neighborhood: String? = nil
      fileprivate var _city: String? = nil
      fileprivate var _region: String? = nil
      fileprivate var _postcode: String? = nil
      fileprivate var _country: String? = nil
    }

    struct Avatar: @unchecked Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var avatar: SignalServiceProtos_AttachmentPointer {
        get {return _storage._avatar ?? SignalServiceProtos_AttachmentPointer()}
        set {_uniqueStorage()._avatar = newValue}
      }
      /// Returns true if `avatar` has been explicitly set.
      var hasAvatar: Bool {return _storage._avatar != nil}
      /// Clears the value of `avatar`. Subsequent reads from it will return its default value.
      mutating func clearAvatar() {_uniqueStorage()._avatar = nil}

      var isProfile: Bool {
        get {return _storage._isProfile ?? false}
        set {_uniqueStorage()._isProfile = newValue}
      }
      /// Returns true if `isProfile` has been explicitly set.
      var hasIsProfile: Bool {return _storage._isProfile != nil}
      /// Clears the value of `isProfile`. Subsequent reads from it will return its default value.
      mutating func clearIsProfile() {_uniqueStorage()._isProfile = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    init() {}

    fileprivate var _name: SignalServiceProtos_DataMessage.Contact.Name? = nil
    fileprivate var _avatar: SignalServiceProtos_DataMessage.Contact.Avatar? = nil
    fileprivate var _organization: String? = nil
  }

  struct Sticker: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var packID: Data {
      get {return _storage._packID ?? Data()}
      set {_uniqueStorage()._packID = newValue}
    }
    /// Returns true if `packID` has been explicitly set.
    var hasPackID: Bool {return _storage._packID != nil}
    /// Clears the value of `packID`. Subsequent reads from it will return its default value.
    mutating func clearPackID() {_uniqueStorage()._packID = nil}

    /// @required
    var packKey: Data {
      get {return _storage._packKey ?? Data()}
      set {_uniqueStorage()._packKey = newValue}
    }
    /// Returns true if `packKey` has been explicitly set.
    var hasPackKey: Bool {return _storage._packKey != nil}
    /// Clears the value of `packKey`. Subsequent reads from it will return its default value.
    mutating func clearPackKey() {_uniqueStorage()._packKey = nil}

    /// @required
    var stickerID: UInt32 {
      get {return _storage._stickerID ?? 0}
      set {_uniqueStorage()._stickerID = newValue}
    }
    /// Returns true if `stickerID` has been explicitly set.
    var hasStickerID: Bool {return _storage._stickerID != nil}
    /// Clears the value of `stickerID`. Subsequent reads from it will return its default value.
    mutating func clearStickerID() {_uniqueStorage()._stickerID = nil}

    /// @required
    var data: SignalServiceProtos_AttachmentPointer {
      get {return _storage._data ?? SignalServiceProtos_AttachmentPointer()}
      set {_uniqueStorage()._data = newValue}
    }
    /// Returns true if `data` has been explicitly set.
    var hasData: Bool {return _storage._data != nil}
    /// Clears the value of `data`. Subsequent reads from it will return its default value.
    mutating func clearData() {_uniqueStorage()._data = nil}

    var emoji: String {
      get {return _storage._emoji ?? String()}
      set {_uniqueStorage()._emoji = newValue}
    }
    /// Returns true if `emoji` has been explicitly set.
    var hasEmoji: Bool {return _storage._emoji != nil}
    /// Clears the value of `emoji`. Subsequent reads from it will return its default value.
    mutating func clearEmoji() {_uniqueStorage()._emoji = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct Reaction: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var emoji: String {
      get {return _emoji ?? String()}
      set {_emoji = newValue}
    }
    /// Returns true if `emoji` has been explicitly set.
    var hasEmoji: Bool {return self._emoji != nil}
    /// Clears the value of `emoji`. Subsequent reads from it will return its default value.
    mutating func clearEmoji() {self._emoji = nil}

    var remove: Bool {
      get {return _remove ?? false}
      set {_remove = newValue}
    }
    /// Returns true if `remove` has been explicitly set.
    var hasRemove: Bool {return self._remove != nil}
    /// Clears the value of `remove`. Subsequent reads from it will return its default value.
    mutating func clearRemove() {self._remove = nil}

    var targetAuthorAci: String {
      get {return _targetAuthorAci ?? String()}
      set {_targetAuthorAci = newValue}
    }
    /// Returns true if `targetAuthorAci` has been explicitly set.
    var hasTargetAuthorAci: Bool {return self._targetAuthorAci != nil}
    /// Clears the value of `targetAuthorAci`. Subsequent reads from it will return its default value.
    mutating func clearTargetAuthorAci() {self._targetAuthorAci = nil}

    /// @required
    var timestamp: UInt64 {
      get {return _timestamp ?? 0}
      set {_timestamp = newValue}
    }
    /// Returns true if `timestamp` has been explicitly set.
    var hasTimestamp: Bool {return self._timestamp != nil}
    /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
    mutating func clearTimestamp() {self._timestamp = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _emoji: String? = nil
    fileprivate var _remove: Bool? = nil
    fileprivate var _targetAuthorAci: String? = nil
    fileprivate var _timestamp: UInt64? = nil
  }

  struct Delete: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var targetSentTimestamp: UInt64 {
      get {return _targetSentTimestamp ?? 0}
      set {_targetSentTimestamp = newValue}
    }
    /// Returns true if `targetSentTimestamp` has been explicitly set.
    var hasTargetSentTimestamp: Bool {return self._targetSentTimestamp != nil}
    /// Clears the value of `targetSentTimestamp`. Subsequent reads from it will return its default value.
    mutating func clearTargetSentTimestamp() {self._targetSentTimestamp = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _targetSentTimestamp: UInt64? = nil
  }

  struct GroupCallUpdate: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var eraID: String {
      get {return _eraID ?? String()}
      set {_eraID = newValue}
    }
    /// Returns true if `eraID` has been explicitly set.
    var hasEraID: Bool {return self._eraID != nil}
    /// Clears the value of `eraID`. Subsequent reads from it will return its default value.
    mutating func clearEraID() {self._eraID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _eraID: String? = nil
  }

  struct Payment: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// oneof commented out
    /// oneof Item {
    var notification: SignalServiceProtos_DataMessage.Payment.Notification {
      get {return _notification ?? SignalServiceProtos_DataMessage.Payment.Notification()}
      set {_notification = newValue}
    }
    /// Returns true if `notification` has been explicitly set.
    var hasNotification: Bool {return self._notification != nil}
    /// Clears the value of `notification`. Subsequent reads from it will return its default value.
    mutating func clearNotification() {self._notification = nil}

    var activation: SignalServiceProtos_DataMessage.Payment.Activation {
      get {return _activation ?? SignalServiceProtos_DataMessage.Payment.Activation()}
      set {_activation = newValue}
    }
    /// Returns true if `activation` has been explicitly set.
    var hasActivation: Bool {return self._activation != nil}
    /// Clears the value of `activation`. Subsequent reads from it will return its default value.
    mutating func clearActivation() {self._activation = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Amount: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// oneof commented out
      /// oneof Amount {
      var mobileCoin: SignalServiceProtos_DataMessage.Payment.Amount.MobileCoin {
        get {return _mobileCoin ?? SignalServiceProtos_DataMessage.Payment.Amount.MobileCoin()}
        set {_mobileCoin = newValue}
      }
      /// Returns true if `mobileCoin` has been explicitly set.
      var hasMobileCoin: Bool {return self._mobileCoin != nil}
      /// Clears the value of `mobileCoin`. Subsequent reads from it will return its default value.
      mutating func clearMobileCoin() {self._mobileCoin = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      struct MobileCoin: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// @required
        var picoMob: UInt64 {
          get {return _picoMob ?? 0}
          set {_picoMob = newValue}
        }
        /// Returns true if `picoMob` has been explicitly set.
        var hasPicoMob: Bool {return self._picoMob != nil}
        /// Clears the value of `picoMob`. Subsequent reads from it will return its default value.
        mutating func clearPicoMob() {self._picoMob = nil}

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _picoMob: UInt64? = nil
      }

      init() {}

      fileprivate var _mobileCoin: SignalServiceProtos_DataMessage.Payment.Amount.MobileCoin? = nil
    }

    struct Notification: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// oneof commented out
      /// oneof Transaction {
      var mobileCoin: SignalServiceProtos_DataMessage.Payment.Notification.MobileCoin {
        get {return _mobileCoin ?? SignalServiceProtos_DataMessage.Payment.Notification.MobileCoin()}
        set {_mobileCoin = newValue}
      }
      /// Returns true if `mobileCoin` has been explicitly set.
      var hasMobileCoin: Bool {return self._mobileCoin != nil}
      /// Clears the value of `mobileCoin`. Subsequent reads from it will return its default value.
      mutating func clearMobileCoin() {self._mobileCoin = nil}

      var note: String {
        get {return _note ?? String()}
        set {_note = newValue}
      }
      /// Returns true if `note` has been explicitly set.
      var hasNote: Bool {return self._note != nil}
      /// Clears the value of `note`. Subsequent reads from it will return its default value.
      mutating func clearNote() {self._note = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      struct MobileCoin: @unchecked Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// @required
        var receipt: Data {
          get {return _receipt ?? Data()}
          set {_receipt = newValue}
        }
        /// Returns true if `receipt` has been explicitly set.
        var hasReceipt: Bool {return self._receipt != nil}
        /// Clears the value of `receipt`. Subsequent reads from it will return its default value.
        mutating func clearReceipt() {self._receipt = nil}

        var unknownFields = SwiftProtobuf.UnknownStorage()

        init() {}

        fileprivate var _receipt: Data? = nil
      }

      init() {}

      fileprivate var _mobileCoin: SignalServiceProtos_DataMessage.Payment.Notification.MobileCoin? = nil
      fileprivate var _note: String? = nil
    }

    struct Activation: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var type: SignalServiceProtos_DataMessage.Payment.Activation.TypeEnum {
        get {return _type ?? .request}
        set {_type = newValue}
      }
      /// Returns true if `type` has been explicitly set.
      var hasType: Bool {return self._type != nil}
      /// Clears the value of `type`. Subsequent reads from it will return its default value.
      mutating func clearType() {self._type = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum TypeEnum: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
        case request = 0
        case activated = 1

        init() {
          self = .request
        }

      }

      init() {}

      fileprivate var _type: SignalServiceProtos_DataMessage.Payment.Activation.TypeEnum? = nil
    }

    init() {}

    fileprivate var _notification: SignalServiceProtos_DataMessage.Payment.Notification? = nil
    fileprivate var _activation: SignalServiceProtos_DataMessage.Payment.Activation? = nil
  }

  struct StoryContext: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var authorAci: String {
      get {return _authorAci ?? String()}
      set {_authorAci = newValue}
    }
    /// Returns true if `authorAci` has been explicitly set.
    var hasAuthorAci: Bool {return self._authorAci != nil}
    /// Clears the value of `authorAci`. Subsequent reads from it will return its default value.
    mutating func clearAuthorAci() {self._authorAci = nil}

    var sentTimestamp: UInt64 {
      get {return _sentTimestamp ?? 0}
      set {_sentTimestamp = newValue}
    }
    /// Returns true if `sentTimestamp` has been explicitly set.
    var hasSentTimestamp: Bool {return self._sentTimestamp != nil}
    /// Clears the value of `sentTimestamp`. Subsequent reads from it will return its default value.
    mutating func clearSentTimestamp() {self._sentTimestamp = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _authorAci: String? = nil
    fileprivate var _sentTimestamp: UInt64? = nil
  }

  struct GiftBadge: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var receiptCredentialPresentation: Data {
      get {return _receiptCredentialPresentation ?? Data()}
      set {_receiptCredentialPresentation = newValue}
    }
    /// Returns true if `receiptCredentialPresentation` has been explicitly set.
    var hasReceiptCredentialPresentation: Bool {return self._receiptCredentialPresentation != nil}
    /// Clears the value of `receiptCredentialPresentation`. Subsequent reads from it will return its default value.
    mutating func clearReceiptCredentialPresentation() {self._receiptCredentialPresentation = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _receiptCredentialPresentation: Data? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SignalServiceProtos_NullMessage: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var padding: Data {
    get {return _padding ?? Data()}
    set {_padding = newValue}
  }
  /// Returns true if `padding` has been explicitly set.
  var hasPadding: Bool {return self._padding != nil}
  /// Clears the value of `padding`. Subsequent reads from it will return its default value.
  mutating func clearPadding() {self._padding = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _padding: Data? = nil
}

struct SignalServiceProtos_ReceiptMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: SignalServiceProtos_ReceiptMessage.TypeEnum {
    get {return _type ?? .delivery}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var timestamp: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case delivery = 0
    case read = 1
    case viewed = 2

    init() {
      self = .delivery
    }

  }

  init() {}

  fileprivate var _type: SignalServiceProtos_ReceiptMessage.TypeEnum? = nil
}

struct SignalServiceProtos_Verified: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var destinationAci: String {
    get {return _destinationAci ?? String()}
    set {_destinationAci = newValue}
  }
  /// Returns true if `destinationAci` has been explicitly set.
  var hasDestinationAci: Bool {return self._destinationAci != nil}
  /// Clears the value of `destinationAci`. Subsequent reads from it will return its default value.
  mutating func clearDestinationAci() {self._destinationAci = nil}

  var identityKey: Data {
    get {return _identityKey ?? Data()}
    set {_identityKey = newValue}
  }
  /// Returns true if `identityKey` has been explicitly set.
  var hasIdentityKey: Bool {return self._identityKey != nil}
  /// Clears the value of `identityKey`. Subsequent reads from it will return its default value.
  mutating func clearIdentityKey() {self._identityKey = nil}

  var state: SignalServiceProtos_Verified.State {
    get {return _state ?? .default}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  mutating func clearState() {self._state = nil}

  var nullMessage: Data {
    get {return _nullMessage ?? Data()}
    set {_nullMessage = newValue}
  }
  /// Returns true if `nullMessage` has been explicitly set.
  var hasNullMessage: Bool {return self._nullMessage != nil}
  /// Clears the value of `nullMessage`. Subsequent reads from it will return its default value.
  mutating func clearNullMessage() {self._nullMessage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum State: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case `default` = 0
    case verified = 1
    case unverified = 2

    init() {
      self = .default
    }

  }

  init() {}

  fileprivate var _destinationAci: String? = nil
  fileprivate var _identityKey: Data? = nil
  fileprivate var _state: SignalServiceProtos_Verified.State? = nil
  fileprivate var _nullMessage: Data? = nil
}

struct SignalServiceProtos_SyncMessage: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sent: SignalServiceProtos_SyncMessage.Sent {
    get {return _storage._sent ?? SignalServiceProtos_SyncMessage.Sent()}
    set {_uniqueStorage()._sent = newValue}
  }
  /// Returns true if `sent` has been explicitly set.
  var hasSent: Bool {return _storage._sent != nil}
  /// Clears the value of `sent`. Subsequent reads from it will return its default value.
  mutating func clearSent() {_uniqueStorage()._sent = nil}

  var contacts: SignalServiceProtos_SyncMessage.Contacts {
    get {return _storage._contacts ?? SignalServiceProtos_SyncMessage.Contacts()}
    set {_uniqueStorage()._contacts = newValue}
  }
  /// Returns true if `contacts` has been explicitly set.
  var hasContacts: Bool {return _storage._contacts != nil}
  /// Clears the value of `contacts`. Subsequent reads from it will return its default value.
  mutating func clearContacts() {_uniqueStorage()._contacts = nil}

  var request: SignalServiceProtos_SyncMessage.Request {
    get {return _storage._request ?? SignalServiceProtos_SyncMessage.Request()}
    set {_uniqueStorage()._request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  var hasRequest: Bool {return _storage._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  mutating func clearRequest() {_uniqueStorage()._request = nil}

  var read: [SignalServiceProtos_SyncMessage.Read] {
    get {return _storage._read}
    set {_uniqueStorage()._read = newValue}
  }

  var blocked: SignalServiceProtos_SyncMessage.Blocked {
    get {return _storage._blocked ?? SignalServiceProtos_SyncMessage.Blocked()}
    set {_uniqueStorage()._blocked = newValue}
  }
  /// Returns true if `blocked` has been explicitly set.
  var hasBlocked: Bool {return _storage._blocked != nil}
  /// Clears the value of `blocked`. Subsequent reads from it will return its default value.
  mutating func clearBlocked() {_uniqueStorage()._blocked = nil}

  var verified: SignalServiceProtos_Verified {
    get {return _storage._verified ?? SignalServiceProtos_Verified()}
    set {_uniqueStorage()._verified = newValue}
  }
  /// Returns true if `verified` has been explicitly set.
  var hasVerified: Bool {return _storage._verified != nil}
  /// Clears the value of `verified`. Subsequent reads from it will return its default value.
  mutating func clearVerified() {_uniqueStorage()._verified = nil}

  var configuration: SignalServiceProtos_SyncMessage.Configuration {
    get {return _storage._configuration ?? SignalServiceProtos_SyncMessage.Configuration()}
    set {_uniqueStorage()._configuration = newValue}
  }
  /// Returns true if `configuration` has been explicitly set.
  var hasConfiguration: Bool {return _storage._configuration != nil}
  /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
  mutating func clearConfiguration() {_uniqueStorage()._configuration = nil}

  var padding: Data {
    get {return _storage._padding ?? Data()}
    set {_uniqueStorage()._padding = newValue}
  }
  /// Returns true if `padding` has been explicitly set.
  var hasPadding: Bool {return _storage._padding != nil}
  /// Clears the value of `padding`. Subsequent reads from it will return its default value.
  mutating func clearPadding() {_uniqueStorage()._padding = nil}

  var stickerPackOperation: [SignalServiceProtos_SyncMessage.StickerPackOperation] {
    get {return _storage._stickerPackOperation}
    set {_uniqueStorage()._stickerPackOperation = newValue}
  }

  var viewOnceOpen: SignalServiceProtos_SyncMessage.ViewOnceOpen {
    get {return _storage._viewOnceOpen ?? SignalServiceProtos_SyncMessage.ViewOnceOpen()}
    set {_uniqueStorage()._viewOnceOpen = newValue}
  }
  /// Returns true if `viewOnceOpen` has been explicitly set.
  var hasViewOnceOpen: Bool {return _storage._viewOnceOpen != nil}
  /// Clears the value of `viewOnceOpen`. Subsequent reads from it will return its default value.
  mutating func clearViewOnceOpen() {_uniqueStorage()._viewOnceOpen = nil}

  var fetchLatest: SignalServiceProtos_SyncMessage.FetchLatest {
    get {return _storage._fetchLatest ?? SignalServiceProtos_SyncMessage.FetchLatest()}
    set {_uniqueStorage()._fetchLatest = newValue}
  }
  /// Returns true if `fetchLatest` has been explicitly set.
  var hasFetchLatest: Bool {return _storage._fetchLatest != nil}
  /// Clears the value of `fetchLatest`. Subsequent reads from it will return its default value.
  mutating func clearFetchLatest() {_uniqueStorage()._fetchLatest = nil}

  var keys: SignalServiceProtos_SyncMessage.Keys {
    get {return _storage._keys ?? SignalServiceProtos_SyncMessage.Keys()}
    set {_uniqueStorage()._keys = newValue}
  }
  /// Returns true if `keys` has been explicitly set.
  var hasKeys: Bool {return _storage._keys != nil}
  /// Clears the value of `keys`. Subsequent reads from it will return its default value.
  mutating func clearKeys() {_uniqueStorage()._keys = nil}

  var messageRequestResponse: SignalServiceProtos_SyncMessage.MessageRequestResponse {
    get {return _storage._messageRequestResponse ?? SignalServiceProtos_SyncMessage.MessageRequestResponse()}
    set {_uniqueStorage()._messageRequestResponse = newValue}
  }
  /// Returns true if `messageRequestResponse` has been explicitly set.
  var hasMessageRequestResponse: Bool {return _storage._messageRequestResponse != nil}
  /// Clears the value of `messageRequestResponse`. Subsequent reads from it will return its default value.
  mutating func clearMessageRequestResponse() {_uniqueStorage()._messageRequestResponse = nil}

  var outgoingPayment: SignalServiceProtos_SyncMessage.OutgoingPayment {
    get {return _storage._outgoingPayment ?? SignalServiceProtos_SyncMessage.OutgoingPayment()}
    set {_uniqueStorage()._outgoingPayment = newValue}
  }
  /// Returns true if `outgoingPayment` has been explicitly set.
  var hasOutgoingPayment: Bool {return _storage._outgoingPayment != nil}
  /// Clears the value of `outgoingPayment`. Subsequent reads from it will return its default value.
  mutating func clearOutgoingPayment() {_uniqueStorage()._outgoingPayment = nil}

  var viewed: [SignalServiceProtos_SyncMessage.Viewed] {
    get {return _storage._viewed}
    set {_uniqueStorage()._viewed = newValue}
  }

  var pniChangeNumber: SignalServiceProtos_SyncMessage.PniChangeNumber {
    get {return _storage._pniChangeNumber ?? SignalServiceProtos_SyncMessage.PniChangeNumber()}
    set {_uniqueStorage()._pniChangeNumber = newValue}
  }
  /// Returns true if `pniChangeNumber` has been explicitly set.
  var hasPniChangeNumber: Bool {return _storage._pniChangeNumber != nil}
  /// Clears the value of `pniChangeNumber`. Subsequent reads from it will return its default value.
  mutating func clearPniChangeNumber() {_uniqueStorage()._pniChangeNumber = nil}

  var callEvent: SignalServiceProtos_SyncMessage.CallEvent {
    get {return _storage._callEvent ?? SignalServiceProtos_SyncMessage.CallEvent()}
    set {_uniqueStorage()._callEvent = newValue}
  }
  /// Returns true if `callEvent` has been explicitly set.
  var hasCallEvent: Bool {return _storage._callEvent != nil}
  /// Clears the value of `callEvent`. Subsequent reads from it will return its default value.
  mutating func clearCallEvent() {_uniqueStorage()._callEvent = nil}

  var callLinkUpdate: SignalServiceProtos_SyncMessage.CallLinkUpdate {
    get {return _storage._callLinkUpdate ?? SignalServiceProtos_SyncMessage.CallLinkUpdate()}
    set {_uniqueStorage()._callLinkUpdate = newValue}
  }
  /// Returns true if `callLinkUpdate` has been explicitly set.
  var hasCallLinkUpdate: Bool {return _storage._callLinkUpdate != nil}
  /// Clears the value of `callLinkUpdate`. Subsequent reads from it will return its default value.
  mutating func clearCallLinkUpdate() {_uniqueStorage()._callLinkUpdate = nil}

  var callLogEvent: SignalServiceProtos_SyncMessage.CallLogEvent {
    get {return _storage._callLogEvent ?? SignalServiceProtos_SyncMessage.CallLogEvent()}
    set {_uniqueStorage()._callLogEvent = newValue}
  }
  /// Returns true if `callLogEvent` has been explicitly set.
  var hasCallLogEvent: Bool {return _storage._callLogEvent != nil}
  /// Clears the value of `callLogEvent`. Subsequent reads from it will return its default value.
  mutating func clearCallLogEvent() {_uniqueStorage()._callLogEvent = nil}

  var deleteForMe: SignalServiceProtos_SyncMessage.DeleteForMe {
    get {return _storage._deleteForMe ?? SignalServiceProtos_SyncMessage.DeleteForMe()}
    set {_uniqueStorage()._deleteForMe = newValue}
  }
  /// Returns true if `deleteForMe` has been explicitly set.
  var hasDeleteForMe: Bool {return _storage._deleteForMe != nil}
  /// Clears the value of `deleteForMe`. Subsequent reads from it will return its default value.
  mutating func clearDeleteForMe() {_uniqueStorage()._deleteForMe = nil}

  var deviceNameChange: SignalServiceProtos_SyncMessage.DeviceNameChange {
    get {return _storage._deviceNameChange ?? SignalServiceProtos_SyncMessage.DeviceNameChange()}
    set {_uniqueStorage()._deviceNameChange = newValue}
  }
  /// Returns true if `deviceNameChange` has been explicitly set.
  var hasDeviceNameChange: Bool {return _storage._deviceNameChange != nil}
  /// Clears the value of `deviceNameChange`. Subsequent reads from it will return its default value.
  mutating func clearDeviceNameChange() {_uniqueStorage()._deviceNameChange = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Sent: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var destinationE164: String {
      get {return _destinationE164 ?? String()}
      set {_destinationE164 = newValue}
    }
    /// Returns true if `destinationE164` has been explicitly set.
    var hasDestinationE164: Bool {return self._destinationE164 != nil}
    /// Clears the value of `destinationE164`. Subsequent reads from it will return its default value.
    mutating func clearDestinationE164() {self._destinationE164 = nil}

    var destinationServiceID: String {
      get {return _destinationServiceID ?? String()}
      set {_destinationServiceID = newValue}
    }
    /// Returns true if `destinationServiceID` has been explicitly set.
    var hasDestinationServiceID: Bool {return self._destinationServiceID != nil}
    /// Clears the value of `destinationServiceID`. Subsequent reads from it will return its default value.
    mutating func clearDestinationServiceID() {self._destinationServiceID = nil}

    var timestamp: UInt64 {
      get {return _timestamp ?? 0}
      set {_timestamp = newValue}
    }
    /// Returns true if `timestamp` has been explicitly set.
    var hasTimestamp: Bool {return self._timestamp != nil}
    /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
    mutating func clearTimestamp() {self._timestamp = nil}

    var message: SignalServiceProtos_DataMessage {
      get {return _message ?? SignalServiceProtos_DataMessage()}
      set {_message = newValue}
    }
    /// Returns true if `message` has been explicitly set.
    var hasMessage: Bool {return self._message != nil}
    /// Clears the value of `message`. Subsequent reads from it will return its default value.
    mutating func clearMessage() {self._message = nil}

    var expirationStartTimestamp: UInt64 {
      get {return _expirationStartTimestamp ?? 0}
      set {_expirationStartTimestamp = newValue}
    }
    /// Returns true if `expirationStartTimestamp` has been explicitly set.
    var hasExpirationStartTimestamp: Bool {return self._expirationStartTimestamp != nil}
    /// Clears the value of `expirationStartTimestamp`. Subsequent reads from it will return its default value.
    mutating func clearExpirationStartTimestamp() {self._expirationStartTimestamp = nil}

    var unidentifiedStatus: [SignalServiceProtos_SyncMessage.Sent.UnidentifiedDeliveryStatus] = []

    var isRecipientUpdate: Bool {
      get {return _isRecipientUpdate ?? false}
      set {_isRecipientUpdate = newValue}
    }
    /// Returns true if `isRecipientUpdate` has been explicitly set.
    var hasIsRecipientUpdate: Bool {return self._isRecipientUpdate != nil}
    /// Clears the value of `isRecipientUpdate`. Subsequent reads from it will return its default value.
    mutating func clearIsRecipientUpdate() {self._isRecipientUpdate = nil}

    var storyMessage: SignalServiceProtos_StoryMessage {
      get {return _storyMessage ?? SignalServiceProtos_StoryMessage()}
      set {_storyMessage = newValue}
    }
    /// Returns true if `storyMessage` has been explicitly set.
    var hasStoryMessage: Bool {return self._storyMessage != nil}
    /// Clears the value of `storyMessage`. Subsequent reads from it will return its default value.
    mutating func clearStoryMessage() {self._storyMessage = nil}

    var storyMessageRecipients: [SignalServiceProtos_SyncMessage.Sent.StoryMessageRecipient] = []

    var editMessage: SignalServiceProtos_EditMessage {
      get {return _editMessage ?? SignalServiceProtos_EditMessage()}
      set {_editMessage = newValue}
    }
    /// Returns true if `editMessage` has been explicitly set.
    var hasEditMessage: Bool {return self._editMessage != nil}
    /// Clears the value of `editMessage`. Subsequent reads from it will return its default value.
    mutating func clearEditMessage() {self._editMessage = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct UnidentifiedDeliveryStatus: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var destinationServiceID: String {
        get {return _destinationServiceID ?? String()}
        set {_destinationServiceID = newValue}
      }
      /// Returns true if `destinationServiceID` has been explicitly set.
      var hasDestinationServiceID: Bool {return self._destinationServiceID != nil}
      /// Clears the value of `destinationServiceID`. Subsequent reads from it will return its default value.
      mutating func clearDestinationServiceID() {self._destinationServiceID = nil}

      var unidentified: Bool {
        get {return _unidentified ?? false}
        set {_unidentified = newValue}
      }
      /// Returns true if `unidentified` has been explicitly set.
      var hasUnidentified: Bool {return self._unidentified != nil}
      /// Clears the value of `unidentified`. Subsequent reads from it will return its default value.
      mutating func clearUnidentified() {self._unidentified = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _destinationServiceID: String? = nil
      fileprivate var _unidentified: Bool? = nil
    }

    struct StoryMessageRecipient: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var destinationServiceID: String {
        get {return _destinationServiceID ?? String()}
        set {_destinationServiceID = newValue}
      }
      /// Returns true if `destinationServiceID` has been explicitly set.
      var hasDestinationServiceID: Bool {return self._destinationServiceID != nil}
      /// Clears the value of `destinationServiceID`. Subsequent reads from it will return its default value.
      mutating func clearDestinationServiceID() {self._destinationServiceID = nil}

      var distributionListIds: [String] = []

      var isAllowedToReply: Bool {
        get {return _isAllowedToReply ?? false}
        set {_isAllowedToReply = newValue}
      }
      /// Returns true if `isAllowedToReply` has been explicitly set.
      var hasIsAllowedToReply: Bool {return self._isAllowedToReply != nil}
      /// Clears the value of `isAllowedToReply`. Subsequent reads from it will return its default value.
      mutating func clearIsAllowedToReply() {self._isAllowedToReply = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _destinationServiceID: String? = nil
      fileprivate var _isAllowedToReply: Bool? = nil
    }

    init() {}

    fileprivate var _destinationE164: String? = nil
    fileprivate var _destinationServiceID: String? = nil
    fileprivate var _timestamp: UInt64? = nil
    fileprivate var _message: SignalServiceProtos_DataMessage? = nil
    fileprivate var _expirationStartTimestamp: UInt64? = nil
    fileprivate var _isRecipientUpdate: Bool? = nil
    fileprivate var _storyMessage: SignalServiceProtos_StoryMessage? = nil
    fileprivate var _editMessage: SignalServiceProtos_EditMessage? = nil
  }

  struct Contacts: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var blob: SignalServiceProtos_AttachmentPointer {
      get {return _storage._blob ?? SignalServiceProtos_AttachmentPointer()}
      set {_uniqueStorage()._blob = newValue}
    }
    /// Returns true if `blob` has been explicitly set.
    var hasBlob: Bool {return _storage._blob != nil}
    /// Clears the value of `blob`. Subsequent reads from it will return its default value.
    mutating func clearBlob() {_uniqueStorage()._blob = nil}

    /// Signal-iOS renamed this property.
    var isComplete: Bool {
      get {return _storage._isComplete ?? false}
      set {_uniqueStorage()._isComplete = newValue}
    }
    /// Returns true if `isComplete` has been explicitly set.
    var hasIsComplete: Bool {return _storage._isComplete != nil}
    /// Clears the value of `isComplete`. Subsequent reads from it will return its default value.
    mutating func clearIsComplete() {_uniqueStorage()._isComplete = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct Blocked: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var numbers: [String] = []

    var acis: [String] = []

    var groupIds: [Data] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Request: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: SignalServiceProtos_SyncMessage.Request.TypeEnum {
      get {return _type ?? .unknown}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() {self._type = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TypeEnum: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
      case unknown = 0
      case contacts = 1
      case blocked = 3
      case configuration = 4
      case keys = 5

      init() {
        self = .unknown
      }

    }

    init() {}

    fileprivate var _type: SignalServiceProtos_SyncMessage.Request.TypeEnum? = nil
  }

  struct Read: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var senderAci: String {
      get {return _senderAci ?? String()}
      set {_senderAci = newValue}
    }
    /// Returns true if `senderAci` has been explicitly set.
    var hasSenderAci: Bool {return self._senderAci != nil}
    /// Clears the value of `senderAci`. Subsequent reads from it will return its default value.
    mutating func clearSenderAci() {self._senderAci = nil}

    /// @required
    var timestamp: UInt64 {
      get {return _timestamp ?? 0}
      set {_timestamp = newValue}
    }
    /// Returns true if `timestamp` has been explicitly set.
    var hasTimestamp: Bool {return self._timestamp != nil}
    /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
    mutating func clearTimestamp() {self._timestamp = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _senderAci: String? = nil
    fileprivate var _timestamp: UInt64? = nil
  }

  struct Viewed: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var senderAci: String {
      get {return _senderAci ?? String()}
      set {_senderAci = newValue}
    }
    /// Returns true if `senderAci` has been explicitly set.
    var hasSenderAci: Bool {return self._senderAci != nil}
    /// Clears the value of `senderAci`. Subsequent reads from it will return its default value.
    mutating func clearSenderAci() {self._senderAci = nil}

    /// @required
    var timestamp: UInt64 {
      get {return _timestamp ?? 0}
      set {_timestamp = newValue}
    }
    /// Returns true if `timestamp` has been explicitly set.
    var hasTimestamp: Bool {return self._timestamp != nil}
    /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
    mutating func clearTimestamp() {self._timestamp = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _senderAci: String? = nil
    fileprivate var _timestamp: UInt64? = nil
  }

  struct Configuration: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var readReceipts: Bool {
      get {return _readReceipts ?? false}
      set {_readReceipts = newValue}
    }
    /// Returns true if `readReceipts` has been explicitly set.
    var hasReadReceipts: Bool {return self._readReceipts != nil}
    /// Clears the value of `readReceipts`. Subsequent reads from it will return its default value.
    mutating func clearReadReceipts() {self._readReceipts = nil}

    var unidentifiedDeliveryIndicators: Bool {
      get {return _unidentifiedDeliveryIndicators ?? false}
      set {_unidentifiedDeliveryIndicators = newValue}
    }
    /// Returns true if `unidentifiedDeliveryIndicators` has been explicitly set.
    var hasUnidentifiedDeliveryIndicators: Bool {return self._unidentifiedDeliveryIndicators != nil}
    /// Clears the value of `unidentifiedDeliveryIndicators`. Subsequent reads from it will return its default value.
    mutating func clearUnidentifiedDeliveryIndicators() {self._unidentifiedDeliveryIndicators = nil}

    var typingIndicators: Bool {
      get {return _typingIndicators ?? false}
      set {_typingIndicators = newValue}
    }
    /// Returns true if `typingIndicators` has been explicitly set.
    var hasTypingIndicators: Bool {return self._typingIndicators != nil}
    /// Clears the value of `typingIndicators`. Subsequent reads from it will return its default value.
    mutating func clearTypingIndicators() {self._typingIndicators = nil}

    var provisioningVersion: UInt32 {
      get {return _provisioningVersion ?? 0}
      set {_provisioningVersion = newValue}
    }
    /// Returns true if `provisioningVersion` has been explicitly set.
    var hasProvisioningVersion: Bool {return self._provisioningVersion != nil}
    /// Clears the value of `provisioningVersion`. Subsequent reads from it will return its default value.
    mutating func clearProvisioningVersion() {self._provisioningVersion = nil}

    var linkPreviews: Bool {
      get {return _linkPreviews ?? false}
      set {_linkPreviews = newValue}
    }
    /// Returns true if `linkPreviews` has been explicitly set.
    var hasLinkPreviews: Bool {return self._linkPreviews != nil}
    /// Clears the value of `linkPreviews`. Subsequent reads from it will return its default value.
    mutating func clearLinkPreviews() {self._linkPreviews = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _readReceipts: Bool? = nil
    fileprivate var _unidentifiedDeliveryIndicators: Bool? = nil
    fileprivate var _typingIndicators: Bool? = nil
    fileprivate var _provisioningVersion: UInt32? = nil
    fileprivate var _linkPreviews: Bool? = nil
  }

  struct StickerPackOperation: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var packID: Data {
      get {return _packID ?? Data()}
      set {_packID = newValue}
    }
    /// Returns true if `packID` has been explicitly set.
    var hasPackID: Bool {return self._packID != nil}
    /// Clears the value of `packID`. Subsequent reads from it will return its default value.
    mutating func clearPackID() {self._packID = nil}

    /// @required
    var packKey: Data {
      get {return _packKey ?? Data()}
      set {_packKey = newValue}
    }
    /// Returns true if `packKey` has been explicitly set.
    var hasPackKey: Bool {return self._packKey != nil}
    /// Clears the value of `packKey`. Subsequent reads from it will return its default value.
    mutating func clearPackKey() {self._packKey = nil}

    var type: SignalServiceProtos_SyncMessage.StickerPackOperation.TypeEnum {
      get {return _type ?? .install}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() {self._type = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TypeEnum: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
      case install = 0
      case remove = 1

      init() {
        self = .install
      }

    }

    init() {}

    fileprivate var _packID: Data? = nil
    fileprivate var _packKey: Data? = nil
    fileprivate var _type: SignalServiceProtos_SyncMessage.StickerPackOperation.TypeEnum? = nil
  }

  struct ViewOnceOpen: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var senderAci: String {
      get {return _senderAci ?? String()}
      set {_senderAci = newValue}
    }
    /// Returns true if `senderAci` has been explicitly set.
    var hasSenderAci: Bool {return self._senderAci != nil}
    /// Clears the value of `senderAci`. Subsequent reads from it will return its default value.
    mutating func clearSenderAci() {self._senderAci = nil}

    /// @required
    var timestamp: UInt64 {
      get {return _timestamp ?? 0}
      set {_timestamp = newValue}
    }
    /// Returns true if `timestamp` has been explicitly set.
    var hasTimestamp: Bool {return self._timestamp != nil}
    /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
    mutating func clearTimestamp() {self._timestamp = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _senderAci: String? = nil
    fileprivate var _timestamp: UInt64? = nil
  }

  struct FetchLatest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: SignalServiceProtos_SyncMessage.FetchLatest.TypeEnum {
      get {return _type ?? .unknown}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() {self._type = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TypeEnum: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
      case unknown = 0
      case localProfile = 1
      case storageManifest = 2
      case subscriptionStatus = 3

      init() {
        self = .unknown
      }

    }

    init() {}

    fileprivate var _type: SignalServiceProtos_SyncMessage.FetchLatest.TypeEnum? = nil
  }

  struct Keys: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var master: Data {
      get {return _master ?? Data()}
      set {_master = newValue}
    }
    /// Returns true if `master` has been explicitly set.
    var hasMaster: Bool {return self._master != nil}
    /// Clears the value of `master`. Subsequent reads from it will return its default value.
    mutating func clearMaster() {self._master = nil}

    var accountEntropyPool: String {
      get {return _accountEntropyPool ?? String()}
      set {_accountEntropyPool = newValue}
    }
    /// Returns true if `accountEntropyPool` has been explicitly set.
    var hasAccountEntropyPool: Bool {return self._accountEntropyPool != nil}
    /// Clears the value of `accountEntropyPool`. Subsequent reads from it will return its default value.
    mutating func clearAccountEntropyPool() {self._accountEntropyPool = nil}

    var mediaRootBackupKey: Data {
      get {return _mediaRootBackupKey ?? Data()}
      set {_mediaRootBackupKey = newValue}
    }
    /// Returns true if `mediaRootBackupKey` has been explicitly set.
    var hasMediaRootBackupKey: Bool {return self._mediaRootBackupKey != nil}
    /// Clears the value of `mediaRootBackupKey`. Subsequent reads from it will return its default value.
    mutating func clearMediaRootBackupKey() {self._mediaRootBackupKey = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _master: Data? = nil
    fileprivate var _accountEntropyPool: String? = nil
    fileprivate var _mediaRootBackupKey: Data? = nil
  }

  struct MessageRequestResponse: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var threadAci: String {
      get {return _threadAci ?? String()}
      set {_threadAci = newValue}
    }
    /// Returns true if `threadAci` has been explicitly set.
    var hasThreadAci: Bool {return self._threadAci != nil}
    /// Clears the value of `threadAci`. Subsequent reads from it will return its default value.
    mutating func clearThreadAci() {self._threadAci = nil}

    var groupID: Data {
      get {return _groupID ?? Data()}
      set {_groupID = newValue}
    }
    /// Returns true if `groupID` has been explicitly set.
    var hasGroupID: Bool {return self._groupID != nil}
    /// Clears the value of `groupID`. Subsequent reads from it will return its default value.
    mutating func clearGroupID() {self._groupID = nil}

    var type: SignalServiceProtos_SyncMessage.MessageRequestResponse.TypeEnum {
      get {return _type ?? .unknown}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() {self._type = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TypeEnum: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
      case unknown = 0
      case accept = 1
      case delete = 2
      case block = 3
      case blockAndDelete = 4
      case spam = 5
      case blockAndSpam = 6

      init() {
        self = .unknown
      }

    }

    init() {}

    fileprivate var _threadAci: String? = nil
    fileprivate var _groupID: Data? = nil
    fileprivate var _type: SignalServiceProtos_SyncMessage.MessageRequestResponse.TypeEnum? = nil
  }

  struct OutgoingPayment: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var recipientServiceID: String {
      get {return _recipientServiceID ?? String()}
      set {_recipientServiceID = newValue}
    }
    /// Returns true if `recipientServiceID` has been explicitly set.
    var hasRecipientServiceID: Bool {return self._recipientServiceID != nil}
    /// Clears the value of `recipientServiceID`. Subsequent reads from it will return its default value.
    mutating func clearRecipientServiceID() {self._recipientServiceID = nil}

    var note: String {
      get {return _note ?? String()}
      set {_note = newValue}
    }
    /// Returns true if `note` has been explicitly set.
    var hasNote: Bool {return self._note != nil}
    /// Clears the value of `note`. Subsequent reads from it will return its default value.
    mutating func clearNote() {self._note = nil}

    /// oneof attachment_identifier {
    var mobileCoin: SignalServiceProtos_SyncMessage.OutgoingPayment.MobileCoin {
      get {return _mobileCoin ?? SignalServiceProtos_SyncMessage.OutgoingPayment.MobileCoin()}
      set {_mobileCoin = newValue}
    }
    /// Returns true if `mobileCoin` has been explicitly set.
    var hasMobileCoin: Bool {return self._mobileCoin != nil}
    /// Clears the value of `mobileCoin`. Subsequent reads from it will return its default value.
    mutating func clearMobileCoin() {self._mobileCoin = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct MobileCoin: @unchecked Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var recipientAddress: Data {
        get {return _recipientAddress ?? Data()}
        set {_recipientAddress = newValue}
      }
      /// Returns true if `recipientAddress` has been explicitly set.
      var hasRecipientAddress: Bool {return self._recipientAddress != nil}
      /// Clears the value of `recipientAddress`. Subsequent reads from it will return its default value.
      mutating func clearRecipientAddress() {self._recipientAddress = nil}

      /// @required
      var amountPicoMob: UInt64 {
        get {return _amountPicoMob ?? 0}
        set {_amountPicoMob = newValue}
      }
      /// Returns true if `amountPicoMob` has been explicitly set.
      var hasAmountPicoMob: Bool {return self._amountPicoMob != nil}
      /// Clears the value of `amountPicoMob`. Subsequent reads from it will return its default value.
      mutating func clearAmountPicoMob() {self._amountPicoMob = nil}

      /// @required
      var feePicoMob: UInt64 {
        get {return _feePicoMob ?? 0}
        set {_feePicoMob = newValue}
      }
      /// Returns true if `feePicoMob` has been explicitly set.
      var hasFeePicoMob: Bool {return self._feePicoMob != nil}
      /// Clears the value of `feePicoMob`. Subsequent reads from it will return its default value.
      mutating func clearFeePicoMob() {self._feePicoMob = nil}

      var receipt: Data {
        get {return _receipt ?? Data()}
        set {_receipt = newValue}
      }
      /// Returns true if `receipt` has been explicitly set.
      var hasReceipt: Bool {return self._receipt != nil}
      /// Clears the value of `receipt`. Subsequent reads from it will return its default value.
      mutating func clearReceipt() {self._receipt = nil}

      var ledgerBlockTimestamp: UInt64 {
        get {return _ledgerBlockTimestamp ?? 0}
        set {_ledgerBlockTimestamp = newValue}
      }
      /// Returns true if `ledgerBlockTimestamp` has been explicitly set.
      var hasLedgerBlockTimestamp: Bool {return self._ledgerBlockTimestamp != nil}
      /// Clears the value of `ledgerBlockTimestamp`. Subsequent reads from it will return its default value.
      mutating func clearLedgerBlockTimestamp() {self._ledgerBlockTimestamp = nil}

      /// @required
      var ledgerBlockIndex: UInt64 {
        get {return _ledgerBlockIndex ?? 0}
        set {_ledgerBlockIndex = newValue}
      }
      /// Returns true if `ledgerBlockIndex` has been explicitly set.
      var hasLedgerBlockIndex: Bool {return self._ledgerBlockIndex != nil}
      /// Clears the value of `ledgerBlockIndex`. Subsequent reads from it will return its default value.
      mutating func clearLedgerBlockIndex() {self._ledgerBlockIndex = nil}

      var spentKeyImages: [Data] = []

      var outputPublicKeys: [Data] = []

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _recipientAddress: Data? = nil
      fileprivate var _amountPicoMob: UInt64? = nil
      fileprivate var _feePicoMob: UInt64? = nil
      fileprivate var _receipt: Data? = nil
      fileprivate var _ledgerBlockTimestamp: UInt64? = nil
      fileprivate var _ledgerBlockIndex: UInt64? = nil
    }

    init() {}

    fileprivate var _recipientServiceID: String? = nil
    fileprivate var _note: String? = nil
    fileprivate var _mobileCoin: SignalServiceProtos_SyncMessage.OutgoingPayment.MobileCoin? = nil
  }

  struct PniChangeNumber: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Serialized libsignal-client IdentityKeyPair
    var identityKeyPair: Data {
      get {return _identityKeyPair ?? Data()}
      set {_identityKeyPair = newValue}
    }
    /// Returns true if `identityKeyPair` has been explicitly set.
    var hasIdentityKeyPair: Bool {return self._identityKeyPair != nil}
    /// Clears the value of `identityKeyPair`. Subsequent reads from it will return its default value.
    mutating func clearIdentityKeyPair() {self._identityKeyPair = nil}

    /// Serialized libsignal-client SignedPreKeyRecord
    var signedPreKey: Data {
      get {return _signedPreKey ?? Data()}
      set {_signedPreKey = newValue}
    }
    /// Returns true if `signedPreKey` has been explicitly set.
    var hasSignedPreKey: Bool {return self._signedPreKey != nil}
    /// Clears the value of `signedPreKey`. Subsequent reads from it will return its default value.
    mutating func clearSignedPreKey() {self._signedPreKey = nil}

    /// Serialized libsignal-client KyberPreKeyRecord
    var lastResortKyberPreKey: Data {
      get {return _lastResortKyberPreKey ?? Data()}
      set {_lastResortKyberPreKey = newValue}
    }
    /// Returns true if `lastResortKyberPreKey` has been explicitly set.
    var hasLastResortKyberPreKey: Bool {return self._lastResortKyberPreKey != nil}
    /// Clears the value of `lastResortKyberPreKey`. Subsequent reads from it will return its default value.
    mutating func clearLastResortKyberPreKey() {self._lastResortKyberPreKey = nil}

    var registrationID: UInt32 {
      get {return _registrationID ?? 0}
      set {_registrationID = newValue}
    }
    /// Returns true if `registrationID` has been explicitly set.
    var hasRegistrationID: Bool {return self._registrationID != nil}
    /// Clears the value of `registrationID`. Subsequent reads from it will return its default value.
    mutating func clearRegistrationID() {self._registrationID = nil}

    var newE164: String {
      get {return _newE164 ?? String()}
      set {_newE164 = newValue}
    }
    /// Returns true if `newE164` has been explicitly set.
    var hasNewE164: Bool {return self._newE164 != nil}
    /// Clears the value of `newE164`. Subsequent reads from it will return its default value.
    mutating func clearNewE164() {self._newE164 = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _identityKeyPair: Data? = nil
    fileprivate var _signedPreKey: Data? = nil
    fileprivate var _lastResortKyberPreKey: Data? = nil
    fileprivate var _registrationID: UInt32? = nil
    fileprivate var _newE164: String? = nil
  }

  struct CallEvent: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Data identifying a conversation. The service ID for 1:1, the group ID for
    /// group, or the room ID for an ad-hoc call. See also
    /// `CallLogEvent/conversationId`. 
    var conversationID: Data {
      get {return _conversationID ?? Data()}
      set {_conversationID = newValue}
    }
    /// Returns true if `conversationID` has been explicitly set.
    var hasConversationID: Bool {return self._conversationID != nil}
    /// Clears the value of `conversationID`. Subsequent reads from it will return its default value.
    mutating func clearConversationID() {self._conversationID = nil}

    /// An identifier for a call. Generated directly for 1:1, or derived from
    /// the era ID for group and ad-hoc calls. See also `CallLogEvent/callId`. 
    var callID: UInt64 {
      get {return _callID ?? 0}
      set {_callID = newValue}
    }
    /// Returns true if `callID` has been explicitly set.
    var hasCallID: Bool {return self._callID != nil}
    /// Clears the value of `callID`. Subsequent reads from it will return its default value.
    mutating func clearCallID() {self._callID = nil}

    var timestamp: UInt64 {
      get {return _timestamp ?? 0}
      set {_timestamp = newValue}
    }
    /// Returns true if `timestamp` has been explicitly set.
    var hasTimestamp: Bool {return self._timestamp != nil}
    /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
    mutating func clearTimestamp() {self._timestamp = nil}

    var type: SignalServiceProtos_SyncMessage.CallEvent.TypeEnum {
      get {return _type ?? .unknownType}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() {self._type = nil}

    var direction: SignalServiceProtos_SyncMessage.CallEvent.Direction {
      get {return _direction ?? .unknownDirection}
      set {_direction = newValue}
    }
    /// Returns true if `direction` has been explicitly set.
    var hasDirection: Bool {return self._direction != nil}
    /// Clears the value of `direction`. Subsequent reads from it will return its default value.
    mutating func clearDirection() {self._direction = nil}

    var event: SignalServiceProtos_SyncMessage.CallEvent.Event {
      get {return _event ?? .unknownAction}
      set {_event = newValue}
    }
    /// Returns true if `event` has been explicitly set.
    var hasEvent: Bool {return self._event != nil}
    /// Clears the value of `event`. Subsequent reads from it will return its default value.
    mutating func clearEvent() {self._event = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TypeEnum: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
      case unknownType = 0
      case audioCall = 1
      case videoCall = 2
      case groupCall = 3
      case adHocCall = 4

      init() {
        self = .unknownType
      }

    }

    enum Direction: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
      case unknownDirection = 0
      case incoming = 1
      case outgoing = 2

      init() {
        self = .unknownDirection
      }

    }

    enum Event: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
      case unknownAction = 0
      case accepted = 1
      case notAccepted = 2
      case deleted = 3
      case observed = 4

      init() {
        self = .unknownAction
      }

    }

    init() {}

    fileprivate var _conversationID: Data? = nil
    fileprivate var _callID: UInt64? = nil
    fileprivate var _timestamp: UInt64? = nil
    fileprivate var _type: SignalServiceProtos_SyncMessage.CallEvent.TypeEnum? = nil
    fileprivate var _direction: SignalServiceProtos_SyncMessage.CallEvent.Direction? = nil
    fileprivate var _event: SignalServiceProtos_SyncMessage.CallEvent.Event? = nil
  }

  struct CallLinkUpdate: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var rootKey: Data {
      get {return _rootKey ?? Data()}
      set {_rootKey = newValue}
    }
    /// Returns true if `rootKey` has been explicitly set.
    var hasRootKey: Bool {return self._rootKey != nil}
    /// Clears the value of `rootKey`. Subsequent reads from it will return its default value.
    mutating func clearRootKey() {self._rootKey = nil}

    var adminPasskey: Data {
      get {return _adminPasskey ?? Data()}
      set {_adminPasskey = newValue}
    }
    /// Returns true if `adminPasskey` has been explicitly set.
    var hasAdminPasskey: Bool {return self._adminPasskey != nil}
    /// Clears the value of `adminPasskey`. Subsequent reads from it will return its default value.
    mutating func clearAdminPasskey() {self._adminPasskey = nil}

    /// defaults to UPDATE
    var type: SignalServiceProtos_SyncMessage.CallLinkUpdate.TypeEnum {
      get {return _type ?? .update}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() {self._type = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TypeEnum: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
      case update = 0

      init() {
        self = .update
      }

    }

    init() {}

    fileprivate var _rootKey: Data? = nil
    fileprivate var _adminPasskey: Data? = nil
    fileprivate var _type: SignalServiceProtos_SyncMessage.CallLinkUpdate.TypeEnum? = nil
  }

  struct CallLogEvent: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: SignalServiceProtos_SyncMessage.CallLogEvent.TypeEnum {
      get {return _type ?? .cleared}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() {self._type = nil}

    var timestamp: UInt64 {
      get {return _timestamp ?? 0}
      set {_timestamp = newValue}
    }
    /// Returns true if `timestamp` has been explicitly set.
    var hasTimestamp: Bool {return self._timestamp != nil}
    /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
    mutating func clearTimestamp() {self._timestamp = nil}

    /// Data identifying a conversation. The service ID for 1:1, the group ID for
    /// group, or the room ID for an ad-hoc call. See also
    /// `CallEvent/conversationId`. 
    var conversationID: Data {
      get {return _conversationID ?? Data()}
      set {_conversationID = newValue}
    }
    /// Returns true if `conversationID` has been explicitly set.
    var hasConversationID: Bool {return self._conversationID != nil}
    /// Clears the value of `conversationID`. Subsequent reads from it will return its default value.
    mutating func clearConversationID() {self._conversationID = nil}

    /// An identifier for a call. Generated directly for 1:1, or derived from
    /// the era ID for group and ad-hoc calls. See also `CallEvent/callId`. 
    var callID: UInt64 {
      get {return _callID ?? 0}
      set {_callID = newValue}
    }
    /// Returns true if `callID` has been explicitly set.
    var hasCallID: Bool {return self._callID != nil}
    /// Clears the value of `callID`. Subsequent reads from it will return its default value.
    mutating func clearCallID() {self._callID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TypeEnum: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
      case cleared = 0
      case markedAsRead = 1
      case markedAsReadInConversation = 2

      init() {
        self = .cleared
      }

    }

    init() {}

    fileprivate var _type: SignalServiceProtos_SyncMessage.CallLogEvent.TypeEnum? = nil
    fileprivate var _timestamp: UInt64? = nil
    fileprivate var _conversationID: Data? = nil
    fileprivate var _callID: UInt64? = nil
  }

  struct DeleteForMe: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var messageDeletes: [SignalServiceProtos_SyncMessage.DeleteForMe.MessageDeletes] = []

    var conversationDeletes: [SignalServiceProtos_SyncMessage.DeleteForMe.ConversationDelete] = []

    var localOnlyConversationDeletes: [SignalServiceProtos_SyncMessage.DeleteForMe.LocalOnlyConversationDelete] = []

    var attachmentDeletes: [SignalServiceProtos_SyncMessage.DeleteForMe.AttachmentDelete] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct ConversationIdentifier: @unchecked Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// oneof identifier {
      var threadServiceID: String {
        get {return _threadServiceID ?? String()}
        set {_threadServiceID = newValue}
      }
      /// Returns true if `threadServiceID` has been explicitly set.
      var hasThreadServiceID: Bool {return self._threadServiceID != nil}
      /// Clears the value of `threadServiceID`. Subsequent reads from it will return its default value.
      mutating func clearThreadServiceID() {self._threadServiceID = nil}

      var threadGroupID: Data {
        get {return _threadGroupID ?? Data()}
        set {_threadGroupID = newValue}
      }
      /// Returns true if `threadGroupID` has been explicitly set.
      var hasThreadGroupID: Bool {return self._threadGroupID != nil}
      /// Clears the value of `threadGroupID`. Subsequent reads from it will return its default value.
      mutating func clearThreadGroupID() {self._threadGroupID = nil}

      /// }
      var threadE164: String {
        get {return _threadE164 ?? String()}
        set {_threadE164 = newValue}
      }
      /// Returns true if `threadE164` has been explicitly set.
      var hasThreadE164: Bool {return self._threadE164 != nil}
      /// Clears the value of `threadE164`. Subsequent reads from it will return its default value.
      mutating func clearThreadE164() {self._threadE164 = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _threadServiceID: String? = nil
      fileprivate var _threadGroupID: Data? = nil
      fileprivate var _threadE164: String? = nil
    }

    struct AddressableMessage: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// oneof author {
      var authorServiceID: String {
        get {return _authorServiceID ?? String()}
        set {_authorServiceID = newValue}
      }
      /// Returns true if `authorServiceID` has been explicitly set.
      var hasAuthorServiceID: Bool {return self._authorServiceID != nil}
      /// Clears the value of `authorServiceID`. Subsequent reads from it will return its default value.
      mutating func clearAuthorServiceID() {self._authorServiceID = nil}

      var authorE164: String {
        get {return _authorE164 ?? String()}
        set {_authorE164 = newValue}
      }
      /// Returns true if `authorE164` has been explicitly set.
      var hasAuthorE164: Bool {return self._authorE164 != nil}
      /// Clears the value of `authorE164`. Subsequent reads from it will return its default value.
      mutating func clearAuthorE164() {self._authorE164 = nil}

      /// }
      var sentTimestamp: UInt64 {
        get {return _sentTimestamp ?? 0}
        set {_sentTimestamp = newValue}
      }
      /// Returns true if `sentTimestamp` has been explicitly set.
      var hasSentTimestamp: Bool {return self._sentTimestamp != nil}
      /// Clears the value of `sentTimestamp`. Subsequent reads from it will return its default value.
      mutating func clearSentTimestamp() {self._sentTimestamp = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _authorServiceID: String? = nil
      fileprivate var _authorE164: String? = nil
      fileprivate var _sentTimestamp: UInt64? = nil
    }

    struct MessageDeletes: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var conversation: SignalServiceProtos_SyncMessage.DeleteForMe.ConversationIdentifier {
        get {return _conversation ?? SignalServiceProtos_SyncMessage.DeleteForMe.ConversationIdentifier()}
        set {_conversation = newValue}
      }
      /// Returns true if `conversation` has been explicitly set.
      var hasConversation: Bool {return self._conversation != nil}
      /// Clears the value of `conversation`. Subsequent reads from it will return its default value.
      mutating func clearConversation() {self._conversation = nil}

      var messages: [SignalServiceProtos_SyncMessage.DeleteForMe.AddressableMessage] = []

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _conversation: SignalServiceProtos_SyncMessage.DeleteForMe.ConversationIdentifier? = nil
    }

    struct AttachmentDelete: @unchecked Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var conversation: SignalServiceProtos_SyncMessage.DeleteForMe.ConversationIdentifier {
        get {return _conversation ?? SignalServiceProtos_SyncMessage.DeleteForMe.ConversationIdentifier()}
        set {_conversation = newValue}
      }
      /// Returns true if `conversation` has been explicitly set.
      var hasConversation: Bool {return self._conversation != nil}
      /// Clears the value of `conversation`. Subsequent reads from it will return its default value.
      mutating func clearConversation() {self._conversation = nil}

      var targetMessage: SignalServiceProtos_SyncMessage.DeleteForMe.AddressableMessage {
        get {return _targetMessage ?? SignalServiceProtos_SyncMessage.DeleteForMe.AddressableMessage()}
        set {_targetMessage = newValue}
      }
      /// Returns true if `targetMessage` has been explicitly set.
      var hasTargetMessage: Bool {return self._targetMessage != nil}
      /// Clears the value of `targetMessage`. Subsequent reads from it will return its default value.
      mutating func clearTargetMessage() {self._targetMessage = nil}

      /// The `clientUuid` from `AttachmentPointer`.
      var clientUuid: Data {
        get {return _clientUuid ?? Data()}
        set {_clientUuid = newValue}
      }
      /// Returns true if `clientUuid` has been explicitly set.
      var hasClientUuid: Bool {return self._clientUuid != nil}
      /// Clears the value of `clientUuid`. Subsequent reads from it will return its default value.
      mutating func clearClientUuid() {self._clientUuid = nil}

      /// SHA256 hash of the (encrypted, padded, etc.) attachment blob on the CDN.
      var fallbackDigest: Data {
        get {return _fallbackDigest ?? Data()}
        set {_fallbackDigest = newValue}
      }
      /// Returns true if `fallbackDigest` has been explicitly set.
      var hasFallbackDigest: Bool {return self._fallbackDigest != nil}
      /// Clears the value of `fallbackDigest`. Subsequent reads from it will return its default value.
      mutating func clearFallbackDigest() {self._fallbackDigest = nil}

      /// SHA256 hash of the plaintext content of the attachment.
      var fallbackPlaintextHash: Data {
        get {return _fallbackPlaintextHash ?? Data()}
        set {_fallbackPlaintextHash = newValue}
      }
      /// Returns true if `fallbackPlaintextHash` has been explicitly set.
      var hasFallbackPlaintextHash: Bool {return self._fallbackPlaintextHash != nil}
      /// Clears the value of `fallbackPlaintextHash`. Subsequent reads from it will return its default value.
      mutating func clearFallbackPlaintextHash() {self._fallbackPlaintextHash = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _conversation: SignalServiceProtos_SyncMessage.DeleteForMe.ConversationIdentifier? = nil
      fileprivate var _targetMessage: SignalServiceProtos_SyncMessage.DeleteForMe.AddressableMessage? = nil
      fileprivate var _clientUuid: Data? = nil
      fileprivate var _fallbackDigest: Data? = nil
      fileprivate var _fallbackPlaintextHash: Data? = nil
    }

    struct ConversationDelete: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var conversation: SignalServiceProtos_SyncMessage.DeleteForMe.ConversationIdentifier {
        get {return _conversation ?? SignalServiceProtos_SyncMessage.DeleteForMe.ConversationIdentifier()}
        set {_conversation = newValue}
      }
      /// Returns true if `conversation` has been explicitly set.
      var hasConversation: Bool {return self._conversation != nil}
      /// Clears the value of `conversation`. Subsequent reads from it will return its default value.
      mutating func clearConversation() {self._conversation = nil}

      var mostRecentMessages: [SignalServiceProtos_SyncMessage.DeleteForMe.AddressableMessage] = []

      var mostRecentNonExpiringMessages: [SignalServiceProtos_SyncMessage.DeleteForMe.AddressableMessage] = []

      var isFullDelete: Bool {
        get {return _isFullDelete ?? false}
        set {_isFullDelete = newValue}
      }
      /// Returns true if `isFullDelete` has been explicitly set.
      var hasIsFullDelete: Bool {return self._isFullDelete != nil}
      /// Clears the value of `isFullDelete`. Subsequent reads from it will return its default value.
      mutating func clearIsFullDelete() {self._isFullDelete = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _conversation: SignalServiceProtos_SyncMessage.DeleteForMe.ConversationIdentifier? = nil
      fileprivate var _isFullDelete: Bool? = nil
    }

    struct LocalOnlyConversationDelete: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var conversation: SignalServiceProtos_SyncMessage.DeleteForMe.ConversationIdentifier {
        get {return _conversation ?? SignalServiceProtos_SyncMessage.DeleteForMe.ConversationIdentifier()}
        set {_conversation = newValue}
      }
      /// Returns true if `conversation` has been explicitly set.
      var hasConversation: Bool {return self._conversation != nil}
      /// Clears the value of `conversation`. Subsequent reads from it will return its default value.
      mutating func clearConversation() {self._conversation = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _conversation: SignalServiceProtos_SyncMessage.DeleteForMe.ConversationIdentifier? = nil
    }

    init() {}
  }

  struct DeviceNameChange: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var deviceID: UInt32 {
      get {return _deviceID ?? 0}
      set {_deviceID = newValue}
    }
    /// Returns true if `deviceID` has been explicitly set.
    var hasDeviceID: Bool {return self._deviceID != nil}
    /// Clears the value of `deviceID`. Subsequent reads from it will return its default value.
    mutating func clearDeviceID() {self._deviceID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _deviceID: UInt32? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct SignalServiceProtos_AttachmentPointer: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// oneof commented out because swift generated
  /// enum with associated values can't be converted
  /// to objc representation
  ///
  /// oneof attachment_identifier {
  var cdnID: UInt64 {
    get {return _cdnID ?? 0}
    set {_cdnID = newValue}
  }
  /// Returns true if `cdnID` has been explicitly set.
  var hasCdnID: Bool {return self._cdnID != nil}
  /// Clears the value of `cdnID`. Subsequent reads from it will return its default value.
  mutating func clearCdnID() {self._cdnID = nil}

  /// }
  var cdnKey: String {
    get {return _cdnKey ?? String()}
    set {_cdnKey = newValue}
  }
  /// Returns true if `cdnKey` has been explicitly set.
  var hasCdnKey: Bool {return self._cdnKey != nil}
  /// Clears the value of `cdnKey`. Subsequent reads from it will return its default value.
  mutating func clearCdnKey() {self._cdnKey = nil}

  /// Cross-client identifier for this attachment among all attachments on the
  /// owning message.
  var clientUuid: Data {
    get {return _clientUuid ?? Data()}
    set {_clientUuid = newValue}
  }
  /// Returns true if `clientUuid` has been explicitly set.
  var hasClientUuid: Bool {return self._clientUuid != nil}
  /// Clears the value of `clientUuid`. Subsequent reads from it will return its default value.
  mutating func clearClientUuid() {self._clientUuid = nil}

  var contentType: String {
    get {return _contentType ?? String()}
    set {_contentType = newValue}
  }
  /// Returns true if `contentType` has been explicitly set.
  var hasContentType: Bool {return self._contentType != nil}
  /// Clears the value of `contentType`. Subsequent reads from it will return its default value.
  mutating func clearContentType() {self._contentType = nil}

  var key: Data {
    get {return _key ?? Data()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  var size: UInt32 {
    get {return _size ?? 0}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  mutating func clearSize() {self._size = nil}

  var thumbnail: Data {
    get {return _thumbnail ?? Data()}
    set {_thumbnail = newValue}
  }
  /// Returns true if `thumbnail` has been explicitly set.
  var hasThumbnail: Bool {return self._thumbnail != nil}
  /// Clears the value of `thumbnail`. Subsequent reads from it will return its default value.
  mutating func clearThumbnail() {self._thumbnail = nil}

  var digest: Data {
    get {return _digest ?? Data()}
    set {_digest = newValue}
  }
  /// Returns true if `digest` has been explicitly set.
  var hasDigest: Bool {return self._digest != nil}
  /// Clears the value of `digest`. Subsequent reads from it will return its default value.
  mutating func clearDigest() {self._digest = nil}

  var fileName: String {
    get {return _fileName ?? String()}
    set {_fileName = newValue}
  }
  /// Returns true if `fileName` has been explicitly set.
  var hasFileName: Bool {return self._fileName != nil}
  /// Clears the value of `fileName`. Subsequent reads from it will return its default value.
  mutating func clearFileName() {self._fileName = nil}

  var flags: UInt32 {
    get {return _flags ?? 0}
    set {_flags = newValue}
  }
  /// Returns true if `flags` has been explicitly set.
  var hasFlags: Bool {return self._flags != nil}
  /// Clears the value of `flags`. Subsequent reads from it will return its default value.
  mutating func clearFlags() {self._flags = nil}

  var width: UInt32 {
    get {return _width ?? 0}
    set {_width = newValue}
  }
  /// Returns true if `width` has been explicitly set.
  var hasWidth: Bool {return self._width != nil}
  /// Clears the value of `width`. Subsequent reads from it will return its default value.
  mutating func clearWidth() {self._width = nil}

  var height: UInt32 {
    get {return _height ?? 0}
    set {_height = newValue}
  }
  /// Returns true if `height` has been explicitly set.
  var hasHeight: Bool {return self._height != nil}
  /// Clears the value of `height`. Subsequent reads from it will return its default value.
  mutating func clearHeight() {self._height = nil}

  var caption: String {
    get {return _caption ?? String()}
    set {_caption = newValue}
  }
  /// Returns true if `caption` has been explicitly set.
  var hasCaption: Bool {return self._caption != nil}
  /// Clears the value of `caption`. Subsequent reads from it will return its default value.
  mutating func clearCaption() {self._caption = nil}

  var blurHash: String {
    get {return _blurHash ?? String()}
    set {_blurHash = newValue}
  }
  /// Returns true if `blurHash` has been explicitly set.
  var hasBlurHash: Bool {return self._blurHash != nil}
  /// Clears the value of `blurHash`. Subsequent reads from it will return its default value.
  mutating func clearBlurHash() {self._blurHash = nil}

  var uploadTimestamp: UInt64 {
    get {return _uploadTimestamp ?? 0}
    set {_uploadTimestamp = newValue}
  }
  /// Returns true if `uploadTimestamp` has been explicitly set.
  var hasUploadTimestamp: Bool {return self._uploadTimestamp != nil}
  /// Clears the value of `uploadTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearUploadTimestamp() {self._uploadTimestamp = nil}

  /// Next ID: 21
  var cdnNumber: UInt32 {
    get {return _cdnNumber ?? 0}
    set {_cdnNumber = newValue}
  }
  /// Returns true if `cdnNumber` has been explicitly set.
  var hasCdnNumber: Bool {return self._cdnNumber != nil}
  /// Clears the value of `cdnNumber`. Subsequent reads from it will return its default value.
  mutating func clearCdnNumber() {self._cdnNumber = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Flags: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case voiceMessage = 1
    case borderless = 2
    case gif = 8

    init() {
      self = .voiceMessage
    }

  }

  init() {}

  fileprivate var _cdnID: UInt64? = nil
  fileprivate var _cdnKey: String? = nil
  fileprivate var _clientUuid: Data? = nil
  fileprivate var _contentType: String? = nil
  fileprivate var _key: Data? = nil
  fileprivate var _size: UInt32? = nil
  fileprivate var _thumbnail: Data? = nil
  fileprivate var _digest: Data? = nil
  fileprivate var _fileName: String? = nil
  fileprivate var _flags: UInt32? = nil
  fileprivate var _width: UInt32? = nil
  fileprivate var _height: UInt32? = nil
  fileprivate var _caption: String? = nil
  fileprivate var _blurHash: String? = nil
  fileprivate var _uploadTimestamp: UInt64? = nil
  fileprivate var _cdnNumber: UInt32? = nil
}

struct SignalServiceProtos_GroupContextV2: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var masterKey: Data {
    get {return _masterKey ?? Data()}
    set {_masterKey = newValue}
  }
  /// Returns true if `masterKey` has been explicitly set.
  var hasMasterKey: Bool {return self._masterKey != nil}
  /// Clears the value of `masterKey`. Subsequent reads from it will return its default value.
  mutating func clearMasterKey() {self._masterKey = nil}

  var revision: UInt32 {
    get {return _revision ?? 0}
    set {_revision = newValue}
  }
  /// Returns true if `revision` has been explicitly set.
  var hasRevision: Bool {return self._revision != nil}
  /// Clears the value of `revision`. Subsequent reads from it will return its default value.
  mutating func clearRevision() {self._revision = nil}

  var groupChange: Data {
    get {return _groupChange ?? Data()}
    set {_groupChange = newValue}
  }
  /// Returns true if `groupChange` has been explicitly set.
  var hasGroupChange: Bool {return self._groupChange != nil}
  /// Clears the value of `groupChange`. Subsequent reads from it will return its default value.
  mutating func clearGroupChange() {self._groupChange = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _masterKey: Data? = nil
  fileprivate var _revision: UInt32? = nil
  fileprivate var _groupChange: Data? = nil
}

struct SignalServiceProtos_ContactDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var contactE164: String {
    get {return _contactE164 ?? String()}
    set {_contactE164 = newValue}
  }
  /// Returns true if `contactE164` has been explicitly set.
  var hasContactE164: Bool {return self._contactE164 != nil}
  /// Clears the value of `contactE164`. Subsequent reads from it will return its default value.
  mutating func clearContactE164() {self._contactE164 = nil}

  var aci: String {
    get {return _aci ?? String()}
    set {_aci = newValue}
  }
  /// Returns true if `aci` has been explicitly set.
  var hasAci: Bool {return self._aci != nil}
  /// Clears the value of `aci`. Subsequent reads from it will return its default value.
  mutating func clearAci() {self._aci = nil}

  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var avatar: SignalServiceProtos_ContactDetails.Avatar {
    get {return _avatar ?? SignalServiceProtos_ContactDetails.Avatar()}
    set {_avatar = newValue}
  }
  /// Returns true if `avatar` has been explicitly set.
  var hasAvatar: Bool {return self._avatar != nil}
  /// Clears the value of `avatar`. Subsequent reads from it will return its default value.
  mutating func clearAvatar() {self._avatar = nil}

  var expireTimer: UInt32 {
    get {return _expireTimer ?? 0}
    set {_expireTimer = newValue}
  }
  /// Returns true if `expireTimer` has been explicitly set.
  var hasExpireTimer: Bool {return self._expireTimer != nil}
  /// Clears the value of `expireTimer`. Subsequent reads from it will return its default value.
  mutating func clearExpireTimer() {self._expireTimer = nil}

  var expireTimerVersion: UInt32 {
    get {return _expireTimerVersion ?? 0}
    set {_expireTimerVersion = newValue}
  }
  /// Returns true if `expireTimerVersion` has been explicitly set.
  var hasExpireTimerVersion: Bool {return self._expireTimerVersion != nil}
  /// Clears the value of `expireTimerVersion`. Subsequent reads from it will return its default value.
  mutating func clearExpireTimerVersion() {self._expireTimerVersion = nil}

  var inboxPosition: UInt32 {
    get {return _inboxPosition ?? 0}
    set {_inboxPosition = newValue}
  }
  /// Returns true if `inboxPosition` has been explicitly set.
  var hasInboxPosition: Bool {return self._inboxPosition != nil}
  /// Clears the value of `inboxPosition`. Subsequent reads from it will return its default value.
  mutating func clearInboxPosition() {self._inboxPosition = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Avatar: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var contentType: String {
      get {return _contentType ?? String()}
      set {_contentType = newValue}
    }
    /// Returns true if `contentType` has been explicitly set.
    var hasContentType: Bool {return self._contentType != nil}
    /// Clears the value of `contentType`. Subsequent reads from it will return its default value.
    mutating func clearContentType() {self._contentType = nil}

    var length: UInt32 {
      get {return _length ?? 0}
      set {_length = newValue}
    }
    /// Returns true if `length` has been explicitly set.
    var hasLength: Bool {return self._length != nil}
    /// Clears the value of `length`. Subsequent reads from it will return its default value.
    mutating func clearLength() {self._length = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _contentType: String? = nil
    fileprivate var _length: UInt32? = nil
  }

  init() {}

  fileprivate var _contactE164: String? = nil
  fileprivate var _aci: String? = nil
  fileprivate var _name: String? = nil
  fileprivate var _avatar: SignalServiceProtos_ContactDetails.Avatar? = nil
  fileprivate var _expireTimer: UInt32? = nil
  fileprivate var _expireTimerVersion: UInt32? = nil
  fileprivate var _inboxPosition: UInt32? = nil
}

struct SignalServiceProtos_Pack: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String {
    get {return _title ?? String()}
    set {_title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  var hasTitle: Bool {return self._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  mutating func clearTitle() {self._title = nil}

  var author: String {
    get {return _author ?? String()}
    set {_author = newValue}
  }
  /// Returns true if `author` has been explicitly set.
  var hasAuthor: Bool {return self._author != nil}
  /// Clears the value of `author`. Subsequent reads from it will return its default value.
  mutating func clearAuthor() {self._author = nil}

  var cover: SignalServiceProtos_Pack.Sticker {
    get {return _cover ?? SignalServiceProtos_Pack.Sticker()}
    set {_cover = newValue}
  }
  /// Returns true if `cover` has been explicitly set.
  var hasCover: Bool {return self._cover != nil}
  /// Clears the value of `cover`. Subsequent reads from it will return its default value.
  mutating func clearCover() {self._cover = nil}

  var stickers: [SignalServiceProtos_Pack.Sticker] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Sticker: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var id: UInt32 {
      get {return _id ?? 0}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating func clearID() {self._id = nil}

    var emoji: String {
      get {return _emoji ?? String()}
      set {_emoji = newValue}
    }
    /// Returns true if `emoji` has been explicitly set.
    var hasEmoji: Bool {return self._emoji != nil}
    /// Clears the value of `emoji`. Subsequent reads from it will return its default value.
    mutating func clearEmoji() {self._emoji = nil}

    var contentType: String {
      get {return _contentType ?? String()}
      set {_contentType = newValue}
    }
    /// Returns true if `contentType` has been explicitly set.
    var hasContentType: Bool {return self._contentType != nil}
    /// Clears the value of `contentType`. Subsequent reads from it will return its default value.
    mutating func clearContentType() {self._contentType = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _id: UInt32? = nil
    fileprivate var _emoji: String? = nil
    fileprivate var _contentType: String? = nil
  }

  init() {}

  fileprivate var _title: String? = nil
  fileprivate var _author: String? = nil
  fileprivate var _cover: SignalServiceProtos_Pack.Sticker? = nil
}

struct SignalServiceProtos_PaymentAddress: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// oneof commented out
  /// oneof Address {
  var mobileCoin: SignalServiceProtos_PaymentAddress.MobileCoin {
    get {return _mobileCoin ?? SignalServiceProtos_PaymentAddress.MobileCoin()}
    set {_mobileCoin = newValue}
  }
  /// Returns true if `mobileCoin` has been explicitly set.
  var hasMobileCoin: Bool {return self._mobileCoin != nil}
  /// Clears the value of `mobileCoin`. Subsequent reads from it will return its default value.
  mutating func clearMobileCoin() {self._mobileCoin = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct MobileCoin: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var publicAddress: Data {
      get {return _publicAddress ?? Data()}
      set {_publicAddress = newValue}
    }
    /// Returns true if `publicAddress` has been explicitly set.
    var hasPublicAddress: Bool {return self._publicAddress != nil}
    /// Clears the value of `publicAddress`. Subsequent reads from it will return its default value.
    mutating func clearPublicAddress() {self._publicAddress = nil}

    /// @required
    var signature: Data {
      get {return _signature ?? Data()}
      set {_signature = newValue}
    }
    /// Returns true if `signature` has been explicitly set.
    var hasSignature: Bool {return self._signature != nil}
    /// Clears the value of `signature`. Subsequent reads from it will return its default value.
    mutating func clearSignature() {self._signature = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _publicAddress: Data? = nil
    fileprivate var _signature: Data? = nil
  }

  init() {}

  fileprivate var _mobileCoin: SignalServiceProtos_PaymentAddress.MobileCoin? = nil
}

struct SignalServiceProtos_DecryptionErrorMessage: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ratchetKey: Data {
    get {return _ratchetKey ?? Data()}
    set {_ratchetKey = newValue}
  }
  /// Returns true if `ratchetKey` has been explicitly set.
  var hasRatchetKey: Bool {return self._ratchetKey != nil}
  /// Clears the value of `ratchetKey`. Subsequent reads from it will return its default value.
  mutating func clearRatchetKey() {self._ratchetKey = nil}

  var timestamp: UInt64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var deviceID: UInt32 {
    get {return _deviceID ?? 0}
    set {_deviceID = newValue}
  }
  /// Returns true if `deviceID` has been explicitly set.
  var hasDeviceID: Bool {return self._deviceID != nil}
  /// Clears the value of `deviceID`. Subsequent reads from it will return its default value.
  mutating func clearDeviceID() {self._deviceID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ratchetKey: Data? = nil
  fileprivate var _timestamp: UInt64? = nil
  fileprivate var _deviceID: UInt32? = nil
}

struct SignalServiceProtos_PniSignatureMessage: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pni: Data {
    get {return _pni ?? Data()}
    set {_pni = newValue}
  }
  /// Returns true if `pni` has been explicitly set.
  var hasPni: Bool {return self._pni != nil}
  /// Clears the value of `pni`. Subsequent reads from it will return its default value.
  mutating func clearPni() {self._pni = nil}

  /// Signature *by* the PNI identity key *of* the ACI identity key
  var signature: Data {
    get {return _signature ?? Data()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  mutating func clearSignature() {self._signature = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pni: Data? = nil
  fileprivate var _signature: Data? = nil
}

struct SignalServiceProtos_BodyRange: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var start: UInt32 {
    get {return _start ?? 0}
    set {_start = newValue}
  }
  /// Returns true if `start` has been explicitly set.
  var hasStart: Bool {return self._start != nil}
  /// Clears the value of `start`. Subsequent reads from it will return its default value.
  mutating func clearStart() {self._start = nil}

  var length: UInt32 {
    get {return _length ?? 0}
    set {_length = newValue}
  }
  /// Returns true if `length` has been explicitly set.
  var hasLength: Bool {return self._length != nil}
  /// Clears the value of `length`. Subsequent reads from it will return its default value.
  mutating func clearLength() {self._length = nil}

  /// oneof commented out because swift generated
  /// enum with associated values can't be converted
  /// to objc representation
  ///
  /// oneof associatedValue {
  var mentionAci: String {
    get {return _mentionAci ?? String()}
    set {_mentionAci = newValue}
  }
  /// Returns true if `mentionAci` has been explicitly set.
  var hasMentionAci: Bool {return self._mentionAci != nil}
  /// Clears the value of `mentionAci`. Subsequent reads from it will return its default value.
  mutating func clearMentionAci() {self._mentionAci = nil}

  /// }
  var style: SignalServiceProtos_BodyRange.Style {
    get {return _style ?? .none}
    set {_style = newValue}
  }
  /// Returns true if `style` has been explicitly set.
  var hasStyle: Bool {return self._style != nil}
  /// Clears the value of `style`. Subsequent reads from it will return its default value.
  mutating func clearStyle() {self._style = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Style: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case none = 0
    case bold = 1
    case italic = 2
    case spoiler = 3
    case strikethrough = 4
    case monospace = 5

    init() {
      self = .none
    }

  }

  init() {}

  fileprivate var _start: UInt32? = nil
  fileprivate var _length: UInt32? = nil
  fileprivate var _mentionAci: String? = nil
  fileprivate var _style: SignalServiceProtos_BodyRange.Style? = nil
}

struct SignalServiceProtos_EditMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var targetSentTimestamp: UInt64 {
    get {return _targetSentTimestamp ?? 0}
    set {_targetSentTimestamp = newValue}
  }
  /// Returns true if `targetSentTimestamp` has been explicitly set.
  var hasTargetSentTimestamp: Bool {return self._targetSentTimestamp != nil}
  /// Clears the value of `targetSentTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearTargetSentTimestamp() {self._targetSentTimestamp = nil}

  var dataMessage: SignalServiceProtos_DataMessage {
    get {return _dataMessage ?? SignalServiceProtos_DataMessage()}
    set {_dataMessage = newValue}
  }
  /// Returns true if `dataMessage` has been explicitly set.
  var hasDataMessage: Bool {return self._dataMessage != nil}
  /// Clears the value of `dataMessage`. Subsequent reads from it will return its default value.
  mutating func clearDataMessage() {self._dataMessage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _targetSentTimestamp: UInt64? = nil
  fileprivate var _dataMessage: SignalServiceProtos_DataMessage? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "SignalServiceProtos"

extension SignalServiceProtos_Envelope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Envelope"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    7: .same(proto: "sourceDevice"),
    13: .same(proto: "destinationServiceId"),
    5: .same(proto: "timestamp"),
    8: .same(proto: "content"),
    9: .same(proto: "serverGuid"),
    10: .same(proto: "serverTimestamp"),
    11: .same(proto: "sourceServiceId"),
    15: .same(proto: "updatedPni"),
    16: .same(proto: "story"),
    17: .same(proto: "spamReportingToken"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._sourceDevice) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self._content) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._serverGuid) }()
      case 10: try { try decoder.decodeSingularUInt64Field(value: &self._serverTimestamp) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self._sourceServiceID) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self._destinationServiceID) }()
      case 15: try { try decoder.decodeSingularStringField(value: &self._updatedPni) }()
      case 16: try { try decoder.decodeSingularBoolField(value: &self._story) }()
      case 17: try { try decoder.decodeSingularBytesField(value: &self._spamReportingToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._sourceDevice {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._content {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._serverGuid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._serverTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._sourceServiceID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._destinationServiceID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 13)
    } }()
    try { if let v = self._updatedPni {
      try visitor.visitSingularStringField(value: v, fieldNumber: 15)
    } }()
    try { if let v = self._story {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 16)
    } }()
    try { if let v = self._spamReportingToken {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 17)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_Envelope, rhs: SignalServiceProtos_Envelope) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._sourceDevice != rhs._sourceDevice {return false}
    if lhs._destinationServiceID != rhs._destinationServiceID {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._content != rhs._content {return false}
    if lhs._serverGuid != rhs._serverGuid {return false}
    if lhs._serverTimestamp != rhs._serverTimestamp {return false}
    if lhs._sourceServiceID != rhs._sourceServiceID {return false}
    if lhs._updatedPni != rhs._updatedPni {return false}
    if lhs._story != rhs._story {return false}
    if lhs._spamReportingToken != rhs._spamReportingToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_Envelope.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "CIPHERTEXT"),
    3: .same(proto: "PREKEY_BUNDLE"),
    5: .same(proto: "RECEIPT"),
    6: .same(proto: "UNIDENTIFIED_SENDER"),
    8: .same(proto: "PLAINTEXT_CONTENT"),
  ]
}

extension SignalServiceProtos_TypingMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TypingMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "action"),
    3: .same(proto: "groupId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._action) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._groupID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._action {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._groupID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_TypingMessage, rhs: SignalServiceProtos_TypingMessage) -> Bool {
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._action != rhs._action {return false}
    if lhs._groupID != rhs._groupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_TypingMessage.Action: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STARTED"),
    1: .same(proto: "STOPPED"),
  ]
}

extension SignalServiceProtos_StoryMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StoryMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "profileKey"),
    2: .same(proto: "group"),
    3: .same(proto: "fileAttachment"),
    4: .same(proto: "textAttachment"),
    5: .same(proto: "allowsReplies"),
    6: .same(proto: "bodyRanges"),
  ]

  fileprivate class _StorageClass {
    var _profileKey: Data? = nil
    var _group: SignalServiceProtos_GroupContextV2? = nil
    var _fileAttachment: SignalServiceProtos_AttachmentPointer? = nil
    var _textAttachment: SignalServiceProtos_TextAttachment? = nil
    var _allowsReplies: Bool? = nil
    var _bodyRanges: [SignalServiceProtos_BodyRange] = []

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _profileKey = source._profileKey
      _group = source._group
      _fileAttachment = source._fileAttachment
      _textAttachment = source._textAttachment
      _allowsReplies = source._allowsReplies
      _bodyRanges = source._bodyRanges
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._profileKey) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._group) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._fileAttachment) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._textAttachment) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._allowsReplies) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._bodyRanges) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._profileKey {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._group {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._fileAttachment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._textAttachment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._allowsReplies {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
      if !_storage._bodyRanges.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._bodyRanges, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_StoryMessage, rhs: SignalServiceProtos_StoryMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._profileKey != rhs_storage._profileKey {return false}
        if _storage._group != rhs_storage._group {return false}
        if _storage._fileAttachment != rhs_storage._fileAttachment {return false}
        if _storage._textAttachment != rhs_storage._textAttachment {return false}
        if _storage._allowsReplies != rhs_storage._allowsReplies {return false}
        if _storage._bodyRanges != rhs_storage._bodyRanges {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_Preview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Preview"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "title"),
    3: .same(proto: "image"),
    4: .same(proto: "previewDescription"),
    5: .same(proto: "date"),
  ]

  fileprivate class _StorageClass {
    var _url: String? = nil
    var _title: String? = nil
    var _image: SignalServiceProtos_AttachmentPointer? = nil
    var _previewDescription: String? = nil
    var _date: UInt64? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _url = source._url
      _title = source._title
      _image = source._image
      _previewDescription = source._previewDescription
      _date = source._date
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._url) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._image) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._previewDescription) }()
        case 5: try { try decoder.decodeSingularUInt64Field(value: &_storage._date) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._url {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._title {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._image {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._previewDescription {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._date {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_Preview, rhs: SignalServiceProtos_Preview) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._url != rhs_storage._url {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._image != rhs_storage._image {return false}
        if _storage._previewDescription != rhs_storage._previewDescription {return false}
        if _storage._date != rhs_storage._date {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_TextAttachment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TextAttachment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "textStyle"),
    3: .same(proto: "textForegroundColor"),
    4: .same(proto: "textBackgroundColor"),
    5: .same(proto: "preview"),
    6: .same(proto: "gradient"),
    7: .same(proto: "color"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._text) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._textStyle) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._textForegroundColor) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._textBackgroundColor) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._preview) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._gradient) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._color) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._text {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._textStyle {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._textForegroundColor {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._textBackgroundColor {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._preview {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._gradient {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._color {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_TextAttachment, rhs: SignalServiceProtos_TextAttachment) -> Bool {
    if lhs._text != rhs._text {return false}
    if lhs._textStyle != rhs._textStyle {return false}
    if lhs._textForegroundColor != rhs._textForegroundColor {return false}
    if lhs._textBackgroundColor != rhs._textBackgroundColor {return false}
    if lhs._preview != rhs._preview {return false}
    if lhs._gradient != rhs._gradient {return false}
    if lhs._color != rhs._color {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_TextAttachment.Style: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "REGULAR"),
    2: .same(proto: "BOLD"),
    3: .same(proto: "SERIF"),
    4: .same(proto: "SCRIPT"),
    5: .same(proto: "CONDENSED"),
  ]
}

extension SignalServiceProtos_TextAttachment.Gradient: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_TextAttachment.protoMessageName + ".Gradient"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "startColor"),
    2: .same(proto: "endColor"),
    3: .same(proto: "angle"),
    4: .same(proto: "colors"),
    5: .same(proto: "positions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._startColor) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._endColor) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._angle) }()
      case 4: try { try decoder.decodeRepeatedUInt32Field(value: &self.colors) }()
      case 5: try { try decoder.decodeRepeatedFloatField(value: &self.positions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._startColor {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._endColor {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._angle {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    if !self.colors.isEmpty {
      try visitor.visitRepeatedUInt32Field(value: self.colors, fieldNumber: 4)
    }
    if !self.positions.isEmpty {
      try visitor.visitRepeatedFloatField(value: self.positions, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_TextAttachment.Gradient, rhs: SignalServiceProtos_TextAttachment.Gradient) -> Bool {
    if lhs._startColor != rhs._startColor {return false}
    if lhs._endColor != rhs._endColor {return false}
    if lhs._angle != rhs._angle {return false}
    if lhs.colors != rhs.colors {return false}
    if lhs.positions != rhs.positions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_Content: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Content"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dataMessage"),
    2: .same(proto: "syncMessage"),
    3: .same(proto: "callMessage"),
    4: .same(proto: "nullMessage"),
    5: .same(proto: "receiptMessage"),
    6: .same(proto: "typingMessage"),
    7: .same(proto: "senderKeyDistributionMessage"),
    8: .same(proto: "decryptionErrorMessage"),
    9: .same(proto: "storyMessage"),
    10: .same(proto: "pniSignatureMessage"),
    11: .same(proto: "editMessage"),
  ]

  fileprivate class _StorageClass {
    var _dataMessage: SignalServiceProtos_DataMessage? = nil
    var _syncMessage: SignalServiceProtos_SyncMessage? = nil
    var _callMessage: SignalServiceProtos_CallMessage? = nil
    var _nullMessage: SignalServiceProtos_NullMessage? = nil
    var _receiptMessage: SignalServiceProtos_ReceiptMessage? = nil
    var _typingMessage: SignalServiceProtos_TypingMessage? = nil
    var _senderKeyDistributionMessage: Data? = nil
    var _decryptionErrorMessage: Data? = nil
    var _storyMessage: SignalServiceProtos_StoryMessage? = nil
    var _pniSignatureMessage: SignalServiceProtos_PniSignatureMessage? = nil
    var _editMessage: SignalServiceProtos_EditMessage? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _dataMessage = source._dataMessage
      _syncMessage = source._syncMessage
      _callMessage = source._callMessage
      _nullMessage = source._nullMessage
      _receiptMessage = source._receiptMessage
      _typingMessage = source._typingMessage
      _senderKeyDistributionMessage = source._senderKeyDistributionMessage
      _decryptionErrorMessage = source._decryptionErrorMessage
      _storyMessage = source._storyMessage
      _pniSignatureMessage = source._pniSignatureMessage
      _editMessage = source._editMessage
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._dataMessage) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._syncMessage) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._callMessage) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._nullMessage) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._receiptMessage) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._typingMessage) }()
        case 7: try { try decoder.decodeSingularBytesField(value: &_storage._senderKeyDistributionMessage) }()
        case 8: try { try decoder.decodeSingularBytesField(value: &_storage._decryptionErrorMessage) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._storyMessage) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._pniSignatureMessage) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._editMessage) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._dataMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._syncMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._callMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._nullMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._receiptMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._typingMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._senderKeyDistributionMessage {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._decryptionErrorMessage {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._storyMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._pniSignatureMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._editMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_Content, rhs: SignalServiceProtos_Content) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._dataMessage != rhs_storage._dataMessage {return false}
        if _storage._syncMessage != rhs_storage._syncMessage {return false}
        if _storage._callMessage != rhs_storage._callMessage {return false}
        if _storage._nullMessage != rhs_storage._nullMessage {return false}
        if _storage._receiptMessage != rhs_storage._receiptMessage {return false}
        if _storage._typingMessage != rhs_storage._typingMessage {return false}
        if _storage._senderKeyDistributionMessage != rhs_storage._senderKeyDistributionMessage {return false}
        if _storage._decryptionErrorMessage != rhs_storage._decryptionErrorMessage {return false}
        if _storage._storyMessage != rhs_storage._storyMessage {return false}
        if _storage._pniSignatureMessage != rhs_storage._pniSignatureMessage {return false}
        if _storage._editMessage != rhs_storage._editMessage {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_CallMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CallMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "offer"),
    2: .same(proto: "answer"),
    3: .same(proto: "iceUpdate"),
    5: .same(proto: "busy"),
    6: .same(proto: "profileKey"),
    7: .same(proto: "hangup"),
    9: .same(proto: "destinationDeviceId"),
    10: .same(proto: "opaque"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._offer) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._answer) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.iceUpdate) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._busy) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self._profileKey) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._hangup) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self._destinationDeviceID) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._opaque) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._offer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._answer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.iceUpdate.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.iceUpdate, fieldNumber: 3)
    }
    try { if let v = self._busy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._profileKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._hangup {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._destinationDeviceID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._opaque {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_CallMessage, rhs: SignalServiceProtos_CallMessage) -> Bool {
    if lhs._offer != rhs._offer {return false}
    if lhs._answer != rhs._answer {return false}
    if lhs.iceUpdate != rhs.iceUpdate {return false}
    if lhs._busy != rhs._busy {return false}
    if lhs._profileKey != rhs._profileKey {return false}
    if lhs._hangup != rhs._hangup {return false}
    if lhs._destinationDeviceID != rhs._destinationDeviceID {return false}
    if lhs._opaque != rhs._opaque {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_CallMessage.Offer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_CallMessage.protoMessageName + ".Offer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    3: .same(proto: "type"),
    4: .same(proto: "opaque"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._id) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._opaque) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._opaque {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_CallMessage.Offer, rhs: SignalServiceProtos_CallMessage.Offer) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._type != rhs._type {return false}
    if lhs._opaque != rhs._opaque {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_CallMessage.Offer.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OFFER_AUDIO_CALL"),
    1: .same(proto: "OFFER_VIDEO_CALL"),
  ]
}

extension SignalServiceProtos_CallMessage.Answer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_CallMessage.protoMessageName + ".Answer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    3: .same(proto: "opaque"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._id) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._opaque) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._opaque {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_CallMessage.Answer, rhs: SignalServiceProtos_CallMessage.Answer) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._opaque != rhs._opaque {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_CallMessage.IceUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_CallMessage.protoMessageName + ".IceUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    5: .same(proto: "opaque"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._id) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._opaque) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._opaque {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_CallMessage.IceUpdate, rhs: SignalServiceProtos_CallMessage.IceUpdate) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._opaque != rhs._opaque {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_CallMessage.Busy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_CallMessage.protoMessageName + ".Busy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_CallMessage.Busy, rhs: SignalServiceProtos_CallMessage.Busy) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_CallMessage.Hangup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_CallMessage.protoMessageName + ".Hangup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .same(proto: "deviceId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._deviceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._deviceID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_CallMessage.Hangup, rhs: SignalServiceProtos_CallMessage.Hangup) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._type != rhs._type {return false}
    if lhs._deviceID != rhs._deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_CallMessage.Hangup.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HANGUP_NORMAL"),
    1: .same(proto: "HANGUP_ACCEPTED"),
    2: .same(proto: "HANGUP_DECLINED"),
    3: .same(proto: "HANGUP_BUSY"),
    4: .same(proto: "HANGUP_NEED_PERMISSION"),
  ]
}

extension SignalServiceProtos_CallMessage.Opaque: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_CallMessage.protoMessageName + ".Opaque"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "urgency"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._data) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._urgency) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._data {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._urgency {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_CallMessage.Opaque, rhs: SignalServiceProtos_CallMessage.Opaque) -> Bool {
    if lhs._data != rhs._data {return false}
    if lhs._urgency != rhs._urgency {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_CallMessage.Opaque.Urgency: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DROPPABLE"),
    1: .same(proto: "HANDLE_IMMEDIATELY"),
  ]
}

extension SignalServiceProtos_DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DataMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "body"),
    2: .same(proto: "attachments"),
    15: .same(proto: "groupV2"),
    4: .same(proto: "flags"),
    5: .same(proto: "expireTimer"),
    23: .same(proto: "expireTimerVersion"),
    6: .same(proto: "profileKey"),
    7: .same(proto: "timestamp"),
    8: .same(proto: "quote"),
    9: .same(proto: "contact"),
    10: .same(proto: "preview"),
    11: .same(proto: "sticker"),
    12: .same(proto: "requiredProtocolVersion"),
    14: .same(proto: "isViewOnce"),
    16: .same(proto: "reaction"),
    17: .same(proto: "delete"),
    18: .same(proto: "bodyRanges"),
    19: .same(proto: "groupCallUpdate"),
    20: .same(proto: "payment"),
    21: .same(proto: "storyContext"),
    22: .same(proto: "giftBadge"),
  ]

  fileprivate class _StorageClass {
    var _body: String? = nil
    var _attachments: [SignalServiceProtos_AttachmentPointer] = []
    var _groupV2: SignalServiceProtos_GroupContextV2? = nil
    var _flags: UInt32? = nil
    var _expireTimer: UInt32? = nil
    var _expireTimerVersion: UInt32? = nil
    var _profileKey: Data? = nil
    var _timestamp: UInt64? = nil
    var _quote: SignalServiceProtos_DataMessage.Quote? = nil
    var _contact: [SignalServiceProtos_DataMessage.Contact] = []
    var _preview: [SignalServiceProtos_Preview] = []
    var _sticker: SignalServiceProtos_DataMessage.Sticker? = nil
    var _requiredProtocolVersion: UInt32? = nil
    var _isViewOnce: Bool? = nil
    var _reaction: SignalServiceProtos_DataMessage.Reaction? = nil
    var _delete: SignalServiceProtos_DataMessage.Delete? = nil
    var _bodyRanges: [SignalServiceProtos_BodyRange] = []
    var _groupCallUpdate: SignalServiceProtos_DataMessage.GroupCallUpdate? = nil
    var _payment: SignalServiceProtos_DataMessage.Payment? = nil
    var _storyContext: SignalServiceProtos_DataMessage.StoryContext? = nil
    var _giftBadge: SignalServiceProtos_DataMessage.GiftBadge? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _body = source._body
      _attachments = source._attachments
      _groupV2 = source._groupV2
      _flags = source._flags
      _expireTimer = source._expireTimer
      _expireTimerVersion = source._expireTimerVersion
      _profileKey = source._profileKey
      _timestamp = source._timestamp
      _quote = source._quote
      _contact = source._contact
      _preview = source._preview
      _sticker = source._sticker
      _requiredProtocolVersion = source._requiredProtocolVersion
      _isViewOnce = source._isViewOnce
      _reaction = source._reaction
      _delete = source._delete
      _bodyRanges = source._bodyRanges
      _groupCallUpdate = source._groupCallUpdate
      _payment = source._payment
      _storyContext = source._storyContext
      _giftBadge = source._giftBadge
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._body) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._attachments) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._flags) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._expireTimer) }()
        case 6: try { try decoder.decodeSingularBytesField(value: &_storage._profileKey) }()
        case 7: try { try decoder.decodeSingularUInt64Field(value: &_storage._timestamp) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._quote) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._contact) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._preview) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._sticker) }()
        case 12: try { try decoder.decodeSingularUInt32Field(value: &_storage._requiredProtocolVersion) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._isViewOnce) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._groupV2) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._reaction) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._delete) }()
        case 18: try { try decoder.decodeRepeatedMessageField(value: &_storage._bodyRanges) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._groupCallUpdate) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._payment) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._storyContext) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._giftBadge) }()
        case 23: try { try decoder.decodeSingularUInt32Field(value: &_storage._expireTimerVersion) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._body {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      if !_storage._attachments.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._attachments, fieldNumber: 2)
      }
      try { if let v = _storage._flags {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._expireTimer {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._profileKey {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._timestamp {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._quote {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._contact.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._contact, fieldNumber: 9)
      }
      if !_storage._preview.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._preview, fieldNumber: 10)
      }
      try { if let v = _storage._sticker {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._requiredProtocolVersion {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._isViewOnce {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._groupV2 {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._reaction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._delete {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      if !_storage._bodyRanges.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._bodyRanges, fieldNumber: 18)
      }
      try { if let v = _storage._groupCallUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._payment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._storyContext {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._giftBadge {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._expireTimerVersion {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 23)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_DataMessage, rhs: SignalServiceProtos_DataMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._body != rhs_storage._body {return false}
        if _storage._attachments != rhs_storage._attachments {return false}
        if _storage._groupV2 != rhs_storage._groupV2 {return false}
        if _storage._flags != rhs_storage._flags {return false}
        if _storage._expireTimer != rhs_storage._expireTimer {return false}
        if _storage._expireTimerVersion != rhs_storage._expireTimerVersion {return false}
        if _storage._profileKey != rhs_storage._profileKey {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._quote != rhs_storage._quote {return false}
        if _storage._contact != rhs_storage._contact {return false}
        if _storage._preview != rhs_storage._preview {return false}
        if _storage._sticker != rhs_storage._sticker {return false}
        if _storage._requiredProtocolVersion != rhs_storage._requiredProtocolVersion {return false}
        if _storage._isViewOnce != rhs_storage._isViewOnce {return false}
        if _storage._reaction != rhs_storage._reaction {return false}
        if _storage._delete != rhs_storage._delete {return false}
        if _storage._bodyRanges != rhs_storage._bodyRanges {return false}
        if _storage._groupCallUpdate != rhs_storage._groupCallUpdate {return false}
        if _storage._payment != rhs_storage._payment {return false}
        if _storage._storyContext != rhs_storage._storyContext {return false}
        if _storage._giftBadge != rhs_storage._giftBadge {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_DataMessage.Flags: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "END_SESSION"),
    2: .same(proto: "EXPIRATION_TIMER_UPDATE"),
    4: .same(proto: "PROFILE_KEY_UPDATE"),
  ]
}

extension SignalServiceProtos_DataMessage.ProtocolVersion: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INITIAL"),
    1: .same(proto: "MESSAGE_TIMERS"),
    2: .same(proto: "VIEW_ONCE"),
    3: .same(proto: "VIEW_ONCE_VIDEO"),
    4: .same(proto: "REACTIONS"),
    5: .same(proto: "CDN_SELECTOR_ATTACHMENTS"),
    6: .same(proto: "MENTIONS"),
    7: .aliased(proto: "PAYMENTS", aliases: ["CURRENT"]),
  ]
}

extension SignalServiceProtos_DataMessage.Quote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_DataMessage.protoMessageName + ".Quote"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    5: .same(proto: "authorAci"),
    3: .same(proto: "text"),
    4: .same(proto: "attachments"),
    6: .same(proto: "bodyRanges"),
    7: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._id) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._text) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.attachments) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._authorAci) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.bodyRanges) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._text {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    if !self.attachments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attachments, fieldNumber: 4)
    }
    try { if let v = self._authorAci {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    if !self.bodyRanges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bodyRanges, fieldNumber: 6)
    }
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_DataMessage.Quote, rhs: SignalServiceProtos_DataMessage.Quote) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._authorAci != rhs._authorAci {return false}
    if lhs._text != rhs._text {return false}
    if lhs.attachments != rhs.attachments {return false}
    if lhs.bodyRanges != rhs.bodyRanges {return false}
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_DataMessage.Quote.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NORMAL"),
    1: .same(proto: "GIFT_BADGE"),
  ]
}

extension SignalServiceProtos_DataMessage.Quote.QuotedAttachment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_DataMessage.Quote.protoMessageName + ".QuotedAttachment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contentType"),
    2: .same(proto: "fileName"),
    3: .same(proto: "thumbnail"),
  ]

  fileprivate class _StorageClass {
    var _contentType: String? = nil
    var _fileName: String? = nil
    var _thumbnail: SignalServiceProtos_AttachmentPointer? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _contentType = source._contentType
      _fileName = source._fileName
      _thumbnail = source._thumbnail
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._contentType) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._fileName) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._thumbnail) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._contentType {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._fileName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._thumbnail {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_DataMessage.Quote.QuotedAttachment, rhs: SignalServiceProtos_DataMessage.Quote.QuotedAttachment) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._contentType != rhs_storage._contentType {return false}
        if _storage._fileName != rhs_storage._fileName {return false}
        if _storage._thumbnail != rhs_storage._thumbnail {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_DataMessage.Contact: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_DataMessage.protoMessageName + ".Contact"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .same(proto: "number"),
    4: .same(proto: "email"),
    5: .same(proto: "address"),
    6: .same(proto: "avatar"),
    7: .same(proto: "organization"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._name) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.number) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.email) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.address) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._avatar) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._organization) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.number.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.number, fieldNumber: 3)
    }
    if !self.email.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.email, fieldNumber: 4)
    }
    if !self.address.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.address, fieldNumber: 5)
    }
    try { if let v = self._avatar {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._organization {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_DataMessage.Contact, rhs: SignalServiceProtos_DataMessage.Contact) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs.number != rhs.number {return false}
    if lhs.email != rhs.email {return false}
    if lhs.address != rhs.address {return false}
    if lhs._avatar != rhs._avatar {return false}
    if lhs._organization != rhs._organization {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_DataMessage.Contact.Name: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_DataMessage.Contact.protoMessageName + ".Name"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "givenName"),
    2: .same(proto: "familyName"),
    3: .same(proto: "prefix"),
    4: .same(proto: "suffix"),
    5: .same(proto: "middleName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._givenName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._familyName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._prefix) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._suffix) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._middleName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._givenName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._familyName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._prefix {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._suffix {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._middleName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_DataMessage.Contact.Name, rhs: SignalServiceProtos_DataMessage.Contact.Name) -> Bool {
    if lhs._givenName != rhs._givenName {return false}
    if lhs._familyName != rhs._familyName {return false}
    if lhs._prefix != rhs._prefix {return false}
    if lhs._suffix != rhs._suffix {return false}
    if lhs._middleName != rhs._middleName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_DataMessage.Contact.Phone: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_DataMessage.Contact.protoMessageName + ".Phone"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "type"),
    3: .same(proto: "label"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._label) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._label {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_DataMessage.Contact.Phone, rhs: SignalServiceProtos_DataMessage.Contact.Phone) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs._type != rhs._type {return false}
    if lhs._label != rhs._label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_DataMessage.Contact.Phone.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "HOME"),
    2: .same(proto: "MOBILE"),
    3: .same(proto: "WORK"),
    4: .same(proto: "CUSTOM"),
  ]
}

extension SignalServiceProtos_DataMessage.Contact.Email: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_DataMessage.Contact.protoMessageName + ".Email"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "type"),
    3: .same(proto: "label"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._label) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._label {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_DataMessage.Contact.Email, rhs: SignalServiceProtos_DataMessage.Contact.Email) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs._type != rhs._type {return false}
    if lhs._label != rhs._label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_DataMessage.Contact.Email.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "HOME"),
    2: .same(proto: "MOBILE"),
    3: .same(proto: "WORK"),
    4: .same(proto: "CUSTOM"),
  ]
}

extension SignalServiceProtos_DataMessage.Contact.PostalAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_DataMessage.Contact.protoMessageName + ".PostalAddress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "label"),
    3: .same(proto: "street"),
    4: .same(proto: "pobox"),
    5: .same(proto: "neighborhood"),
    6: .same(proto: "city"),
    7: .same(proto: "region"),
    8: .same(proto: "postcode"),
    9: .same(proto: "country"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._label) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._street) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._pobox) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._neighborhood) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._city) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._region) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._postcode) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._country) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._label {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._street {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._pobox {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._neighborhood {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._city {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._region {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._postcode {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._country {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_DataMessage.Contact.PostalAddress, rhs: SignalServiceProtos_DataMessage.Contact.PostalAddress) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._label != rhs._label {return false}
    if lhs._street != rhs._street {return false}
    if lhs._pobox != rhs._pobox {return false}
    if lhs._neighborhood != rhs._neighborhood {return false}
    if lhs._city != rhs._city {return false}
    if lhs._region != rhs._region {return false}
    if lhs._postcode != rhs._postcode {return false}
    if lhs._country != rhs._country {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_DataMessage.Contact.PostalAddress.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "HOME"),
    2: .same(proto: "WORK"),
    3: .same(proto: "CUSTOM"),
  ]
}

extension SignalServiceProtos_DataMessage.Contact.Avatar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_DataMessage.Contact.protoMessageName + ".Avatar"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "avatar"),
    2: .same(proto: "isProfile"),
  ]

  fileprivate class _StorageClass {
    var _avatar: SignalServiceProtos_AttachmentPointer? = nil
    var _isProfile: Bool? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _avatar = source._avatar
      _isProfile = source._isProfile
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._avatar) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._isProfile) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._avatar {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._isProfile {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_DataMessage.Contact.Avatar, rhs: SignalServiceProtos_DataMessage.Contact.Avatar) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._avatar != rhs_storage._avatar {return false}
        if _storage._isProfile != rhs_storage._isProfile {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_DataMessage.Sticker: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_DataMessage.protoMessageName + ".Sticker"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "packId"),
    2: .same(proto: "packKey"),
    3: .same(proto: "stickerId"),
    4: .same(proto: "data"),
    5: .same(proto: "emoji"),
  ]

  fileprivate class _StorageClass {
    var _packID: Data? = nil
    var _packKey: Data? = nil
    var _stickerID: UInt32? = nil
    var _data: SignalServiceProtos_AttachmentPointer? = nil
    var _emoji: String? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _packID = source._packID
      _packKey = source._packKey
      _stickerID = source._stickerID
      _data = source._data
      _emoji = source._emoji
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._packID) }()
        case 2: try { try decoder.decodeSingularBytesField(value: &_storage._packKey) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._stickerID) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._data) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._emoji) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._packID {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._packKey {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._stickerID {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._emoji {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_DataMessage.Sticker, rhs: SignalServiceProtos_DataMessage.Sticker) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._packID != rhs_storage._packID {return false}
        if _storage._packKey != rhs_storage._packKey {return false}
        if _storage._stickerID != rhs_storage._stickerID {return false}
        if _storage._data != rhs_storage._data {return false}
        if _storage._emoji != rhs_storage._emoji {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_DataMessage.Reaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_DataMessage.protoMessageName + ".Reaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "emoji"),
    2: .same(proto: "remove"),
    4: .same(proto: "targetAuthorAci"),
    5: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._emoji) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._remove) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._targetAuthorAci) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._emoji {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._remove {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._targetAuthorAci {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_DataMessage.Reaction, rhs: SignalServiceProtos_DataMessage.Reaction) -> Bool {
    if lhs._emoji != rhs._emoji {return false}
    if lhs._remove != rhs._remove {return false}
    if lhs._targetAuthorAci != rhs._targetAuthorAci {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_DataMessage.Delete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_DataMessage.protoMessageName + ".Delete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targetSentTimestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._targetSentTimestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._targetSentTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_DataMessage.Delete, rhs: SignalServiceProtos_DataMessage.Delete) -> Bool {
    if lhs._targetSentTimestamp != rhs._targetSentTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_DataMessage.GroupCallUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_DataMessage.protoMessageName + ".GroupCallUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eraId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._eraID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._eraID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_DataMessage.GroupCallUpdate, rhs: SignalServiceProtos_DataMessage.GroupCallUpdate) -> Bool {
    if lhs._eraID != rhs._eraID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_DataMessage.Payment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_DataMessage.protoMessageName + ".Payment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "notification"),
    2: .same(proto: "activation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._notification) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._activation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._notification {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._activation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_DataMessage.Payment, rhs: SignalServiceProtos_DataMessage.Payment) -> Bool {
    if lhs._notification != rhs._notification {return false}
    if lhs._activation != rhs._activation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_DataMessage.Payment.Amount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_DataMessage.Payment.protoMessageName + ".Amount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mobileCoin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._mobileCoin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mobileCoin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_DataMessage.Payment.Amount, rhs: SignalServiceProtos_DataMessage.Payment.Amount) -> Bool {
    if lhs._mobileCoin != rhs._mobileCoin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_DataMessage.Payment.Amount.MobileCoin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_DataMessage.Payment.Amount.protoMessageName + ".MobileCoin"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "picoMob"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._picoMob) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._picoMob {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_DataMessage.Payment.Amount.MobileCoin, rhs: SignalServiceProtos_DataMessage.Payment.Amount.MobileCoin) -> Bool {
    if lhs._picoMob != rhs._picoMob {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_DataMessage.Payment.Notification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_DataMessage.Payment.protoMessageName + ".Notification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mobileCoin"),
    2: .same(proto: "note"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._mobileCoin) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._note) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mobileCoin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._note {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_DataMessage.Payment.Notification, rhs: SignalServiceProtos_DataMessage.Payment.Notification) -> Bool {
    if lhs._mobileCoin != rhs._mobileCoin {return false}
    if lhs._note != rhs._note {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_DataMessage.Payment.Notification.MobileCoin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_DataMessage.Payment.Notification.protoMessageName + ".MobileCoin"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "receipt"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._receipt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._receipt {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_DataMessage.Payment.Notification.MobileCoin, rhs: SignalServiceProtos_DataMessage.Payment.Notification.MobileCoin) -> Bool {
    if lhs._receipt != rhs._receipt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_DataMessage.Payment.Activation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_DataMessage.Payment.protoMessageName + ".Activation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_DataMessage.Payment.Activation, rhs: SignalServiceProtos_DataMessage.Payment.Activation) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_DataMessage.Payment.Activation.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REQUEST"),
    1: .same(proto: "ACTIVATED"),
  ]
}

extension SignalServiceProtos_DataMessage.StoryContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_DataMessage.protoMessageName + ".StoryContext"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authorAci"),
    2: .same(proto: "sentTimestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._authorAci) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._sentTimestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._authorAci {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sentTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_DataMessage.StoryContext, rhs: SignalServiceProtos_DataMessage.StoryContext) -> Bool {
    if lhs._authorAci != rhs._authorAci {return false}
    if lhs._sentTimestamp != rhs._sentTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_DataMessage.GiftBadge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_DataMessage.protoMessageName + ".GiftBadge"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "receiptCredentialPresentation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._receiptCredentialPresentation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._receiptCredentialPresentation {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_DataMessage.GiftBadge, rhs: SignalServiceProtos_DataMessage.GiftBadge) -> Bool {
    if lhs._receiptCredentialPresentation != rhs._receiptCredentialPresentation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_NullMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NullMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "padding"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._padding) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._padding {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_NullMessage, rhs: SignalServiceProtos_NullMessage) -> Bool {
    if lhs._padding != rhs._padding {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_ReceiptMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReceiptMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeRepeatedUInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    if !self.timestamp.isEmpty {
      try visitor.visitRepeatedUInt64Field(value: self.timestamp, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_ReceiptMessage, rhs: SignalServiceProtos_ReceiptMessage) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_ReceiptMessage.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DELIVERY"),
    1: .same(proto: "READ"),
    2: .same(proto: "VIEWED"),
  ]
}

extension SignalServiceProtos_Verified: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Verified"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .same(proto: "destinationAci"),
    2: .same(proto: "identityKey"),
    3: .same(proto: "state"),
    4: .same(proto: "nullMessage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularBytesField(value: &self._identityKey) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._state) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._nullMessage) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._destinationAci) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identityKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._state {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._nullMessage {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._destinationAci {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_Verified, rhs: SignalServiceProtos_Verified) -> Bool {
    if lhs._destinationAci != rhs._destinationAci {return false}
    if lhs._identityKey != rhs._identityKey {return false}
    if lhs._state != rhs._state {return false}
    if lhs._nullMessage != rhs._nullMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_Verified.State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "VERIFIED"),
    2: .same(proto: "UNVERIFIED"),
  ]
}

extension SignalServiceProtos_SyncMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sent"),
    2: .same(proto: "contacts"),
    4: .same(proto: "request"),
    5: .same(proto: "read"),
    6: .same(proto: "blocked"),
    7: .same(proto: "verified"),
    9: .same(proto: "configuration"),
    8: .same(proto: "padding"),
    10: .same(proto: "stickerPackOperation"),
    11: .same(proto: "viewOnceOpen"),
    12: .same(proto: "fetchLatest"),
    13: .same(proto: "keys"),
    14: .same(proto: "messageRequestResponse"),
    15: .same(proto: "outgoingPayment"),
    16: .same(proto: "viewed"),
    18: .same(proto: "pniChangeNumber"),
    19: .same(proto: "callEvent"),
    20: .same(proto: "callLinkUpdate"),
    21: .same(proto: "callLogEvent"),
    22: .same(proto: "deleteForMe"),
    23: .same(proto: "deviceNameChange"),
  ]

  fileprivate class _StorageClass {
    var _sent: SignalServiceProtos_SyncMessage.Sent? = nil
    var _contacts: SignalServiceProtos_SyncMessage.Contacts? = nil
    var _request: SignalServiceProtos_SyncMessage.Request? = nil
    var _read: [SignalServiceProtos_SyncMessage.Read] = []
    var _blocked: SignalServiceProtos_SyncMessage.Blocked? = nil
    var _verified: SignalServiceProtos_Verified? = nil
    var _configuration: SignalServiceProtos_SyncMessage.Configuration? = nil
    var _padding: Data? = nil
    var _stickerPackOperation: [SignalServiceProtos_SyncMessage.StickerPackOperation] = []
    var _viewOnceOpen: SignalServiceProtos_SyncMessage.ViewOnceOpen? = nil
    var _fetchLatest: SignalServiceProtos_SyncMessage.FetchLatest? = nil
    var _keys: SignalServiceProtos_SyncMessage.Keys? = nil
    var _messageRequestResponse: SignalServiceProtos_SyncMessage.MessageRequestResponse? = nil
    var _outgoingPayment: SignalServiceProtos_SyncMessage.OutgoingPayment? = nil
    var _viewed: [SignalServiceProtos_SyncMessage.Viewed] = []
    var _pniChangeNumber: SignalServiceProtos_SyncMessage.PniChangeNumber? = nil
    var _callEvent: SignalServiceProtos_SyncMessage.CallEvent? = nil
    var _callLinkUpdate: SignalServiceProtos_SyncMessage.CallLinkUpdate? = nil
    var _callLogEvent: SignalServiceProtos_SyncMessage.CallLogEvent? = nil
    var _deleteForMe: SignalServiceProtos_SyncMessage.DeleteForMe? = nil
    var _deviceNameChange: SignalServiceProtos_SyncMessage.DeviceNameChange? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _sent = source._sent
      _contacts = source._contacts
      _request = source._request
      _read = source._read
      _blocked = source._blocked
      _verified = source._verified
      _configuration = source._configuration
      _padding = source._padding
      _stickerPackOperation = source._stickerPackOperation
      _viewOnceOpen = source._viewOnceOpen
      _fetchLatest = source._fetchLatest
      _keys = source._keys
      _messageRequestResponse = source._messageRequestResponse
      _outgoingPayment = source._outgoingPayment
      _viewed = source._viewed
      _pniChangeNumber = source._pniChangeNumber
      _callEvent = source._callEvent
      _callLinkUpdate = source._callLinkUpdate
      _callLogEvent = source._callLogEvent
      _deleteForMe = source._deleteForMe
      _deviceNameChange = source._deviceNameChange
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._sent) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._contacts) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._request) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._read) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._blocked) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._verified) }()
        case 8: try { try decoder.decodeSingularBytesField(value: &_storage._padding) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._configuration) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._stickerPackOperation) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._viewOnceOpen) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._fetchLatest) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._keys) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._messageRequestResponse) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._outgoingPayment) }()
        case 16: try { try decoder.decodeRepeatedMessageField(value: &_storage._viewed) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._pniChangeNumber) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._callEvent) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._callLinkUpdate) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._callLogEvent) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._deleteForMe) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._deviceNameChange) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._sent {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._contacts {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._request {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._read.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._read, fieldNumber: 5)
      }
      try { if let v = _storage._blocked {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._verified {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._padding {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._configuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._stickerPackOperation.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._stickerPackOperation, fieldNumber: 10)
      }
      try { if let v = _storage._viewOnceOpen {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._fetchLatest {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._keys {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._messageRequestResponse {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._outgoingPayment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      if !_storage._viewed.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._viewed, fieldNumber: 16)
      }
      try { if let v = _storage._pniChangeNumber {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._callEvent {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._callLinkUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._callLogEvent {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._deleteForMe {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._deviceNameChange {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_SyncMessage, rhs: SignalServiceProtos_SyncMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sent != rhs_storage._sent {return false}
        if _storage._contacts != rhs_storage._contacts {return false}
        if _storage._request != rhs_storage._request {return false}
        if _storage._read != rhs_storage._read {return false}
        if _storage._blocked != rhs_storage._blocked {return false}
        if _storage._verified != rhs_storage._verified {return false}
        if _storage._configuration != rhs_storage._configuration {return false}
        if _storage._padding != rhs_storage._padding {return false}
        if _storage._stickerPackOperation != rhs_storage._stickerPackOperation {return false}
        if _storage._viewOnceOpen != rhs_storage._viewOnceOpen {return false}
        if _storage._fetchLatest != rhs_storage._fetchLatest {return false}
        if _storage._keys != rhs_storage._keys {return false}
        if _storage._messageRequestResponse != rhs_storage._messageRequestResponse {return false}
        if _storage._outgoingPayment != rhs_storage._outgoingPayment {return false}
        if _storage._viewed != rhs_storage._viewed {return false}
        if _storage._pniChangeNumber != rhs_storage._pniChangeNumber {return false}
        if _storage._callEvent != rhs_storage._callEvent {return false}
        if _storage._callLinkUpdate != rhs_storage._callLinkUpdate {return false}
        if _storage._callLogEvent != rhs_storage._callLogEvent {return false}
        if _storage._deleteForMe != rhs_storage._deleteForMe {return false}
        if _storage._deviceNameChange != rhs_storage._deviceNameChange {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_SyncMessage.Sent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_SyncMessage.protoMessageName + ".Sent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "destinationE164"),
    7: .same(proto: "destinationServiceId"),
    2: .same(proto: "timestamp"),
    3: .same(proto: "message"),
    4: .same(proto: "expirationStartTimestamp"),
    5: .same(proto: "unidentifiedStatus"),
    6: .same(proto: "isRecipientUpdate"),
    8: .same(proto: "storyMessage"),
    9: .same(proto: "storyMessageRecipients"),
    10: .same(proto: "editMessage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._destinationE164) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._expirationStartTimestamp) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.unidentifiedStatus) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._isRecipientUpdate) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._destinationServiceID) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._storyMessage) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.storyMessageRecipients) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._editMessage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._destinationE164 {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._expirationStartTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    if !self.unidentifiedStatus.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.unidentifiedStatus, fieldNumber: 5)
    }
    try { if let v = self._isRecipientUpdate {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._destinationServiceID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._storyMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if !self.storyMessageRecipients.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.storyMessageRecipients, fieldNumber: 9)
    }
    try { if let v = self._editMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_SyncMessage.Sent, rhs: SignalServiceProtos_SyncMessage.Sent) -> Bool {
    if lhs._destinationE164 != rhs._destinationE164 {return false}
    if lhs._destinationServiceID != rhs._destinationServiceID {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._message != rhs._message {return false}
    if lhs._expirationStartTimestamp != rhs._expirationStartTimestamp {return false}
    if lhs.unidentifiedStatus != rhs.unidentifiedStatus {return false}
    if lhs._isRecipientUpdate != rhs._isRecipientUpdate {return false}
    if lhs._storyMessage != rhs._storyMessage {return false}
    if lhs.storyMessageRecipients != rhs.storyMessageRecipients {return false}
    if lhs._editMessage != rhs._editMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_SyncMessage.Sent.UnidentifiedDeliveryStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_SyncMessage.Sent.protoMessageName + ".UnidentifiedDeliveryStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "destinationServiceId"),
    2: .same(proto: "unidentified"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularBoolField(value: &self._unidentified) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._destinationServiceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._unidentified {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._destinationServiceID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_SyncMessage.Sent.UnidentifiedDeliveryStatus, rhs: SignalServiceProtos_SyncMessage.Sent.UnidentifiedDeliveryStatus) -> Bool {
    if lhs._destinationServiceID != rhs._destinationServiceID {return false}
    if lhs._unidentified != rhs._unidentified {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_SyncMessage.Sent.StoryMessageRecipient: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_SyncMessage.Sent.protoMessageName + ".StoryMessageRecipient"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "destinationServiceId"),
    2: .same(proto: "distributionListIds"),
    3: .same(proto: "isAllowedToReply"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._destinationServiceID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.distributionListIds) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._isAllowedToReply) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._destinationServiceID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.distributionListIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.distributionListIds, fieldNumber: 2)
    }
    try { if let v = self._isAllowedToReply {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_SyncMessage.Sent.StoryMessageRecipient, rhs: SignalServiceProtos_SyncMessage.Sent.StoryMessageRecipient) -> Bool {
    if lhs._destinationServiceID != rhs._destinationServiceID {return false}
    if lhs.distributionListIds != rhs.distributionListIds {return false}
    if lhs._isAllowedToReply != rhs._isAllowedToReply {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_SyncMessage.Contacts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_SyncMessage.protoMessageName + ".Contacts"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "blob"),
    2: .same(proto: "isComplete"),
  ]

  fileprivate class _StorageClass {
    var _blob: SignalServiceProtos_AttachmentPointer? = nil
    var _isComplete: Bool? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _blob = source._blob
      _isComplete = source._isComplete
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._blob) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._isComplete) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._blob {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._isComplete {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_SyncMessage.Contacts, rhs: SignalServiceProtos_SyncMessage.Contacts) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._blob != rhs_storage._blob {return false}
        if _storage._isComplete != rhs_storage._isComplete {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_SyncMessage.Blocked: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_SyncMessage.protoMessageName + ".Blocked"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "numbers"),
    3: .same(proto: "acis"),
    2: .same(proto: "groupIds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.numbers) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.groupIds) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.acis) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.numbers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.numbers, fieldNumber: 1)
    }
    if !self.groupIds.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.groupIds, fieldNumber: 2)
    }
    if !self.acis.isEmpty {
      try visitor.visitRepeatedStringField(value: self.acis, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_SyncMessage.Blocked, rhs: SignalServiceProtos_SyncMessage.Blocked) -> Bool {
    if lhs.numbers != rhs.numbers {return false}
    if lhs.acis != rhs.acis {return false}
    if lhs.groupIds != rhs.groupIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_SyncMessage.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_SyncMessage.protoMessageName + ".Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_SyncMessage.Request, rhs: SignalServiceProtos_SyncMessage.Request) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_SyncMessage.Request.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "CONTACTS"),
    3: .same(proto: "BLOCKED"),
    4: .same(proto: "CONFIGURATION"),
    5: .same(proto: "KEYS"),
  ]
}

extension SignalServiceProtos_SyncMessage.Read: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_SyncMessage.protoMessageName + ".Read"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "senderAci"),
    2: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._senderAci) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._senderAci {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_SyncMessage.Read, rhs: SignalServiceProtos_SyncMessage.Read) -> Bool {
    if lhs._senderAci != rhs._senderAci {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_SyncMessage.Viewed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_SyncMessage.protoMessageName + ".Viewed"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "senderAci"),
    2: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._senderAci) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._senderAci {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_SyncMessage.Viewed, rhs: SignalServiceProtos_SyncMessage.Viewed) -> Bool {
    if lhs._senderAci != rhs._senderAci {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_SyncMessage.Configuration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_SyncMessage.protoMessageName + ".Configuration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "readReceipts"),
    2: .same(proto: "unidentifiedDeliveryIndicators"),
    3: .same(proto: "typingIndicators"),
    5: .same(proto: "provisioningVersion"),
    6: .same(proto: "linkPreviews"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._readReceipts) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._unidentifiedDeliveryIndicators) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._typingIndicators) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._provisioningVersion) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._linkPreviews) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._readReceipts {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._unidentifiedDeliveryIndicators {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._typingIndicators {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._provisioningVersion {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._linkPreviews {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_SyncMessage.Configuration, rhs: SignalServiceProtos_SyncMessage.Configuration) -> Bool {
    if lhs._readReceipts != rhs._readReceipts {return false}
    if lhs._unidentifiedDeliveryIndicators != rhs._unidentifiedDeliveryIndicators {return false}
    if lhs._typingIndicators != rhs._typingIndicators {return false}
    if lhs._provisioningVersion != rhs._provisioningVersion {return false}
    if lhs._linkPreviews != rhs._linkPreviews {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_SyncMessage.StickerPackOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_SyncMessage.protoMessageName + ".StickerPackOperation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "packId"),
    2: .same(proto: "packKey"),
    3: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._packID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._packKey) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._packID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._packKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_SyncMessage.StickerPackOperation, rhs: SignalServiceProtos_SyncMessage.StickerPackOperation) -> Bool {
    if lhs._packID != rhs._packID {return false}
    if lhs._packKey != rhs._packKey {return false}
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_SyncMessage.StickerPackOperation.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INSTALL"),
    1: .same(proto: "REMOVE"),
  ]
}

extension SignalServiceProtos_SyncMessage.ViewOnceOpen: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_SyncMessage.protoMessageName + ".ViewOnceOpen"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "senderAci"),
    2: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._senderAci) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._senderAci {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_SyncMessage.ViewOnceOpen, rhs: SignalServiceProtos_SyncMessage.ViewOnceOpen) -> Bool {
    if lhs._senderAci != rhs._senderAci {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_SyncMessage.FetchLatest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_SyncMessage.protoMessageName + ".FetchLatest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_SyncMessage.FetchLatest, rhs: SignalServiceProtos_SyncMessage.FetchLatest) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_SyncMessage.FetchLatest.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "LOCAL_PROFILE"),
    2: .same(proto: "STORAGE_MANIFEST"),
    3: .same(proto: "SUBSCRIPTION_STATUS"),
  ]
}

extension SignalServiceProtos_SyncMessage.Keys: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_SyncMessage.protoMessageName + ".Keys"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "master"),
    3: .same(proto: "accountEntropyPool"),
    4: .same(proto: "mediaRootBackupKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularBytesField(value: &self._master) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._accountEntropyPool) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._mediaRootBackupKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._master {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._accountEntropyPool {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._mediaRootBackupKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_SyncMessage.Keys, rhs: SignalServiceProtos_SyncMessage.Keys) -> Bool {
    if lhs._master != rhs._master {return false}
    if lhs._accountEntropyPool != rhs._accountEntropyPool {return false}
    if lhs._mediaRootBackupKey != rhs._mediaRootBackupKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_SyncMessage.MessageRequestResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_SyncMessage.protoMessageName + ".MessageRequestResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "threadAci"),
    3: .same(proto: "groupId"),
    4: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self._threadAci) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._groupID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._threadAci {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._groupID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_SyncMessage.MessageRequestResponse, rhs: SignalServiceProtos_SyncMessage.MessageRequestResponse) -> Bool {
    if lhs._threadAci != rhs._threadAci {return false}
    if lhs._groupID != rhs._groupID {return false}
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_SyncMessage.MessageRequestResponse.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "ACCEPT"),
    2: .same(proto: "DELETE"),
    3: .same(proto: "BLOCK"),
    4: .same(proto: "BLOCK_AND_DELETE"),
    5: .same(proto: "SPAM"),
    6: .same(proto: "BLOCK_AND_SPAM"),
  ]
}

extension SignalServiceProtos_SyncMessage.OutgoingPayment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_SyncMessage.protoMessageName + ".OutgoingPayment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "recipientServiceId"),
    2: .same(proto: "note"),
    3: .same(proto: "mobileCoin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._recipientServiceID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._note) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._mobileCoin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._recipientServiceID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._note {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._mobileCoin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_SyncMessage.OutgoingPayment, rhs: SignalServiceProtos_SyncMessage.OutgoingPayment) -> Bool {
    if lhs._recipientServiceID != rhs._recipientServiceID {return false}
    if lhs._note != rhs._note {return false}
    if lhs._mobileCoin != rhs._mobileCoin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_SyncMessage.OutgoingPayment.MobileCoin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_SyncMessage.OutgoingPayment.protoMessageName + ".MobileCoin"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "recipientAddress"),
    2: .same(proto: "amountPicoMob"),
    3: .same(proto: "feePicoMob"),
    4: .same(proto: "receipt"),
    5: .same(proto: "ledgerBlockTimestamp"),
    6: .same(proto: "ledgerBlockIndex"),
    7: .same(proto: "spentKeyImages"),
    8: .same(proto: "outputPublicKeys"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._recipientAddress) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._amountPicoMob) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._feePicoMob) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._receipt) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self._ledgerBlockTimestamp) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self._ledgerBlockIndex) }()
      case 7: try { try decoder.decodeRepeatedBytesField(value: &self.spentKeyImages) }()
      case 8: try { try decoder.decodeRepeatedBytesField(value: &self.outputPublicKeys) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._recipientAddress {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._amountPicoMob {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._feePicoMob {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._receipt {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._ledgerBlockTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._ledgerBlockIndex {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    } }()
    if !self.spentKeyImages.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.spentKeyImages, fieldNumber: 7)
    }
    if !self.outputPublicKeys.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.outputPublicKeys, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_SyncMessage.OutgoingPayment.MobileCoin, rhs: SignalServiceProtos_SyncMessage.OutgoingPayment.MobileCoin) -> Bool {
    if lhs._recipientAddress != rhs._recipientAddress {return false}
    if lhs._amountPicoMob != rhs._amountPicoMob {return false}
    if lhs._feePicoMob != rhs._feePicoMob {return false}
    if lhs._receipt != rhs._receipt {return false}
    if lhs._ledgerBlockTimestamp != rhs._ledgerBlockTimestamp {return false}
    if lhs._ledgerBlockIndex != rhs._ledgerBlockIndex {return false}
    if lhs.spentKeyImages != rhs.spentKeyImages {return false}
    if lhs.outputPublicKeys != rhs.outputPublicKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_SyncMessage.PniChangeNumber: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_SyncMessage.protoMessageName + ".PniChangeNumber"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identityKeyPair"),
    2: .same(proto: "signedPreKey"),
    5: .same(proto: "lastResortKyberPreKey"),
    3: .same(proto: "registrationId"),
    4: .same(proto: "newE164"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._identityKeyPair) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._signedPreKey) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._registrationID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._newE164) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._lastResortKyberPreKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identityKeyPair {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._signedPreKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._registrationID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._newE164 {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._lastResortKyberPreKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_SyncMessage.PniChangeNumber, rhs: SignalServiceProtos_SyncMessage.PniChangeNumber) -> Bool {
    if lhs._identityKeyPair != rhs._identityKeyPair {return false}
    if lhs._signedPreKey != rhs._signedPreKey {return false}
    if lhs._lastResortKyberPreKey != rhs._lastResortKyberPreKey {return false}
    if lhs._registrationID != rhs._registrationID {return false}
    if lhs._newE164 != rhs._newE164 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_SyncMessage.CallEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_SyncMessage.protoMessageName + ".CallEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "conversationId"),
    2: .same(proto: "callId"),
    3: .same(proto: "timestamp"),
    4: .same(proto: "type"),
    5: .same(proto: "direction"),
    6: .same(proto: "event"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._conversationID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._callID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self._direction) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self._event) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._conversationID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._callID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._direction {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._event {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_SyncMessage.CallEvent, rhs: SignalServiceProtos_SyncMessage.CallEvent) -> Bool {
    if lhs._conversationID != rhs._conversationID {return false}
    if lhs._callID != rhs._callID {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._type != rhs._type {return false}
    if lhs._direction != rhs._direction {return false}
    if lhs._event != rhs._event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_SyncMessage.CallEvent.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_TYPE"),
    1: .same(proto: "AUDIO_CALL"),
    2: .same(proto: "VIDEO_CALL"),
    3: .same(proto: "GROUP_CALL"),
    4: .same(proto: "AD_HOC_CALL"),
  ]
}

extension SignalServiceProtos_SyncMessage.CallEvent.Direction: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_DIRECTION"),
    1: .same(proto: "INCOMING"),
    2: .same(proto: "OUTGOING"),
  ]
}

extension SignalServiceProtos_SyncMessage.CallEvent.Event: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_ACTION"),
    1: .same(proto: "ACCEPTED"),
    2: .same(proto: "NOT_ACCEPTED"),
    3: .same(proto: "DELETED"),
    4: .same(proto: "OBSERVED"),
  ]
}

extension SignalServiceProtos_SyncMessage.CallLinkUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_SyncMessage.protoMessageName + ".CallLinkUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rootKey"),
    2: .same(proto: "adminPasskey"),
    3: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._rootKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._adminPasskey) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rootKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._adminPasskey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_SyncMessage.CallLinkUpdate, rhs: SignalServiceProtos_SyncMessage.CallLinkUpdate) -> Bool {
    if lhs._rootKey != rhs._rootKey {return false}
    if lhs._adminPasskey != rhs._adminPasskey {return false}
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_SyncMessage.CallLinkUpdate.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UPDATE"),
  ]
}

extension SignalServiceProtos_SyncMessage.CallLogEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_SyncMessage.protoMessageName + ".CallLogEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "timestamp"),
    3: .same(proto: "conversationId"),
    4: .same(proto: "callId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._conversationID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._callID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._conversationID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._callID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_SyncMessage.CallLogEvent, rhs: SignalServiceProtos_SyncMessage.CallLogEvent) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._conversationID != rhs._conversationID {return false}
    if lhs._callID != rhs._callID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_SyncMessage.CallLogEvent.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CLEARED"),
    1: .same(proto: "MARKED_AS_READ"),
    2: .same(proto: "MARKED_AS_READ_IN_CONVERSATION"),
  ]
}

extension SignalServiceProtos_SyncMessage.DeleteForMe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_SyncMessage.protoMessageName + ".DeleteForMe"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messageDeletes"),
    2: .same(proto: "conversationDeletes"),
    3: .same(proto: "localOnlyConversationDeletes"),
    4: .same(proto: "attachmentDeletes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.messageDeletes) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.conversationDeletes) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.localOnlyConversationDeletes) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.attachmentDeletes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messageDeletes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messageDeletes, fieldNumber: 1)
    }
    if !self.conversationDeletes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.conversationDeletes, fieldNumber: 2)
    }
    if !self.localOnlyConversationDeletes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.localOnlyConversationDeletes, fieldNumber: 3)
    }
    if !self.attachmentDeletes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attachmentDeletes, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_SyncMessage.DeleteForMe, rhs: SignalServiceProtos_SyncMessage.DeleteForMe) -> Bool {
    if lhs.messageDeletes != rhs.messageDeletes {return false}
    if lhs.conversationDeletes != rhs.conversationDeletes {return false}
    if lhs.localOnlyConversationDeletes != rhs.localOnlyConversationDeletes {return false}
    if lhs.attachmentDeletes != rhs.attachmentDeletes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_SyncMessage.DeleteForMe.ConversationIdentifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_SyncMessage.DeleteForMe.protoMessageName + ".ConversationIdentifier"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "threadServiceId"),
    2: .same(proto: "threadGroupId"),
    3: .same(proto: "threadE164"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._threadServiceID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._threadGroupID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._threadE164) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._threadServiceID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._threadGroupID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._threadE164 {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_SyncMessage.DeleteForMe.ConversationIdentifier, rhs: SignalServiceProtos_SyncMessage.DeleteForMe.ConversationIdentifier) -> Bool {
    if lhs._threadServiceID != rhs._threadServiceID {return false}
    if lhs._threadGroupID != rhs._threadGroupID {return false}
    if lhs._threadE164 != rhs._threadE164 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_SyncMessage.DeleteForMe.AddressableMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_SyncMessage.DeleteForMe.protoMessageName + ".AddressableMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authorServiceId"),
    2: .same(proto: "authorE164"),
    3: .same(proto: "sentTimestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._authorServiceID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._authorE164) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._sentTimestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._authorServiceID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._authorE164 {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._sentTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_SyncMessage.DeleteForMe.AddressableMessage, rhs: SignalServiceProtos_SyncMessage.DeleteForMe.AddressableMessage) -> Bool {
    if lhs._authorServiceID != rhs._authorServiceID {return false}
    if lhs._authorE164 != rhs._authorE164 {return false}
    if lhs._sentTimestamp != rhs._sentTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_SyncMessage.DeleteForMe.MessageDeletes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_SyncMessage.DeleteForMe.protoMessageName + ".MessageDeletes"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "conversation"),
    2: .same(proto: "messages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._conversation) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._conversation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_SyncMessage.DeleteForMe.MessageDeletes, rhs: SignalServiceProtos_SyncMessage.DeleteForMe.MessageDeletes) -> Bool {
    if lhs._conversation != rhs._conversation {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_SyncMessage.DeleteForMe.AttachmentDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_SyncMessage.DeleteForMe.protoMessageName + ".AttachmentDelete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "conversation"),
    2: .same(proto: "targetMessage"),
    3: .same(proto: "clientUuid"),
    4: .same(proto: "fallbackDigest"),
    5: .same(proto: "fallbackPlaintextHash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._conversation) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._targetMessage) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._clientUuid) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._fallbackDigest) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._fallbackPlaintextHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._conversation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._targetMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._clientUuid {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._fallbackDigest {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._fallbackPlaintextHash {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_SyncMessage.DeleteForMe.AttachmentDelete, rhs: SignalServiceProtos_SyncMessage.DeleteForMe.AttachmentDelete) -> Bool {
    if lhs._conversation != rhs._conversation {return false}
    if lhs._targetMessage != rhs._targetMessage {return false}
    if lhs._clientUuid != rhs._clientUuid {return false}
    if lhs._fallbackDigest != rhs._fallbackDigest {return false}
    if lhs._fallbackPlaintextHash != rhs._fallbackPlaintextHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_SyncMessage.DeleteForMe.ConversationDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_SyncMessage.DeleteForMe.protoMessageName + ".ConversationDelete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "conversation"),
    2: .same(proto: "mostRecentMessages"),
    4: .same(proto: "mostRecentNonExpiringMessages"),
    3: .same(proto: "isFullDelete"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._conversation) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.mostRecentMessages) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._isFullDelete) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.mostRecentNonExpiringMessages) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._conversation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.mostRecentMessages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mostRecentMessages, fieldNumber: 2)
    }
    try { if let v = self._isFullDelete {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    if !self.mostRecentNonExpiringMessages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mostRecentNonExpiringMessages, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_SyncMessage.DeleteForMe.ConversationDelete, rhs: SignalServiceProtos_SyncMessage.DeleteForMe.ConversationDelete) -> Bool {
    if lhs._conversation != rhs._conversation {return false}
    if lhs.mostRecentMessages != rhs.mostRecentMessages {return false}
    if lhs.mostRecentNonExpiringMessages != rhs.mostRecentNonExpiringMessages {return false}
    if lhs._isFullDelete != rhs._isFullDelete {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_SyncMessage.DeleteForMe.LocalOnlyConversationDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_SyncMessage.DeleteForMe.protoMessageName + ".LocalOnlyConversationDelete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "conversation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._conversation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._conversation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_SyncMessage.DeleteForMe.LocalOnlyConversationDelete, rhs: SignalServiceProtos_SyncMessage.DeleteForMe.LocalOnlyConversationDelete) -> Bool {
    if lhs._conversation != rhs._conversation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_SyncMessage.DeviceNameChange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_SyncMessage.protoMessageName + ".DeviceNameChange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "deviceId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._deviceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._deviceID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_SyncMessage.DeviceNameChange, rhs: SignalServiceProtos_SyncMessage.DeviceNameChange) -> Bool {
    if lhs._deviceID != rhs._deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_AttachmentPointer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AttachmentPointer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cdnId"),
    15: .same(proto: "cdnKey"),
    20: .same(proto: "clientUuid"),
    2: .same(proto: "contentType"),
    3: .same(proto: "key"),
    4: .same(proto: "size"),
    5: .same(proto: "thumbnail"),
    6: .same(proto: "digest"),
    7: .same(proto: "fileName"),
    8: .same(proto: "flags"),
    9: .same(proto: "width"),
    10: .same(proto: "height"),
    11: .same(proto: "caption"),
    12: .same(proto: "blurHash"),
    13: .same(proto: "uploadTimestamp"),
    14: .same(proto: "cdnNumber"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._cdnID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._contentType) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._key) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._size) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._thumbnail) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self._digest) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._fileName) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self._flags) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self._width) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self._height) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self._caption) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self._blurHash) }()
      case 13: try { try decoder.decodeSingularUInt64Field(value: &self._uploadTimestamp) }()
      case 14: try { try decoder.decodeSingularUInt32Field(value: &self._cdnNumber) }()
      case 15: try { try decoder.decodeSingularStringField(value: &self._cdnKey) }()
      case 20: try { try decoder.decodeSingularBytesField(value: &self._clientUuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cdnID {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._contentType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._key {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._size {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._thumbnail {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._digest {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._fileName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._flags {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._width {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._height {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._caption {
      try visitor.visitSingularStringField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._blurHash {
      try visitor.visitSingularStringField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._uploadTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 13)
    } }()
    try { if let v = self._cdnNumber {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 14)
    } }()
    try { if let v = self._cdnKey {
      try visitor.visitSingularStringField(value: v, fieldNumber: 15)
    } }()
    try { if let v = self._clientUuid {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 20)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_AttachmentPointer, rhs: SignalServiceProtos_AttachmentPointer) -> Bool {
    if lhs._cdnID != rhs._cdnID {return false}
    if lhs._cdnKey != rhs._cdnKey {return false}
    if lhs._clientUuid != rhs._clientUuid {return false}
    if lhs._contentType != rhs._contentType {return false}
    if lhs._key != rhs._key {return false}
    if lhs._size != rhs._size {return false}
    if lhs._thumbnail != rhs._thumbnail {return false}
    if lhs._digest != rhs._digest {return false}
    if lhs._fileName != rhs._fileName {return false}
    if lhs._flags != rhs._flags {return false}
    if lhs._width != rhs._width {return false}
    if lhs._height != rhs._height {return false}
    if lhs._caption != rhs._caption {return false}
    if lhs._blurHash != rhs._blurHash {return false}
    if lhs._uploadTimestamp != rhs._uploadTimestamp {return false}
    if lhs._cdnNumber != rhs._cdnNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_AttachmentPointer.Flags: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "VOICE_MESSAGE"),
    2: .same(proto: "BORDERLESS"),
    8: .same(proto: "GIF"),
  ]
}

extension SignalServiceProtos_GroupContextV2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupContextV2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "masterKey"),
    2: .same(proto: "revision"),
    3: .same(proto: "groupChange"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._masterKey) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._revision) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._groupChange) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._masterKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._revision {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._groupChange {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_GroupContextV2, rhs: SignalServiceProtos_GroupContextV2) -> Bool {
    if lhs._masterKey != rhs._masterKey {return false}
    if lhs._revision != rhs._revision {return false}
    if lhs._groupChange != rhs._groupChange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_ContactDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContactDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contactE164"),
    9: .same(proto: "aci"),
    2: .same(proto: "name"),
    3: .same(proto: "avatar"),
    8: .same(proto: "expireTimer"),
    12: .same(proto: "expireTimerVersion"),
    10: .same(proto: "inboxPosition"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._contactE164) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._avatar) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self._expireTimer) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._aci) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self._inboxPosition) }()
      case 12: try { try decoder.decodeSingularUInt32Field(value: &self._expireTimerVersion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._contactE164 {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._avatar {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._expireTimer {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._aci {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._inboxPosition {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._expireTimerVersion {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 12)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_ContactDetails, rhs: SignalServiceProtos_ContactDetails) -> Bool {
    if lhs._contactE164 != rhs._contactE164 {return false}
    if lhs._aci != rhs._aci {return false}
    if lhs._name != rhs._name {return false}
    if lhs._avatar != rhs._avatar {return false}
    if lhs._expireTimer != rhs._expireTimer {return false}
    if lhs._expireTimerVersion != rhs._expireTimerVersion {return false}
    if lhs._inboxPosition != rhs._inboxPosition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_ContactDetails.Avatar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_ContactDetails.protoMessageName + ".Avatar"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contentType"),
    2: .same(proto: "length"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._contentType) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._length) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._contentType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._length {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_ContactDetails.Avatar, rhs: SignalServiceProtos_ContactDetails.Avatar) -> Bool {
    if lhs._contentType != rhs._contentType {return false}
    if lhs._length != rhs._length {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_Pack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Pack"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "author"),
    3: .same(proto: "cover"),
    4: .same(proto: "stickers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._author) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._cover) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.stickers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._title {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._author {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._cover {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.stickers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stickers, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_Pack, rhs: SignalServiceProtos_Pack) -> Bool {
    if lhs._title != rhs._title {return false}
    if lhs._author != rhs._author {return false}
    if lhs._cover != rhs._cover {return false}
    if lhs.stickers != rhs.stickers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_Pack.Sticker: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_Pack.protoMessageName + ".Sticker"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "emoji"),
    3: .same(proto: "contentType"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._emoji) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._contentType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._emoji {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._contentType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_Pack.Sticker, rhs: SignalServiceProtos_Pack.Sticker) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._emoji != rhs._emoji {return false}
    if lhs._contentType != rhs._contentType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_PaymentAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PaymentAddress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mobileCoin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._mobileCoin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mobileCoin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_PaymentAddress, rhs: SignalServiceProtos_PaymentAddress) -> Bool {
    if lhs._mobileCoin != rhs._mobileCoin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_PaymentAddress.MobileCoin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SignalServiceProtos_PaymentAddress.protoMessageName + ".MobileCoin"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicAddress"),
    2: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._publicAddress) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._signature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._publicAddress {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_PaymentAddress.MobileCoin, rhs: SignalServiceProtos_PaymentAddress.MobileCoin) -> Bool {
    if lhs._publicAddress != rhs._publicAddress {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_DecryptionErrorMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DecryptionErrorMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ratchetKey"),
    2: .same(proto: "timestamp"),
    3: .same(proto: "deviceId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._ratchetKey) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._deviceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ratchetKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._deviceID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_DecryptionErrorMessage, rhs: SignalServiceProtos_DecryptionErrorMessage) -> Bool {
    if lhs._ratchetKey != rhs._ratchetKey {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._deviceID != rhs._deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_PniSignatureMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PniSignatureMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pni"),
    2: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._pni) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._signature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pni {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._signature {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_PniSignatureMessage, rhs: SignalServiceProtos_PniSignatureMessage) -> Bool {
    if lhs._pni != rhs._pni {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_BodyRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BodyRange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "length"),
    3: .same(proto: "mentionAci"),
    4: .same(proto: "style"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._start) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._length) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._mentionAci) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._style) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._start {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._length {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._mentionAci {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._style {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_BodyRange, rhs: SignalServiceProtos_BodyRange) -> Bool {
    if lhs._start != rhs._start {return false}
    if lhs._length != rhs._length {return false}
    if lhs._mentionAci != rhs._mentionAci {return false}
    if lhs._style != rhs._style {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SignalServiceProtos_BodyRange.Style: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "BOLD"),
    2: .same(proto: "ITALIC"),
    3: .same(proto: "SPOILER"),
    4: .same(proto: "STRIKETHROUGH"),
    5: .same(proto: "MONOSPACE"),
  ]
}

extension SignalServiceProtos_EditMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EditMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targetSentTimestamp"),
    2: .same(proto: "dataMessage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._targetSentTimestamp) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._dataMessage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._targetSentTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._dataMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SignalServiceProtos_EditMessage, rhs: SignalServiceProtos_EditMessage) -> Bool {
    if lhs._targetSentTimestamp != rhs._targetSentTimestamp {return false}
    if lhs._dataMessage != rhs._dataMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
