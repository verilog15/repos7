//
// Copyright 2019 Signal Messenger, LLC
// SPDX-License-Identifier: AGPL-3.0-only
//

// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: StorageService.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
// Copyright 2019 Signal Messenger, LLC
// SPDX-License-Identifier: AGPL-3.0-only

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum StorageServiceProtos_OptionalBool: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unset // = 0
  case `true` // = 1
  case `false` // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unset
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unset
    case 1: self = .true
    case 2: self = .false
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unset: return 0
    case .true: return 1
    case .false: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [StorageServiceProtos_OptionalBool] = [
    .unset,
    .true,
    .false,
  ]

}

/// If unset - computed as the value of the first byte of SHA-256(msg=CONTACT_ID)
/// modulo the count of colors. Once set the avatar color for a recipient is
/// never recomputed or changed.
///
/// `CONTACT_ID` is the first available identifier from the list:
/// - ServiceIdToBinary(ACI)
/// - E164
/// - ServiceIdToBinary(PNI)
/// - Group Id
enum StorageServiceProtos_AvatarColor: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case a100 // = 0
  case a110 // = 1
  case a120 // = 2
  case a130 // = 3
  case a140 // = 4
  case a150 // = 5
  case a160 // = 6
  case a170 // = 7
  case a180 // = 8
  case a190 // = 9
  case a200 // = 10
  case a210 // = 11
  case UNRECOGNIZED(Int)

  init() {
    self = .a100
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .a100
    case 1: self = .a110
    case 2: self = .a120
    case 3: self = .a130
    case 4: self = .a140
    case 5: self = .a150
    case 6: self = .a160
    case 7: self = .a170
    case 8: self = .a180
    case 9: self = .a190
    case 10: self = .a200
    case 11: self = .a210
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .a100: return 0
    case .a110: return 1
    case .a120: return 2
    case .a130: return 3
    case .a140: return 4
    case .a150: return 5
    case .a160: return 6
    case .a170: return 7
    case .a180: return 8
    case .a190: return 9
    case .a200: return 10
    case .a210: return 11
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [StorageServiceProtos_AvatarColor] = [
    .a100,
    .a110,
    .a120,
    .a130,
    .a140,
    .a150,
    .a160,
    .a170,
    .a180,
    .a190,
    .a200,
    .a210,
  ]

}

struct StorageServiceProtos_StorageItem: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var key: Data = Data()

  /// @required
  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StorageServiceProtos_StorageItems: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Corresponds to the requested
  var items: [StorageServiceProtos_StorageItem] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StorageServiceProtos_StorageManifest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var version: UInt64 = 0

  /// @required
  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StorageServiceProtos_ReadOperation: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var readKey: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StorageServiceProtos_WriteOperation: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var manifest: StorageServiceProtos_StorageManifest {
    get {return _manifest ?? StorageServiceProtos_StorageManifest()}
    set {_manifest = newValue}
  }
  /// Returns true if `manifest` has been explicitly set.
  var hasManifest: Bool {return self._manifest != nil}
  /// Clears the value of `manifest`. Subsequent reads from it will return its default value.
  mutating func clearManifest() {self._manifest = nil}

  var insertItem: [StorageServiceProtos_StorageItem] = []

  var deleteKey: [Data] = []

  var deleteAll: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _manifest: StorageServiceProtos_StorageManifest? = nil
}

struct StorageServiceProtos_ManifestRecord: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var version: UInt64 = 0

  var sourceDevice: UInt32 = 0

  var keys: [StorageServiceProtos_ManifestRecord.Key] = []

  var recordIkm: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Key: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var data: Data = Data()

    /// @required
    var type: StorageServiceProtos_ManifestRecord.Key.TypeEnum = .unknown

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TypeEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case unknown // = 0
      case contact // = 1
      case groupv1 // = 2
      case groupv2 // = 3
      case account // = 4
      case storyDistributionList // = 5
      case callLink // = 7
      case UNRECOGNIZED(Int)

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .contact
        case 2: self = .groupv1
        case 3: self = .groupv2
        case 4: self = .account
        case 5: self = .storyDistributionList
        case 7: self = .callLink
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .contact: return 1
        case .groupv1: return 2
        case .groupv2: return 3
        case .account: return 4
        case .storyDistributionList: return 5
        case .callLink: return 7
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [StorageServiceProtos_ManifestRecord.Key.TypeEnum] = [
        .unknown,
        .contact,
        .groupv1,
        .groupv2,
        .account,
        .storyDistributionList,
        .callLink,
      ]

    }

    init() {}
  }

  init() {}
}

struct StorageServiceProtos_StorageRecord: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var record: StorageServiceProtos_StorageRecord.OneOf_Record? = nil

  var contact: StorageServiceProtos_ContactRecord {
    get {
      if case .contact(let v)? = record {return v}
      return StorageServiceProtos_ContactRecord()
    }
    set {record = .contact(newValue)}
  }

  var groupV1: StorageServiceProtos_GroupV1Record {
    get {
      if case .groupV1(let v)? = record {return v}
      return StorageServiceProtos_GroupV1Record()
    }
    set {record = .groupV1(newValue)}
  }

  var groupV2: StorageServiceProtos_GroupV2Record {
    get {
      if case .groupV2(let v)? = record {return v}
      return StorageServiceProtos_GroupV2Record()
    }
    set {record = .groupV2(newValue)}
  }

  var account: StorageServiceProtos_AccountRecord {
    get {
      if case .account(let v)? = record {return v}
      return StorageServiceProtos_AccountRecord()
    }
    set {record = .account(newValue)}
  }

  var storyDistributionList: StorageServiceProtos_StoryDistributionListRecord {
    get {
      if case .storyDistributionList(let v)? = record {return v}
      return StorageServiceProtos_StoryDistributionListRecord()
    }
    set {record = .storyDistributionList(newValue)}
  }

  var callLink: StorageServiceProtos_CallLinkRecord {
    get {
      if case .callLink(let v)? = record {return v}
      return StorageServiceProtos_CallLinkRecord()
    }
    set {record = .callLink(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Record: Equatable, Sendable {
    case contact(StorageServiceProtos_ContactRecord)
    case groupV1(StorageServiceProtos_GroupV1Record)
    case groupV2(StorageServiceProtos_GroupV2Record)
    case account(StorageServiceProtos_AccountRecord)
    case storyDistributionList(StorageServiceProtos_StoryDistributionListRecord)
    case callLink(StorageServiceProtos_CallLinkRecord)

  }

  init() {}
}

struct StorageServiceProtos_ContactRecord: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var aci: String {
    get {return _storage._aci}
    set {_uniqueStorage()._aci = newValue}
  }

  var e164: String {
    get {return _storage._e164}
    set {_uniqueStorage()._e164 = newValue}
  }

  var pni: String {
    get {return _storage._pni}
    set {_uniqueStorage()._pni = newValue}
  }

  var profileKey: Data {
    get {return _storage._profileKey}
    set {_uniqueStorage()._profileKey = newValue}
  }

  var identityKey: Data {
    get {return _storage._identityKey}
    set {_uniqueStorage()._identityKey = newValue}
  }

  var identityState: StorageServiceProtos_ContactRecord.IdentityState {
    get {return _storage._identityState}
    set {_uniqueStorage()._identityState = newValue}
  }

  var givenName: String {
    get {return _storage._givenName}
    set {_uniqueStorage()._givenName = newValue}
  }

  var familyName: String {
    get {return _storage._familyName}
    set {_uniqueStorage()._familyName = newValue}
  }

  var username: String {
    get {return _storage._username}
    set {_uniqueStorage()._username = newValue}
  }

  var blocked: Bool {
    get {return _storage._blocked}
    set {_uniqueStorage()._blocked = newValue}
  }

  var whitelisted: Bool {
    get {return _storage._whitelisted}
    set {_uniqueStorage()._whitelisted = newValue}
  }

  var archived: Bool {
    get {return _storage._archived}
    set {_uniqueStorage()._archived = newValue}
  }

  var markedUnread: Bool {
    get {return _storage._markedUnread}
    set {_uniqueStorage()._markedUnread = newValue}
  }

  var mutedUntilTimestamp: UInt64 {
    get {return _storage._mutedUntilTimestamp}
    set {_uniqueStorage()._mutedUntilTimestamp = newValue}
  }

  var hideStory: Bool {
    get {return _storage._hideStory}
    set {_uniqueStorage()._hideStory = newValue}
  }

  var unregisteredAtTimestamp: UInt64 {
    get {return _storage._unregisteredAtTimestamp}
    set {_uniqueStorage()._unregisteredAtTimestamp = newValue}
  }

  var systemGivenName: String {
    get {return _storage._systemGivenName}
    set {_uniqueStorage()._systemGivenName = newValue}
  }

  var systemFamilyName: String {
    get {return _storage._systemFamilyName}
    set {_uniqueStorage()._systemFamilyName = newValue}
  }

  var systemNickname: String {
    get {return _storage._systemNickname}
    set {_uniqueStorage()._systemNickname = newValue}
  }

  var hidden: Bool {
    get {return _storage._hidden}
    set {_uniqueStorage()._hidden = newValue}
  }

  var nickname: StorageServiceProtos_ContactRecord.Name {
    get {return _storage._nickname ?? StorageServiceProtos_ContactRecord.Name()}
    set {_uniqueStorage()._nickname = newValue}
  }
  /// Returns true if `nickname` has been explicitly set.
  var hasNickname: Bool {return _storage._nickname != nil}
  /// Clears the value of `nickname`. Subsequent reads from it will return its default value.
  mutating func clearNickname() {_uniqueStorage()._nickname = nil}

  var note: String {
    get {return _storage._note}
    set {_uniqueStorage()._note = newValue}
  }

  var avatarColor: StorageServiceProtos_AvatarColor {
    get {return _storage._avatarColor ?? .a100}
    set {_uniqueStorage()._avatarColor = newValue}
  }
  /// Returns true if `avatarColor` has been explicitly set.
  var hasAvatarColor: Bool {return _storage._avatarColor != nil}
  /// Clears the value of `avatarColor`. Subsequent reads from it will return its default value.
  mutating func clearAvatarColor() {_uniqueStorage()._avatarColor = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum IdentityState: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case `default` // = 0
    case verified // = 1
    case unverified // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .default
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .default
      case 1: self = .verified
      case 2: self = .unverified
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .default: return 0
      case .verified: return 1
      case .unverified: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [StorageServiceProtos_ContactRecord.IdentityState] = [
      .default,
      .verified,
      .unverified,
    ]

  }

  struct Name: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var given: String = String()

    var family: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct StorageServiceProtos_GroupV1Record: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var id: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StorageServiceProtos_GroupV2Record: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var masterKey: Data = Data()

  var blocked: Bool = false

  var whitelisted: Bool = false

  var archived: Bool = false

  var markedUnread: Bool = false

  var mutedUntilTimestamp: UInt64 = 0

  var dontNotifyForMentionsIfMuted: Bool = false

  var hideStory: Bool = false

  var storySendMode: StorageServiceProtos_GroupV2Record.StorySendMode = .default

  var avatarColor: StorageServiceProtos_AvatarColor {
    get {return _avatarColor ?? .a100}
    set {_avatarColor = newValue}
  }
  /// Returns true if `avatarColor` has been explicitly set.
  var hasAvatarColor: Bool {return self._avatarColor != nil}
  /// Clears the value of `avatarColor`. Subsequent reads from it will return its default value.
  mutating func clearAvatarColor() {self._avatarColor = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum StorySendMode: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case `default` // = 0
    case disabled // = 1
    case enabled // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .default
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .default
      case 1: self = .disabled
      case 2: self = .enabled
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .default: return 0
      case .disabled: return 1
      case .enabled: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [StorageServiceProtos_GroupV2Record.StorySendMode] = [
      .default,
      .disabled,
      .enabled,
    ]

  }

  init() {}

  fileprivate var _avatarColor: StorageServiceProtos_AvatarColor? = nil
}

struct StorageServiceProtos_AccountRecord: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var profileKey: Data {
    get {return _storage._profileKey}
    set {_uniqueStorage()._profileKey = newValue}
  }

  var givenName: String {
    get {return _storage._givenName}
    set {_uniqueStorage()._givenName = newValue}
  }

  var familyName: String {
    get {return _storage._familyName}
    set {_uniqueStorage()._familyName = newValue}
  }

  var avatarURL: String {
    get {return _storage._avatarURL}
    set {_uniqueStorage()._avatarURL = newValue}
  }

  var noteToSelfArchived: Bool {
    get {return _storage._noteToSelfArchived}
    set {_uniqueStorage()._noteToSelfArchived = newValue}
  }

  var readReceipts: Bool {
    get {return _storage._readReceipts}
    set {_uniqueStorage()._readReceipts = newValue}
  }

  var sealedSenderIndicators: Bool {
    get {return _storage._sealedSenderIndicators}
    set {_uniqueStorage()._sealedSenderIndicators = newValue}
  }

  var typingIndicators: Bool {
    get {return _storage._typingIndicators}
    set {_uniqueStorage()._typingIndicators = newValue}
  }

  /// Legacy link previews flag
  var proxiedLinkPreviews: Bool {
    get {return _storage._proxiedLinkPreviews}
    set {_uniqueStorage()._proxiedLinkPreviews = newValue}
  }

  var noteToSelfMarkedUnread: Bool {
    get {return _storage._noteToSelfMarkedUnread}
    set {_uniqueStorage()._noteToSelfMarkedUnread = newValue}
  }

  var linkPreviews: Bool {
    get {return _storage._linkPreviews}
    set {_uniqueStorage()._linkPreviews = newValue}
  }

  var phoneNumberSharingMode: StorageServiceProtos_AccountRecord.PhoneNumberSharingMode {
    get {return _storage._phoneNumberSharingMode}
    set {_uniqueStorage()._phoneNumberSharingMode = newValue}
  }

  var notDiscoverableByPhoneNumber: Bool {
    get {return _storage._notDiscoverableByPhoneNumber}
    set {_uniqueStorage()._notDiscoverableByPhoneNumber = newValue}
  }

  var pinnedConversations: [StorageServiceProtos_AccountRecord.PinnedConversation] {
    get {return _storage._pinnedConversations}
    set {_uniqueStorage()._pinnedConversations = newValue}
  }

  var preferContactAvatars: Bool {
    get {return _storage._preferContactAvatars}
    set {_uniqueStorage()._preferContactAvatars = newValue}
  }

  var payments: StorageServiceProtos_AccountRecord.Payments {
    get {return _storage._payments ?? StorageServiceProtos_AccountRecord.Payments()}
    set {_uniqueStorage()._payments = newValue}
  }
  /// Returns true if `payments` has been explicitly set.
  var hasPayments: Bool {return _storage._payments != nil}
  /// Clears the value of `payments`. Subsequent reads from it will return its default value.
  mutating func clearPayments() {_uniqueStorage()._payments = nil}

  var universalExpireTimer: UInt32 {
    get {return _storage._universalExpireTimer}
    set {_uniqueStorage()._universalExpireTimer = newValue}
  }

  var e164: String {
    get {return _storage._e164}
    set {_uniqueStorage()._e164 = newValue}
  }

  var preferredReactionEmoji: [String] {
    get {return _storage._preferredReactionEmoji}
    set {_uniqueStorage()._preferredReactionEmoji = newValue}
  }

  var donorSubscriberID: Data {
    get {return _storage._donorSubscriberID}
    set {_uniqueStorage()._donorSubscriberID = newValue}
  }

  var donorSubscriberCurrencyCode: String {
    get {return _storage._donorSubscriberCurrencyCode}
    set {_uniqueStorage()._donorSubscriberCurrencyCode = newValue}
  }

  var displayBadgesOnProfile: Bool {
    get {return _storage._displayBadgesOnProfile}
    set {_uniqueStorage()._displayBadgesOnProfile = newValue}
  }

  var donorSubscriptionManuallyCancelled: Bool {
    get {return _storage._donorSubscriptionManuallyCancelled}
    set {_uniqueStorage()._donorSubscriptionManuallyCancelled = newValue}
  }

  var keepMutedChatsArchived: Bool {
    get {return _storage._keepMutedChatsArchived}
    set {_uniqueStorage()._keepMutedChatsArchived = newValue}
  }

  /// Removed 'has' prefix on spec definition to avoid name conflict.
  var myStoryPrivacyHasBeenSet: Bool {
    get {return _storage._myStoryPrivacyHasBeenSet}
    set {_uniqueStorage()._myStoryPrivacyHasBeenSet = newValue}
  }

  /// Removed 'has' prefix on spec definition to avoid name conflict.
  var viewedOnboardingStory: Bool {
    get {return _storage._viewedOnboardingStory}
    set {_uniqueStorage()._viewedOnboardingStory = newValue}
  }

  var storiesDisabled: Bool {
    get {return _storage._storiesDisabled}
    set {_uniqueStorage()._storiesDisabled = newValue}
  }

  var storyViewReceiptsEnabled: StorageServiceProtos_OptionalBool {
    get {return _storage._storyViewReceiptsEnabled}
    set {_uniqueStorage()._storyViewReceiptsEnabled = newValue}
  }

  var readOnboardingStory: Bool {
    get {return _storage._readOnboardingStory}
    set {_uniqueStorage()._readOnboardingStory = newValue}
  }

  var username: String {
    get {return _storage._username}
    set {_uniqueStorage()._username = newValue}
  }

  /// Removed 'has' prefix on spec definition to avoid name conflict.
  var completedUsernameOnboarding: Bool {
    get {return _storage._completedUsernameOnboarding}
    set {_uniqueStorage()._completedUsernameOnboarding = newValue}
  }

  var usernameLink: StorageServiceProtos_AccountRecord.UsernameLink {
    get {return _storage._usernameLink ?? StorageServiceProtos_AccountRecord.UsernameLink()}
    set {_uniqueStorage()._usernameLink = newValue}
  }
  /// Returns true if `usernameLink` has been explicitly set.
  var hasUsernameLink: Bool {return _storage._usernameLink != nil}
  /// Clears the value of `usernameLink`. Subsequent reads from it will return its default value.
  mutating func clearUsernameLink() {_uniqueStorage()._usernameLink = nil}

  var backupSubscriberData: StorageServiceProtos_AccountRecord.IAPSubscriberData {
    get {return _storage._backupSubscriberData ?? StorageServiceProtos_AccountRecord.IAPSubscriberData()}
    set {_uniqueStorage()._backupSubscriberData = newValue}
  }
  /// Returns true if `backupSubscriberData` has been explicitly set.
  var hasBackupSubscriberData: Bool {return _storage._backupSubscriberData != nil}
  /// Clears the value of `backupSubscriberData`. Subsequent reads from it will return its default value.
  mutating func clearBackupSubscriberData() {_uniqueStorage()._backupSubscriberData = nil}

  var avatarColor: StorageServiceProtos_AvatarColor {
    get {return _storage._avatarColor ?? .a100}
    set {_uniqueStorage()._avatarColor = newValue}
  }
  /// Returns true if `avatarColor` has been explicitly set.
  var hasAvatarColor: Bool {return _storage._avatarColor != nil}
  /// Clears the value of `avatarColor`. Subsequent reads from it will return its default value.
  mutating func clearAvatarColor() {_uniqueStorage()._avatarColor = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum PhoneNumberSharingMode: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case unknown // = 0
    case everybody // = 1
    case nobody // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .everybody
      case 2: self = .nobody
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .everybody: return 1
      case .nobody: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [StorageServiceProtos_AccountRecord.PhoneNumberSharingMode] = [
      .unknown,
      .everybody,
      .nobody,
    ]

  }

  struct PinnedConversation: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var identifier: StorageServiceProtos_AccountRecord.PinnedConversation.OneOf_Identifier? = nil

    var contact: StorageServiceProtos_AccountRecord.PinnedConversation.Contact {
      get {
        if case .contact(let v)? = identifier {return v}
        return StorageServiceProtos_AccountRecord.PinnedConversation.Contact()
      }
      set {identifier = .contact(newValue)}
    }

    var legacyGroupID: Data {
      get {
        if case .legacyGroupID(let v)? = identifier {return v}
        return Data()
      }
      set {identifier = .legacyGroupID(newValue)}
    }

    var groupMasterKey: Data {
      get {
        if case .groupMasterKey(let v)? = identifier {return v}
        return Data()
      }
      set {identifier = .groupMasterKey(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Identifier: Equatable, @unchecked Sendable {
      case contact(StorageServiceProtos_AccountRecord.PinnedConversation.Contact)
      case legacyGroupID(Data)
      case groupMasterKey(Data)

    }

    struct Contact: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var serviceID: String = String()

      var e164: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  struct Payments: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var enabled: Bool = false

    var paymentsEntropy: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct UsernameLink: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// 32 bytes of entropy used for encryption
    var entropy: Data = Data()

    /// 16 bytes of encoded UUID provided by the server
    var serverID: Data = Data()

    /// color of the QR code itself
    var color: StorageServiceProtos_AccountRecord.UsernameLink.Color = .unknown

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Color: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case unknown // = 0
      case blue // = 1
      case white // = 2
      case grey // = 3
      case olive // = 4
      case green // = 5
      case orange // = 6
      case pink // = 7
      case purple // = 8
      case UNRECOGNIZED(Int)

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .blue
        case 2: self = .white
        case 3: self = .grey
        case 4: self = .olive
        case 5: self = .green
        case 6: self = .orange
        case 7: self = .pink
        case 8: self = .purple
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .blue: return 1
        case .white: return 2
        case .grey: return 3
        case .olive: return 4
        case .green: return 5
        case .orange: return 6
        case .pink: return 7
        case .purple: return 8
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      static let allCases: [StorageServiceProtos_AccountRecord.UsernameLink.Color] = [
        .unknown,
        .blue,
        .white,
        .grey,
        .olive,
        .green,
        .orange,
        .pink,
        .purple,
      ]

    }

    init() {}
  }

  struct IAPSubscriberData: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var subscriberID: Data = Data()

    var iapSubscriptionID: StorageServiceProtos_AccountRecord.IAPSubscriberData.OneOf_IapSubscriptionID? = nil

    /// Identifies an Android Play Store IAP subscription.
    var purchaseToken: String {
      get {
        if case .purchaseToken(let v)? = iapSubscriptionID {return v}
        return String()
      }
      set {iapSubscriptionID = .purchaseToken(newValue)}
    }

    /// Identifies an iOS App Store IAP subscription.
    var originalTransactionID: UInt64 {
      get {
        if case .originalTransactionID(let v)? = iapSubscriptionID {return v}
        return 0
      }
      set {iapSubscriptionID = .originalTransactionID(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_IapSubscriptionID: Equatable, Sendable {
      /// Identifies an Android Play Store IAP subscription.
      case purchaseToken(String)
      /// Identifies an iOS App Store IAP subscription.
      case originalTransactionID(UInt64)

    }

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct StorageServiceProtos_StoryDistributionListRecord: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var identifier: Data = Data()

  var name: String = String()

  var recipientServiceIds: [String] = []

  var deletedAtTimestamp: UInt64 = 0

  var allowsReplies: Bool = false

  var isBlockList: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StorageServiceProtos_CallLinkRecord: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 16 bytes
  var rootKey: Data = Data()

  /// Non-empty when the current user is an admin
  var adminPasskey: Data = Data()

  /// When present and non-zero, `adminPasskey`
  var deletedAtTimestampMs: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "StorageServiceProtos"

extension StorageServiceProtos_OptionalBool: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSET"),
    1: .same(proto: "TRUE"),
    2: .same(proto: "FALSE"),
  ]
}

extension StorageServiceProtos_AvatarColor: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "A100"),
    1: .same(proto: "A110"),
    2: .same(proto: "A120"),
    3: .same(proto: "A130"),
    4: .same(proto: "A140"),
    5: .same(proto: "A150"),
    6: .same(proto: "A160"),
    7: .same(proto: "A170"),
    8: .same(proto: "A180"),
    9: .same(proto: "A190"),
    10: .same(proto: "A200"),
    11: .same(proto: "A210"),
  ]
}

extension StorageServiceProtos_StorageItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StorageItem"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_StorageItem, rhs: StorageServiceProtos_StorageItem) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_StorageItems: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StorageItems"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "items"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_StorageItems, rhs: StorageServiceProtos_StorageItems) -> Bool {
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_StorageManifest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StorageManifest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.version) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != 0 {
      try visitor.visitSingularUInt64Field(value: self.version, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_StorageManifest, rhs: StorageServiceProtos_StorageManifest) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_ReadOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReadOperation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "readKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.readKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.readKey.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.readKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_ReadOperation, rhs: StorageServiceProtos_ReadOperation) -> Bool {
    if lhs.readKey != rhs.readKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_WriteOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WriteOperation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "manifest"),
    2: .same(proto: "insertItem"),
    3: .same(proto: "deleteKey"),
    4: .same(proto: "deleteAll"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._manifest) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.insertItem) }()
      case 3: try { try decoder.decodeRepeatedBytesField(value: &self.deleteKey) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.deleteAll) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._manifest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.insertItem.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.insertItem, fieldNumber: 2)
    }
    if !self.deleteKey.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.deleteKey, fieldNumber: 3)
    }
    if self.deleteAll != false {
      try visitor.visitSingularBoolField(value: self.deleteAll, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_WriteOperation, rhs: StorageServiceProtos_WriteOperation) -> Bool {
    if lhs._manifest != rhs._manifest {return false}
    if lhs.insertItem != rhs.insertItem {return false}
    if lhs.deleteKey != rhs.deleteKey {return false}
    if lhs.deleteAll != rhs.deleteAll {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_ManifestRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ManifestRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    3: .same(proto: "sourceDevice"),
    2: .same(proto: "keys"),
    4: .same(proto: "recordIkm"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.version) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.keys) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.sourceDevice) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.recordIkm) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != 0 {
      try visitor.visitSingularUInt64Field(value: self.version, fieldNumber: 1)
    }
    if !self.keys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keys, fieldNumber: 2)
    }
    if self.sourceDevice != 0 {
      try visitor.visitSingularUInt32Field(value: self.sourceDevice, fieldNumber: 3)
    }
    if !self.recordIkm.isEmpty {
      try visitor.visitSingularBytesField(value: self.recordIkm, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_ManifestRecord, rhs: StorageServiceProtos_ManifestRecord) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.sourceDevice != rhs.sourceDevice {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.recordIkm != rhs.recordIkm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_ManifestRecord.Key: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = StorageServiceProtos_ManifestRecord.protoMessageName + ".Key"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_ManifestRecord.Key, rhs: StorageServiceProtos_ManifestRecord.Key) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_ManifestRecord.Key.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "CONTACT"),
    2: .same(proto: "GROUPV1"),
    3: .same(proto: "GROUPV2"),
    4: .same(proto: "ACCOUNT"),
    5: .same(proto: "STORY_DISTRIBUTION_LIST"),
    7: .same(proto: "CALL_LINK"),
  ]
}

extension StorageServiceProtos_StorageRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StorageRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contact"),
    2: .same(proto: "groupV1"),
    3: .same(proto: "groupV2"),
    4: .same(proto: "account"),
    5: .same(proto: "storyDistributionList"),
    7: .same(proto: "callLink"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: StorageServiceProtos_ContactRecord?
        var hadOneofValue = false
        if let current = self.record {
          hadOneofValue = true
          if case .contact(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.record = .contact(v)
        }
      }()
      case 2: try {
        var v: StorageServiceProtos_GroupV1Record?
        var hadOneofValue = false
        if let current = self.record {
          hadOneofValue = true
          if case .groupV1(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.record = .groupV1(v)
        }
      }()
      case 3: try {
        var v: StorageServiceProtos_GroupV2Record?
        var hadOneofValue = false
        if let current = self.record {
          hadOneofValue = true
          if case .groupV2(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.record = .groupV2(v)
        }
      }()
      case 4: try {
        var v: StorageServiceProtos_AccountRecord?
        var hadOneofValue = false
        if let current = self.record {
          hadOneofValue = true
          if case .account(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.record = .account(v)
        }
      }()
      case 5: try {
        var v: StorageServiceProtos_StoryDistributionListRecord?
        var hadOneofValue = false
        if let current = self.record {
          hadOneofValue = true
          if case .storyDistributionList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.record = .storyDistributionList(v)
        }
      }()
      case 7: try {
        var v: StorageServiceProtos_CallLinkRecord?
        var hadOneofValue = false
        if let current = self.record {
          hadOneofValue = true
          if case .callLink(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.record = .callLink(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.record {
    case .contact?: try {
      guard case .contact(let v)? = self.record else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .groupV1?: try {
      guard case .groupV1(let v)? = self.record else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .groupV2?: try {
      guard case .groupV2(let v)? = self.record else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .account?: try {
      guard case .account(let v)? = self.record else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .storyDistributionList?: try {
      guard case .storyDistributionList(let v)? = self.record else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .callLink?: try {
      guard case .callLink(let v)? = self.record else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_StorageRecord, rhs: StorageServiceProtos_StorageRecord) -> Bool {
    if lhs.record != rhs.record {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_ContactRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContactRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "aci"),
    2: .same(proto: "e164"),
    15: .same(proto: "pni"),
    3: .same(proto: "profileKey"),
    4: .same(proto: "identityKey"),
    5: .same(proto: "identityState"),
    6: .same(proto: "givenName"),
    7: .same(proto: "familyName"),
    8: .same(proto: "username"),
    9: .same(proto: "blocked"),
    10: .same(proto: "whitelisted"),
    11: .same(proto: "archived"),
    12: .same(proto: "markedUnread"),
    13: .same(proto: "mutedUntilTimestamp"),
    14: .same(proto: "hideStory"),
    16: .same(proto: "unregisteredAtTimestamp"),
    17: .same(proto: "systemGivenName"),
    18: .same(proto: "systemFamilyName"),
    19: .same(proto: "systemNickname"),
    20: .same(proto: "hidden"),
    22: .same(proto: "nickname"),
    23: .same(proto: "note"),
    24: .same(proto: "avatarColor"),
  ]

  fileprivate class _StorageClass {
    var _aci: String = String()
    var _e164: String = String()
    var _pni: String = String()
    var _profileKey: Data = Data()
    var _identityKey: Data = Data()
    var _identityState: StorageServiceProtos_ContactRecord.IdentityState = .default
    var _givenName: String = String()
    var _familyName: String = String()
    var _username: String = String()
    var _blocked: Bool = false
    var _whitelisted: Bool = false
    var _archived: Bool = false
    var _markedUnread: Bool = false
    var _mutedUntilTimestamp: UInt64 = 0
    var _hideStory: Bool = false
    var _unregisteredAtTimestamp: UInt64 = 0
    var _systemGivenName: String = String()
    var _systemFamilyName: String = String()
    var _systemNickname: String = String()
    var _hidden: Bool = false
    var _nickname: StorageServiceProtos_ContactRecord.Name? = nil
    var _note: String = String()
    var _avatarColor: StorageServiceProtos_AvatarColor? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _aci = source._aci
      _e164 = source._e164
      _pni = source._pni
      _profileKey = source._profileKey
      _identityKey = source._identityKey
      _identityState = source._identityState
      _givenName = source._givenName
      _familyName = source._familyName
      _username = source._username
      _blocked = source._blocked
      _whitelisted = source._whitelisted
      _archived = source._archived
      _markedUnread = source._markedUnread
      _mutedUntilTimestamp = source._mutedUntilTimestamp
      _hideStory = source._hideStory
      _unregisteredAtTimestamp = source._unregisteredAtTimestamp
      _systemGivenName = source._systemGivenName
      _systemFamilyName = source._systemFamilyName
      _systemNickname = source._systemNickname
      _hidden = source._hidden
      _nickname = source._nickname
      _note = source._note
      _avatarColor = source._avatarColor
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._aci) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._e164) }()
        case 3: try { try decoder.decodeSingularBytesField(value: &_storage._profileKey) }()
        case 4: try { try decoder.decodeSingularBytesField(value: &_storage._identityKey) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._identityState) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._givenName) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._familyName) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._username) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._blocked) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._whitelisted) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._archived) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._markedUnread) }()
        case 13: try { try decoder.decodeSingularUInt64Field(value: &_storage._mutedUntilTimestamp) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._hideStory) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._pni) }()
        case 16: try { try decoder.decodeSingularUInt64Field(value: &_storage._unregisteredAtTimestamp) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._systemGivenName) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._systemFamilyName) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._systemNickname) }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._hidden) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._nickname) }()
        case 23: try { try decoder.decodeSingularStringField(value: &_storage._note) }()
        case 24: try { try decoder.decodeSingularEnumField(value: &_storage._avatarColor) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._aci.isEmpty {
        try visitor.visitSingularStringField(value: _storage._aci, fieldNumber: 1)
      }
      if !_storage._e164.isEmpty {
        try visitor.visitSingularStringField(value: _storage._e164, fieldNumber: 2)
      }
      if !_storage._profileKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._profileKey, fieldNumber: 3)
      }
      if !_storage._identityKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._identityKey, fieldNumber: 4)
      }
      if _storage._identityState != .default {
        try visitor.visitSingularEnumField(value: _storage._identityState, fieldNumber: 5)
      }
      if !_storage._givenName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._givenName, fieldNumber: 6)
      }
      if !_storage._familyName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._familyName, fieldNumber: 7)
      }
      if !_storage._username.isEmpty {
        try visitor.visitSingularStringField(value: _storage._username, fieldNumber: 8)
      }
      if _storage._blocked != false {
        try visitor.visitSingularBoolField(value: _storage._blocked, fieldNumber: 9)
      }
      if _storage._whitelisted != false {
        try visitor.visitSingularBoolField(value: _storage._whitelisted, fieldNumber: 10)
      }
      if _storage._archived != false {
        try visitor.visitSingularBoolField(value: _storage._archived, fieldNumber: 11)
      }
      if _storage._markedUnread != false {
        try visitor.visitSingularBoolField(value: _storage._markedUnread, fieldNumber: 12)
      }
      if _storage._mutedUntilTimestamp != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._mutedUntilTimestamp, fieldNumber: 13)
      }
      if _storage._hideStory != false {
        try visitor.visitSingularBoolField(value: _storage._hideStory, fieldNumber: 14)
      }
      if !_storage._pni.isEmpty {
        try visitor.visitSingularStringField(value: _storage._pni, fieldNumber: 15)
      }
      if _storage._unregisteredAtTimestamp != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._unregisteredAtTimestamp, fieldNumber: 16)
      }
      if !_storage._systemGivenName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._systemGivenName, fieldNumber: 17)
      }
      if !_storage._systemFamilyName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._systemFamilyName, fieldNumber: 18)
      }
      if !_storage._systemNickname.isEmpty {
        try visitor.visitSingularStringField(value: _storage._systemNickname, fieldNumber: 19)
      }
      if _storage._hidden != false {
        try visitor.visitSingularBoolField(value: _storage._hidden, fieldNumber: 20)
      }
      try { if let v = _storage._nickname {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      if !_storage._note.isEmpty {
        try visitor.visitSingularStringField(value: _storage._note, fieldNumber: 23)
      }
      try { if let v = _storage._avatarColor {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 24)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_ContactRecord, rhs: StorageServiceProtos_ContactRecord) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._aci != rhs_storage._aci {return false}
        if _storage._e164 != rhs_storage._e164 {return false}
        if _storage._pni != rhs_storage._pni {return false}
        if _storage._profileKey != rhs_storage._profileKey {return false}
        if _storage._identityKey != rhs_storage._identityKey {return false}
        if _storage._identityState != rhs_storage._identityState {return false}
        if _storage._givenName != rhs_storage._givenName {return false}
        if _storage._familyName != rhs_storage._familyName {return false}
        if _storage._username != rhs_storage._username {return false}
        if _storage._blocked != rhs_storage._blocked {return false}
        if _storage._whitelisted != rhs_storage._whitelisted {return false}
        if _storage._archived != rhs_storage._archived {return false}
        if _storage._markedUnread != rhs_storage._markedUnread {return false}
        if _storage._mutedUntilTimestamp != rhs_storage._mutedUntilTimestamp {return false}
        if _storage._hideStory != rhs_storage._hideStory {return false}
        if _storage._unregisteredAtTimestamp != rhs_storage._unregisteredAtTimestamp {return false}
        if _storage._systemGivenName != rhs_storage._systemGivenName {return false}
        if _storage._systemFamilyName != rhs_storage._systemFamilyName {return false}
        if _storage._systemNickname != rhs_storage._systemNickname {return false}
        if _storage._hidden != rhs_storage._hidden {return false}
        if _storage._nickname != rhs_storage._nickname {return false}
        if _storage._note != rhs_storage._note {return false}
        if _storage._avatarColor != rhs_storage._avatarColor {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_ContactRecord.IdentityState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "VERIFIED"),
    2: .same(proto: "UNVERIFIED"),
  ]
}

extension StorageServiceProtos_ContactRecord.Name: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = StorageServiceProtos_ContactRecord.protoMessageName + ".Name"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "given"),
    2: .same(proto: "family"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.given) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.family) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.given.isEmpty {
      try visitor.visitSingularStringField(value: self.given, fieldNumber: 1)
    }
    if !self.family.isEmpty {
      try visitor.visitSingularStringField(value: self.family, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_ContactRecord.Name, rhs: StorageServiceProtos_ContactRecord.Name) -> Bool {
    if lhs.given != rhs.given {return false}
    if lhs.family != rhs.family {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_GroupV1Record: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupV1Record"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_GroupV1Record, rhs: StorageServiceProtos_GroupV1Record) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_GroupV2Record: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupV2Record"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "masterKey"),
    2: .same(proto: "blocked"),
    3: .same(proto: "whitelisted"),
    4: .same(proto: "archived"),
    5: .same(proto: "markedUnread"),
    6: .same(proto: "mutedUntilTimestamp"),
    7: .same(proto: "dontNotifyForMentionsIfMuted"),
    8: .same(proto: "hideStory"),
    10: .same(proto: "storySendMode"),
    11: .same(proto: "avatarColor"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.masterKey) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.blocked) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.whitelisted) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.archived) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.markedUnread) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.mutedUntilTimestamp) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.dontNotifyForMentionsIfMuted) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.hideStory) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.storySendMode) }()
      case 11: try { try decoder.decodeSingularEnumField(value: &self._avatarColor) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.masterKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.masterKey, fieldNumber: 1)
    }
    if self.blocked != false {
      try visitor.visitSingularBoolField(value: self.blocked, fieldNumber: 2)
    }
    if self.whitelisted != false {
      try visitor.visitSingularBoolField(value: self.whitelisted, fieldNumber: 3)
    }
    if self.archived != false {
      try visitor.visitSingularBoolField(value: self.archived, fieldNumber: 4)
    }
    if self.markedUnread != false {
      try visitor.visitSingularBoolField(value: self.markedUnread, fieldNumber: 5)
    }
    if self.mutedUntilTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.mutedUntilTimestamp, fieldNumber: 6)
    }
    if self.dontNotifyForMentionsIfMuted != false {
      try visitor.visitSingularBoolField(value: self.dontNotifyForMentionsIfMuted, fieldNumber: 7)
    }
    if self.hideStory != false {
      try visitor.visitSingularBoolField(value: self.hideStory, fieldNumber: 8)
    }
    if self.storySendMode != .default {
      try visitor.visitSingularEnumField(value: self.storySendMode, fieldNumber: 10)
    }
    try { if let v = self._avatarColor {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_GroupV2Record, rhs: StorageServiceProtos_GroupV2Record) -> Bool {
    if lhs.masterKey != rhs.masterKey {return false}
    if lhs.blocked != rhs.blocked {return false}
    if lhs.whitelisted != rhs.whitelisted {return false}
    if lhs.archived != rhs.archived {return false}
    if lhs.markedUnread != rhs.markedUnread {return false}
    if lhs.mutedUntilTimestamp != rhs.mutedUntilTimestamp {return false}
    if lhs.dontNotifyForMentionsIfMuted != rhs.dontNotifyForMentionsIfMuted {return false}
    if lhs.hideStory != rhs.hideStory {return false}
    if lhs.storySendMode != rhs.storySendMode {return false}
    if lhs._avatarColor != rhs._avatarColor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_GroupV2Record.StorySendMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "DISABLED"),
    2: .same(proto: "ENABLED"),
  ]
}

extension StorageServiceProtos_AccountRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AccountRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "profileKey"),
    2: .same(proto: "givenName"),
    3: .same(proto: "familyName"),
    4: .same(proto: "avatarUrl"),
    5: .same(proto: "noteToSelfArchived"),
    6: .same(proto: "readReceipts"),
    7: .same(proto: "sealedSenderIndicators"),
    8: .same(proto: "typingIndicators"),
    9: .same(proto: "proxiedLinkPreviews"),
    10: .same(proto: "noteToSelfMarkedUnread"),
    11: .same(proto: "linkPreviews"),
    12: .same(proto: "phoneNumberSharingMode"),
    13: .same(proto: "notDiscoverableByPhoneNumber"),
    14: .same(proto: "pinnedConversations"),
    15: .same(proto: "preferContactAvatars"),
    16: .same(proto: "payments"),
    17: .same(proto: "universalExpireTimer"),
    19: .same(proto: "e164"),
    20: .same(proto: "preferredReactionEmoji"),
    21: .same(proto: "donorSubscriberID"),
    22: .same(proto: "donorSubscriberCurrencyCode"),
    23: .same(proto: "displayBadgesOnProfile"),
    24: .same(proto: "donorSubscriptionManuallyCancelled"),
    25: .same(proto: "keepMutedChatsArchived"),
    26: .same(proto: "myStoryPrivacyHasBeenSet"),
    27: .same(proto: "viewedOnboardingStory"),
    29: .same(proto: "storiesDisabled"),
    30: .same(proto: "storyViewReceiptsEnabled"),
    31: .same(proto: "readOnboardingStory"),
    33: .same(proto: "username"),
    34: .same(proto: "completedUsernameOnboarding"),
    35: .same(proto: "usernameLink"),
    41: .same(proto: "backupSubscriberData"),
    42: .same(proto: "avatarColor"),
  ]

  fileprivate class _StorageClass {
    var _profileKey: Data = Data()
    var _givenName: String = String()
    var _familyName: String = String()
    var _avatarURL: String = String()
    var _noteToSelfArchived: Bool = false
    var _readReceipts: Bool = false
    var _sealedSenderIndicators: Bool = false
    var _typingIndicators: Bool = false
    var _proxiedLinkPreviews: Bool = false
    var _noteToSelfMarkedUnread: Bool = false
    var _linkPreviews: Bool = false
    var _phoneNumberSharingMode: StorageServiceProtos_AccountRecord.PhoneNumberSharingMode = .unknown
    var _notDiscoverableByPhoneNumber: Bool = false
    var _pinnedConversations: [StorageServiceProtos_AccountRecord.PinnedConversation] = []
    var _preferContactAvatars: Bool = false
    var _payments: StorageServiceProtos_AccountRecord.Payments? = nil
    var _universalExpireTimer: UInt32 = 0
    var _e164: String = String()
    var _preferredReactionEmoji: [String] = []
    var _donorSubscriberID: Data = Data()
    var _donorSubscriberCurrencyCode: String = String()
    var _displayBadgesOnProfile: Bool = false
    var _donorSubscriptionManuallyCancelled: Bool = false
    var _keepMutedChatsArchived: Bool = false
    var _myStoryPrivacyHasBeenSet: Bool = false
    var _viewedOnboardingStory: Bool = false
    var _storiesDisabled: Bool = false
    var _storyViewReceiptsEnabled: StorageServiceProtos_OptionalBool = .unset
    var _readOnboardingStory: Bool = false
    var _username: String = String()
    var _completedUsernameOnboarding: Bool = false
    var _usernameLink: StorageServiceProtos_AccountRecord.UsernameLink? = nil
    var _backupSubscriberData: StorageServiceProtos_AccountRecord.IAPSubscriberData? = nil
    var _avatarColor: StorageServiceProtos_AvatarColor? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _profileKey = source._profileKey
      _givenName = source._givenName
      _familyName = source._familyName
      _avatarURL = source._avatarURL
      _noteToSelfArchived = source._noteToSelfArchived
      _readReceipts = source._readReceipts
      _sealedSenderIndicators = source._sealedSenderIndicators
      _typingIndicators = source._typingIndicators
      _proxiedLinkPreviews = source._proxiedLinkPreviews
      _noteToSelfMarkedUnread = source._noteToSelfMarkedUnread
      _linkPreviews = source._linkPreviews
      _phoneNumberSharingMode = source._phoneNumberSharingMode
      _notDiscoverableByPhoneNumber = source._notDiscoverableByPhoneNumber
      _pinnedConversations = source._pinnedConversations
      _preferContactAvatars = source._preferContactAvatars
      _payments = source._payments
      _universalExpireTimer = source._universalExpireTimer
      _e164 = source._e164
      _preferredReactionEmoji = source._preferredReactionEmoji
      _donorSubscriberID = source._donorSubscriberID
      _donorSubscriberCurrencyCode = source._donorSubscriberCurrencyCode
      _displayBadgesOnProfile = source._displayBadgesOnProfile
      _donorSubscriptionManuallyCancelled = source._donorSubscriptionManuallyCancelled
      _keepMutedChatsArchived = source._keepMutedChatsArchived
      _myStoryPrivacyHasBeenSet = source._myStoryPrivacyHasBeenSet
      _viewedOnboardingStory = source._viewedOnboardingStory
      _storiesDisabled = source._storiesDisabled
      _storyViewReceiptsEnabled = source._storyViewReceiptsEnabled
      _readOnboardingStory = source._readOnboardingStory
      _username = source._username
      _completedUsernameOnboarding = source._completedUsernameOnboarding
      _usernameLink = source._usernameLink
      _backupSubscriberData = source._backupSubscriberData
      _avatarColor = source._avatarColor
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._profileKey) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._givenName) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._familyName) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._avatarURL) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._noteToSelfArchived) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._readReceipts) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._sealedSenderIndicators) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._typingIndicators) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._proxiedLinkPreviews) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._noteToSelfMarkedUnread) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._linkPreviews) }()
        case 12: try { try decoder.decodeSingularEnumField(value: &_storage._phoneNumberSharingMode) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._notDiscoverableByPhoneNumber) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._pinnedConversations) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._preferContactAvatars) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._payments) }()
        case 17: try { try decoder.decodeSingularUInt32Field(value: &_storage._universalExpireTimer) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._e164) }()
        case 20: try { try decoder.decodeRepeatedStringField(value: &_storage._preferredReactionEmoji) }()
        case 21: try { try decoder.decodeSingularBytesField(value: &_storage._donorSubscriberID) }()
        case 22: try { try decoder.decodeSingularStringField(value: &_storage._donorSubscriberCurrencyCode) }()
        case 23: try { try decoder.decodeSingularBoolField(value: &_storage._displayBadgesOnProfile) }()
        case 24: try { try decoder.decodeSingularBoolField(value: &_storage._donorSubscriptionManuallyCancelled) }()
        case 25: try { try decoder.decodeSingularBoolField(value: &_storage._keepMutedChatsArchived) }()
        case 26: try { try decoder.decodeSingularBoolField(value: &_storage._myStoryPrivacyHasBeenSet) }()
        case 27: try { try decoder.decodeSingularBoolField(value: &_storage._viewedOnboardingStory) }()
        case 29: try { try decoder.decodeSingularBoolField(value: &_storage._storiesDisabled) }()
        case 30: try { try decoder.decodeSingularEnumField(value: &_storage._storyViewReceiptsEnabled) }()
        case 31: try { try decoder.decodeSingularBoolField(value: &_storage._readOnboardingStory) }()
        case 33: try { try decoder.decodeSingularStringField(value: &_storage._username) }()
        case 34: try { try decoder.decodeSingularBoolField(value: &_storage._completedUsernameOnboarding) }()
        case 35: try { try decoder.decodeSingularMessageField(value: &_storage._usernameLink) }()
        case 41: try { try decoder.decodeSingularMessageField(value: &_storage._backupSubscriberData) }()
        case 42: try { try decoder.decodeSingularEnumField(value: &_storage._avatarColor) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._profileKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._profileKey, fieldNumber: 1)
      }
      if !_storage._givenName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._givenName, fieldNumber: 2)
      }
      if !_storage._familyName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._familyName, fieldNumber: 3)
      }
      if !_storage._avatarURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._avatarURL, fieldNumber: 4)
      }
      if _storage._noteToSelfArchived != false {
        try visitor.visitSingularBoolField(value: _storage._noteToSelfArchived, fieldNumber: 5)
      }
      if _storage._readReceipts != false {
        try visitor.visitSingularBoolField(value: _storage._readReceipts, fieldNumber: 6)
      }
      if _storage._sealedSenderIndicators != false {
        try visitor.visitSingularBoolField(value: _storage._sealedSenderIndicators, fieldNumber: 7)
      }
      if _storage._typingIndicators != false {
        try visitor.visitSingularBoolField(value: _storage._typingIndicators, fieldNumber: 8)
      }
      if _storage._proxiedLinkPreviews != false {
        try visitor.visitSingularBoolField(value: _storage._proxiedLinkPreviews, fieldNumber: 9)
      }
      if _storage._noteToSelfMarkedUnread != false {
        try visitor.visitSingularBoolField(value: _storage._noteToSelfMarkedUnread, fieldNumber: 10)
      }
      if _storage._linkPreviews != false {
        try visitor.visitSingularBoolField(value: _storage._linkPreviews, fieldNumber: 11)
      }
      if _storage._phoneNumberSharingMode != .unknown {
        try visitor.visitSingularEnumField(value: _storage._phoneNumberSharingMode, fieldNumber: 12)
      }
      if _storage._notDiscoverableByPhoneNumber != false {
        try visitor.visitSingularBoolField(value: _storage._notDiscoverableByPhoneNumber, fieldNumber: 13)
      }
      if !_storage._pinnedConversations.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._pinnedConversations, fieldNumber: 14)
      }
      if _storage._preferContactAvatars != false {
        try visitor.visitSingularBoolField(value: _storage._preferContactAvatars, fieldNumber: 15)
      }
      try { if let v = _storage._payments {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      if _storage._universalExpireTimer != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._universalExpireTimer, fieldNumber: 17)
      }
      if !_storage._e164.isEmpty {
        try visitor.visitSingularStringField(value: _storage._e164, fieldNumber: 19)
      }
      if !_storage._preferredReactionEmoji.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._preferredReactionEmoji, fieldNumber: 20)
      }
      if !_storage._donorSubscriberID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._donorSubscriberID, fieldNumber: 21)
      }
      if !_storage._donorSubscriberCurrencyCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._donorSubscriberCurrencyCode, fieldNumber: 22)
      }
      if _storage._displayBadgesOnProfile != false {
        try visitor.visitSingularBoolField(value: _storage._displayBadgesOnProfile, fieldNumber: 23)
      }
      if _storage._donorSubscriptionManuallyCancelled != false {
        try visitor.visitSingularBoolField(value: _storage._donorSubscriptionManuallyCancelled, fieldNumber: 24)
      }
      if _storage._keepMutedChatsArchived != false {
        try visitor.visitSingularBoolField(value: _storage._keepMutedChatsArchived, fieldNumber: 25)
      }
      if _storage._myStoryPrivacyHasBeenSet != false {
        try visitor.visitSingularBoolField(value: _storage._myStoryPrivacyHasBeenSet, fieldNumber: 26)
      }
      if _storage._viewedOnboardingStory != false {
        try visitor.visitSingularBoolField(value: _storage._viewedOnboardingStory, fieldNumber: 27)
      }
      if _storage._storiesDisabled != false {
        try visitor.visitSingularBoolField(value: _storage._storiesDisabled, fieldNumber: 29)
      }
      if _storage._storyViewReceiptsEnabled != .unset {
        try visitor.visitSingularEnumField(value: _storage._storyViewReceiptsEnabled, fieldNumber: 30)
      }
      if _storage._readOnboardingStory != false {
        try visitor.visitSingularBoolField(value: _storage._readOnboardingStory, fieldNumber: 31)
      }
      if !_storage._username.isEmpty {
        try visitor.visitSingularStringField(value: _storage._username, fieldNumber: 33)
      }
      if _storage._completedUsernameOnboarding != false {
        try visitor.visitSingularBoolField(value: _storage._completedUsernameOnboarding, fieldNumber: 34)
      }
      try { if let v = _storage._usernameLink {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
      } }()
      try { if let v = _storage._backupSubscriberData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
      } }()
      try { if let v = _storage._avatarColor {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 42)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_AccountRecord, rhs: StorageServiceProtos_AccountRecord) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._profileKey != rhs_storage._profileKey {return false}
        if _storage._givenName != rhs_storage._givenName {return false}
        if _storage._familyName != rhs_storage._familyName {return false}
        if _storage._avatarURL != rhs_storage._avatarURL {return false}
        if _storage._noteToSelfArchived != rhs_storage._noteToSelfArchived {return false}
        if _storage._readReceipts != rhs_storage._readReceipts {return false}
        if _storage._sealedSenderIndicators != rhs_storage._sealedSenderIndicators {return false}
        if _storage._typingIndicators != rhs_storage._typingIndicators {return false}
        if _storage._proxiedLinkPreviews != rhs_storage._proxiedLinkPreviews {return false}
        if _storage._noteToSelfMarkedUnread != rhs_storage._noteToSelfMarkedUnread {return false}
        if _storage._linkPreviews != rhs_storage._linkPreviews {return false}
        if _storage._phoneNumberSharingMode != rhs_storage._phoneNumberSharingMode {return false}
        if _storage._notDiscoverableByPhoneNumber != rhs_storage._notDiscoverableByPhoneNumber {return false}
        if _storage._pinnedConversations != rhs_storage._pinnedConversations {return false}
        if _storage._preferContactAvatars != rhs_storage._preferContactAvatars {return false}
        if _storage._payments != rhs_storage._payments {return false}
        if _storage._universalExpireTimer != rhs_storage._universalExpireTimer {return false}
        if _storage._e164 != rhs_storage._e164 {return false}
        if _storage._preferredReactionEmoji != rhs_storage._preferredReactionEmoji {return false}
        if _storage._donorSubscriberID != rhs_storage._donorSubscriberID {return false}
        if _storage._donorSubscriberCurrencyCode != rhs_storage._donorSubscriberCurrencyCode {return false}
        if _storage._displayBadgesOnProfile != rhs_storage._displayBadgesOnProfile {return false}
        if _storage._donorSubscriptionManuallyCancelled != rhs_storage._donorSubscriptionManuallyCancelled {return false}
        if _storage._keepMutedChatsArchived != rhs_storage._keepMutedChatsArchived {return false}
        if _storage._myStoryPrivacyHasBeenSet != rhs_storage._myStoryPrivacyHasBeenSet {return false}
        if _storage._viewedOnboardingStory != rhs_storage._viewedOnboardingStory {return false}
        if _storage._storiesDisabled != rhs_storage._storiesDisabled {return false}
        if _storage._storyViewReceiptsEnabled != rhs_storage._storyViewReceiptsEnabled {return false}
        if _storage._readOnboardingStory != rhs_storage._readOnboardingStory {return false}
        if _storage._username != rhs_storage._username {return false}
        if _storage._completedUsernameOnboarding != rhs_storage._completedUsernameOnboarding {return false}
        if _storage._usernameLink != rhs_storage._usernameLink {return false}
        if _storage._backupSubscriberData != rhs_storage._backupSubscriberData {return false}
        if _storage._avatarColor != rhs_storage._avatarColor {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_AccountRecord.PhoneNumberSharingMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "EVERYBODY"),
    2: .same(proto: "NOBODY"),
  ]
}

extension StorageServiceProtos_AccountRecord.PinnedConversation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = StorageServiceProtos_AccountRecord.protoMessageName + ".PinnedConversation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contact"),
    3: .same(proto: "legacyGroupId"),
    4: .same(proto: "groupMasterKey"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: StorageServiceProtos_AccountRecord.PinnedConversation.Contact?
        var hadOneofValue = false
        if let current = self.identifier {
          hadOneofValue = true
          if case .contact(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.identifier = .contact(v)
        }
      }()
      case 3: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.identifier != nil {try decoder.handleConflictingOneOf()}
          self.identifier = .legacyGroupID(v)
        }
      }()
      case 4: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.identifier != nil {try decoder.handleConflictingOneOf()}
          self.identifier = .groupMasterKey(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.identifier {
    case .contact?: try {
      guard case .contact(let v)? = self.identifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .legacyGroupID?: try {
      guard case .legacyGroupID(let v)? = self.identifier else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }()
    case .groupMasterKey?: try {
      guard case .groupMasterKey(let v)? = self.identifier else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_AccountRecord.PinnedConversation, rhs: StorageServiceProtos_AccountRecord.PinnedConversation) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_AccountRecord.PinnedConversation.Contact: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = StorageServiceProtos_AccountRecord.PinnedConversation.protoMessageName + ".Contact"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "serviceId"),
    2: .same(proto: "e164"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serviceID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.e164) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceID, fieldNumber: 1)
    }
    if !self.e164.isEmpty {
      try visitor.visitSingularStringField(value: self.e164, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_AccountRecord.PinnedConversation.Contact, rhs: StorageServiceProtos_AccountRecord.PinnedConversation.Contact) -> Bool {
    if lhs.serviceID != rhs.serviceID {return false}
    if lhs.e164 != rhs.e164 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_AccountRecord.Payments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = StorageServiceProtos_AccountRecord.protoMessageName + ".Payments"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .same(proto: "paymentsEntropy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.paymentsEntropy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if !self.paymentsEntropy.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentsEntropy, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_AccountRecord.Payments, rhs: StorageServiceProtos_AccountRecord.Payments) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.paymentsEntropy != rhs.paymentsEntropy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_AccountRecord.UsernameLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = StorageServiceProtos_AccountRecord.protoMessageName + ".UsernameLink"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entropy"),
    2: .same(proto: "serverId"),
    3: .same(proto: "color"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.entropy) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.serverID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.color) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entropy.isEmpty {
      try visitor.visitSingularBytesField(value: self.entropy, fieldNumber: 1)
    }
    if !self.serverID.isEmpty {
      try visitor.visitSingularBytesField(value: self.serverID, fieldNumber: 2)
    }
    if self.color != .unknown {
      try visitor.visitSingularEnumField(value: self.color, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_AccountRecord.UsernameLink, rhs: StorageServiceProtos_AccountRecord.UsernameLink) -> Bool {
    if lhs.entropy != rhs.entropy {return false}
    if lhs.serverID != rhs.serverID {return false}
    if lhs.color != rhs.color {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_AccountRecord.UsernameLink.Color: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "BLUE"),
    2: .same(proto: "WHITE"),
    3: .same(proto: "GREY"),
    4: .same(proto: "OLIVE"),
    5: .same(proto: "GREEN"),
    6: .same(proto: "ORANGE"),
    7: .same(proto: "PINK"),
    8: .same(proto: "PURPLE"),
  ]
}

extension StorageServiceProtos_AccountRecord.IAPSubscriberData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = StorageServiceProtos_AccountRecord.protoMessageName + ".IAPSubscriberData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscriberId"),
    2: .same(proto: "purchaseToken"),
    3: .same(proto: "originalTransactionId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.subscriberID) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.iapSubscriptionID != nil {try decoder.handleConflictingOneOf()}
          self.iapSubscriptionID = .purchaseToken(v)
        }
      }()
      case 3: try {
        var v: UInt64?
        try decoder.decodeSingularUInt64Field(value: &v)
        if let v = v {
          if self.iapSubscriptionID != nil {try decoder.handleConflictingOneOf()}
          self.iapSubscriptionID = .originalTransactionID(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.subscriberID.isEmpty {
      try visitor.visitSingularBytesField(value: self.subscriberID, fieldNumber: 1)
    }
    switch self.iapSubscriptionID {
    case .purchaseToken?: try {
      guard case .purchaseToken(let v)? = self.iapSubscriptionID else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .originalTransactionID?: try {
      guard case .originalTransactionID(let v)? = self.iapSubscriptionID else { preconditionFailure() }
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_AccountRecord.IAPSubscriberData, rhs: StorageServiceProtos_AccountRecord.IAPSubscriberData) -> Bool {
    if lhs.subscriberID != rhs.subscriberID {return false}
    if lhs.iapSubscriptionID != rhs.iapSubscriptionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_StoryDistributionListRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StoryDistributionListRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
    2: .same(proto: "name"),
    3: .same(proto: "recipientServiceIds"),
    4: .same(proto: "deletedAtTimestamp"),
    5: .same(proto: "allowsReplies"),
    6: .same(proto: "isBlockList"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.identifier) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.recipientServiceIds) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.deletedAtTimestamp) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.allowsReplies) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isBlockList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identifier.isEmpty {
      try visitor.visitSingularBytesField(value: self.identifier, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.recipientServiceIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.recipientServiceIds, fieldNumber: 3)
    }
    if self.deletedAtTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.deletedAtTimestamp, fieldNumber: 4)
    }
    if self.allowsReplies != false {
      try visitor.visitSingularBoolField(value: self.allowsReplies, fieldNumber: 5)
    }
    if self.isBlockList != false {
      try visitor.visitSingularBoolField(value: self.isBlockList, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_StoryDistributionListRecord, rhs: StorageServiceProtos_StoryDistributionListRecord) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs.name != rhs.name {return false}
    if lhs.recipientServiceIds != rhs.recipientServiceIds {return false}
    if lhs.deletedAtTimestamp != rhs.deletedAtTimestamp {return false}
    if lhs.allowsReplies != rhs.allowsReplies {return false}
    if lhs.isBlockList != rhs.isBlockList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StorageServiceProtos_CallLinkRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CallLinkRecord"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rootKey"),
    2: .same(proto: "adminPasskey"),
    3: .same(proto: "deletedAtTimestampMs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.rootKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.adminPasskey) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.deletedAtTimestampMs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rootKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.rootKey, fieldNumber: 1)
    }
    if !self.adminPasskey.isEmpty {
      try visitor.visitSingularBytesField(value: self.adminPasskey, fieldNumber: 2)
    }
    if self.deletedAtTimestampMs != 0 {
      try visitor.visitSingularUInt64Field(value: self.deletedAtTimestampMs, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StorageServiceProtos_CallLinkRecord, rhs: StorageServiceProtos_CallLinkRecord) -> Bool {
    if lhs.rootKey != rhs.rootKey {return false}
    if lhs.adminPasskey != rhs.adminPasskey {return false}
    if lhs.deletedAtTimestampMs != rhs.deletedAtTimestampMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
